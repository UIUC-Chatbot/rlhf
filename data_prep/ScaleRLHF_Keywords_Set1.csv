attachments_json,metadata
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a finite state machine?\n#### Option 1\n-------\nA finite state machine (FSM) is a model of computation used to design both computer programs and sequential logic circuits. It is conceived as an abstract machine that can be in one of a finite number of user-specified states. An FSM is defined by a list of its states, its initial state, and the inputs and outputs that trigger each transition.\\n\n\nFSMs are of two types: Mealy machine and Moore machine. In a Mealy machine, the output depends on the present state and the current input. In a Moore machine, the output only depends on the present state.\\n\n\nFSMs can be used to design both synchronous and asynchronous circuits. In synchronous circuits, the output changes only on certain clock edges, whereas in asynchronous circuits, the output changes as soon as the input changes.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA finite state machine is a machine that can be in one of a finite number of states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA finite state machine is a mathematical model of computation that can be implemented in hardware or software. It is a abstract machine that can be in one of a finite number of states. The machine is in only one state at a time; it can change from one state to another when triggered by some input. An FSM can output some value when it is in a certain state.""
 }
]","{
 ""id"": 1
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the basic steps of designing a finite state machine?\n#### Option 1\n-------\nThe basic steps of designing a finite state machine are as follows:\\n\n1) Develop an abstract model of the system. This model should describe the system's behavior in terms of a set of states and the transitions between them.\\n\n2) Translate the abstract model into a concrete state transition diagram. This diagram should show all of the states and transitions in the system, as well as the inputs and outputs associated with each transition.\\n\n3) Implement the state transition diagram in hardware. This implementation will typically use flip-flops to store the current state of the system, and logic gates to implement the state transitions.\\n\n4) Initialize the system. This step is necessary to ensure that the system starts in a known state.\\n\n5) Test the system. This step is necessary to ensure that the system behaves as expected.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe basic steps of designing a finite state machine are: 1) developing an abstract model; 2) implementing functions for the next-state variables and output signals; and 3) translating a concrete and complete state transition diagram into an implementation based on flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe basic steps of designing a finite state machine are:\n\n1. Develop an abstract model\n2. Specify I/O behavior\n3. Complete the specification\n4. Choose a state representation\n5. Calculate logic expressions\n6. Implement with flip-flops and gates""
 }
]","{
 ""id"": 2
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is an example of a design that is more intuitive and easier for humans to understand?\n#### Option 1\n-------\nA design that is more intuitive and easier for humans to understand is one that is more abstract and less concrete. In our first few examples, we only consider the concrete aspects of FSM design: we implement several counters, which illustrate the basic process of translating a concrete and complete state transition diagram into an implementation based on flip-flops and logic gates. However, we next consider a counter with a number of states that is not a power of two, with which we illustrate the need for FSM initialization. As part of solving the initialization problem, we also introduce a general form of selection logic called a multiplexer.\n\nBy working from an abstract model down to an implementation, we illustrate how semantic knowledge from the abstract model can be used to simplify the implementation. This is an example of a design that is more intuitive and easier for humans to understand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA counter with multiple inputs to control its behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nOne example of a design that is more intuitive and easier for humans to understand is a counter with multiple inputs to control its behavior. By working from an abstract model down to an implementation, designers can illustrate how semantic knowledge from the abstract model can be used to simplify the implementation. Additionally, by choosing a state representation that is more intuitive and easier for humans to understand, the complexity of the implementation can be reduced.""
 }
]","{
 ""id"": 3
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the design process for a digital FSM?\n#### Option 1\n-------\nThe design process for a digital FSM typically consists of four steps:\n\n1. Develop an abstract model of the FSM. This model should specify the FSM's inputs, outputs, and states, as well as the conditions under which the FSM should transition from one state to another.\n\n2. Implement functions for the next-state variables and output signals. These functions should be based on the abstract model developed in step 1.\n\n3. Choose a representation for the FSM's internal state. This representation will affect the complexity of the implementation.\n\n4. Implement the FSM using flip-flops and logic gates. The implementation should be based on the functions developed in step 2 and the chosen state representation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWe begin with an overview of the design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for a digital FSM typically consists of six steps: developing an abstract model, specifying I/O behavior, completing the specification, choosing a state representation, calculating logic expressions, and implementing with flip-flops and gates.""
 }
]","{
 ""id"": 4
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is an example of a counter with a number of states that is not a power of two?\n#### Option 1\n-------\nAn example of a counter with a number of states that is not a power of two is a counter with three states. In this case, the states are represented by the numbers 0, 1, and 2. The counter goes through the states in the order 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA counter with a number of states that is not a power of two is an example of a counter that needs FSM initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nOne example of a counter with a number of states that is not a power of two is a counter with three states. This counter would have a state transition diagram that looks like this:\n\nState 0: If the input is 0, stay in state 0. If the input is 1, go to state 1.\n\nState 1: If the input is 0, go to state 2. If the input is 1, stay in state 1.\n\nState 2: If the input is 0, go to state 0. If the input is 1, go to state 1.""
 }
]","{
 ""id"": 5
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the general form of selection logic called a multiplexer?\n#### Option 1\n-------\nA multiplexer is a general form of selection logic that allows for the selection of one of several input signals. The input signals are typically encoded as a binary number, with the most significant bit (MSB) corresponding to the selection of the first input signal, the second most significant bit corresponding to the selection of the second input signal, and so on. The output of the multiplexer is the selected input signal.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA multiplexer is a general form of selection logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA multiplexer is a general form of selection logic that allows for the selection of one of several input signals based on the value of a control signal. A multiplexer can be used to simplify the implementation of an FSM by allowing for the selection of the next state based on the value of the current state and the input signal.""
 }
]","{
 ""id"": 6
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to have a clear understanding of the abstract model when designing a FSM?\n#### Option 1\n-------\nIt is important to have a clear understanding of the abstract model when designing a FSM because the abstract model provides a clear and concise description of the FSM's desired behavior. This description can be used to simplify the implementation of the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nHaving a clear understanding of the abstract model is important when designing a FSM because it allows for a simpler implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt is important to have a clear understanding of the abstract model when designing a FSM because the abstract model provides a clear and concise description of the desired behavior of the FSM. The abstract model can be used to generate logic expressions for the next-state variables and the output signals, which can then be used to implement the FSM.""
 }
]","{
 ""id"": 7
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the choice of representation for the FSM's internal state affect the complexity of the implementation?\n#### Option 1\n-------\nThe choice of representation for the FSM's internal state can affect the complexity of the implementation in a number of ways. For example, if the internal state is represented as a sequence of bits, the number of flip-flops required to implement the FSM will be proportional to the number of bits in the state. If the internal state is represented as a number, the number of flip-flops required will be proportional to the number of digits in the state. In addition, the choice of representation can affect the complexity of the logic required to implement the next-state and output functions. For example, if the internal state is represented as a sequence of bits, the next-state function can be implemented using a simple combinational logic circuit. If the internal state is represented as a number, the next-state function can be implemented using a sequential logic circuit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe choice of representation for the FSM's internal state can affect the complexity of the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n""
 }
]","{
 ""id"": 8
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can semantic knowledge from the abstract model be used to simplify the implementation?\n#### Option 1\n-------\nSemantic knowledge from the abstract model can be used to simplify the implementation in a number of ways. For example, if we know that the FSM will always be in a particular state when it receives a particular input, we can use that knowledge to simplify the logic for the next-state variables. Alternatively, if we know that the output of the FSM will only depend on the current state, we can use that knowledge to simplify the logic for the output signals.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nBy using semantic knowledge from the abstract model, the implementation can be simplified.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nSemantic knowledge from the abstract model can be used to simplify the implementation by reducing the number of logic expressions that need to be derived. For example, if the abstract model includes information about which states are reachable from other states, this can be used to simplify the logic expressions for the next-state variables. Similarly, if the abstract model includes information about the output behavior of the FSM, this can be used to simplify the logic expressions for the output signals.""
 }
]","{
 ""id"": 9
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a finite state machine?\n#### Option 1\n-------\nA finite state machine (FSM) is a model of computation used to design both computer programs and sequential logic circuits. It is conceived as an abstract machine that can be in one of a finite number of user-specified states. An FSM is defined by a list of its states, its initial state, and the conditions for each transition.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA finite state machine is a digital logic design that uses flip-flops and logic gates to implement a state transition diagram.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA finite state machine is a mathematical model of computation that can be used to design digital logic circuits. It is a way of representing the behavior of a system as a set of states and transitions between those states. The states represent the different modes that the system can be in, and the transitions represent the events that can cause the system to change from one state to another.""
 }
]","{
 ""id"": 10
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are some applications of finite state machines?\n#### Option 1\n-------\nFinite state machines are a fundamental concept in computer science, and they have a wide range of applications. \n\nOne common application is in modeling sequential circuits. Sequential circuits are digital circuits whose output depends not only on the current input, but also on the previous history of inputs. This makes them more difficult to design and analyze than combinational circuits, which only depend on the current input. Finite state machines can be used to model sequential circuits, and this can simplify the design process.\n\nAnother common application is in computer programming. Many programming languages support finite state machines as a way of modeling the behavior of a program. This can be helpful in designing and understanding the behavior of complex programs.\n\nFinally, finite state machines are also used in artificial intelligence and machine learning. They can be used to model the behavior of agents in a simulated environment, and this can be used to train the agents to behave in a desired way.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nFinite state machines are used in a variety of applications, including digital logic design, computer programming, and artificial intelligence.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nOne application of finite state machines is in the design of digital logic circuits. For example, a simple counter circuit can be designed as a finite state machine. Counters are used in a variety of applications, such as digital clocks and timers. Another application of finite state machines is in the design of computer programs. For example, a program that checks whether a given string is a valid identifier can be designed as a finite state machine.""
 }
]","{
 ""id"": 11
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How do you design a finite state machine?\n#### Option 1\n-------\nThe design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWe work from an abstract model down to an implementation, illustrating how semantic knowledge from the abstract model can be used to simplify the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are six steps in the design process for a digital finite state machine (FSM):\n\n1. Develop an abstract model. This step involves translating the description of the FSM into a model with states and desired behavior. The goal at this stage is simply to capture the intent of the description, and accuracy and thoroughness are not as important.\n\n2. Specify I/O behavior. In this step, the input and output behavior of the FSM is formalized. All input and output must be in the form of bits if the FSM is to be implemented as a digital system.\n\n3. Complete the specification. In this step, any implicit assumptions are made clear, and any other decisions necessary to the design are made. Sometimes, it may be helpful to leave something undecided in the hope of simplifying the design with \""don't care\"" entries in the logic formulation.\n\n4. Choose a state representation. In this step, an internal representation for the bits necessary to encode the state of the FSM is selected. For small designs, this representation can be selected by a computer in such a way as to optimize the implementation. However, for large designs, such as the LC-3 instruction set architecture, humans typically do most of the work by hand.\n\n5. Calculate logic expressions. In this step, the next-state variables and the output signals are derived from the complete specification.\n\n6. Implement with flip""
 }
]","{
 ""id"": 12
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is an FSM?\n#### Option 1\n-------\nA finite state machine (FSM) is a model of computation used to design both computer programs and sequential logic circuits. It is conceived as an abstract machine that can be in one of a finite number of user-specified states. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition.\\n\nFSMs are of two types:\\n\n1. Mealy machine\\n\n2. Moore machine\\n\nMealy machine produces output as soon as the input is given, i.e., output depends on the present state and the present input.\\n\nMoore machine produces output only when the state changes i.e., output depends only on the present state and not on the present input.\\n\n\nThe design process of an FSM involves the following steps:\\n\n1. Develop an abstract model of the system to be implemented, including a state transition diagram that specifies the behavior of the system.\\n\n2. Choose a representation for the FSM's internal state.\\n\n3. For each state, determine the logic functions for the next-state variables and output signals.\\n\n4. Implement the FSM using flip-flops and logic gates.\\n\n5. Verify the correctness of the design using simulation.\\""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA finite state machine (FSM) is a digital logic design pattern that encodes the behavior of a system as a sequence of states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA finite state machine (FSM) is a model of computation that can be implemented using digital logic. An FSM consists of a set of states, a set of inputs, a set of outputs, and a set of transitions between states. The transitions are triggered by the inputs and determine the next state of the machine. The outputs are determined by the current state of the machine.""
 }
]","{
 ""id"": 13
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the design process for a digital FSM?\n#### Option 1\n-------\nThe design process for a digital FSM typically begins with the development of an abstract model. This model is then used to generate functions for the next-state variables and output signals. The design process can be further simplified by choosing a representation for the FSM's internal state that is more intuitive and easier for humans to understand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWe begin with an overview of the design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for a digital FSM typically consists of six steps: developing an abstract model, specifying I/O behavior, completing the specification, choosing a state representation, calculating logic expressions, and implementing with flip-flops and gates.""
 }
]","{
 ""id"": 14
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the concrete aspects of implementing an FSM?\n#### Option 1\n-------\nThe concrete aspects of implementing an FSM include the development of an abstract model, the implementation of functions for the next-state variables and output signals, and the choice of representation for the FSM's internal state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe concrete aspects of implementing an FSM include developing an abstract model, specifying I/O behavior, completing the specification, choosing a state representation, calculating logic expressions, and implementing with flip-flops and gates.""
 }
]","{
 ""id"": 15
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a finite state machine?\n#### Option 1\n-------\nA finite state machine (FSM) is a mathematical model of computation used to design both computer programs and sequential logic circuits. It is conceived as an abstract machine that can be in one of a finite number of user-specified states. An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA finite state machine is a digital logic circuit that can be in one of a finite number of states. The state of the machine is determined by the inputs to the circuit, and the output of the circuit depends on the state of the machine.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA finite state machine is a machine that can be in one of a finite number of states. The machine can change from one state to another in response to some inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition.""
 }
]","{
 ""id"": 16
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are some design principles for implementing a finite state machine?\n#### Option 1\n-------\nThere are a few key design principles to keep in mind when implementing a finite state machine:\n\n1. Start with an abstract model: This will help you to understand the desired behavior of the FSM and identify the states and transitions that need to be implemented.\n\n2. Use flip-flops and logic gates: These are the basic building blocks of FSMs.\n\n3. Initialize the FSM: This is necessary to ensure that the FSM starts in the correct state.\n\n4. Use a multiplexer: This is a type of selection logic that can be used to simplify the implementation of FSMs.\n\n5. Choose an appropriate representation for the internal state: This can affect the complexity of the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nSome design principles for implementing a finite state machine are:\n\n1) Develop an abstract model: Translate the description of the FSM into a model with states and desired behavior.\n\n2) Specify I/O behavior: Formalize the model by specifying its input and output behavior.\n\n3) Complete the specification: Make any implicit assumptions clear and make any other decisions necessary to the design.\n\n4) Choose a state representation: Select an internal representation for the bits necessary to encode the state of the FSM.\n\n5) Calculate logic expressions: Derive logic expressions for the next-state variables and the output signals.\n\n6) Implement with flip-flops and gates: Use flip-flops and logic gates to implement the FSM.""
 }
]","{
 ""id"": 17
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is an example of a counter with multiple inputs to control its behavior?\n#### Option 1\n-------\nA counter with multiple inputs to control its behavior is an example of a more complex FSM. In this case, the inputs can be used to control the sequence of states that the FSM goes through. For example, a counter with two inputs could be used to count up or down, depending on the input.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA counter with multiple inputs to control its behavior is an example of how the choice of representation for the FSM's internal state affects the complexity of the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nOne example of a counter with multiple inputs to control its behavior is a digital stopwatch. A digital stopwatch typically has inputs for starting and stopping the timer, as well as inputs for resetting the timer to zero. The behavior of the stopwatch is controlled by these inputs; for instance, when the start input is asserted, the timer begins counting up from zero. When the stop input is asserted, the timer stops counting. And when the reset input is asserted, the timer is reset to zero.""
 }
]","{
 ""id"": 18
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the design process for a digital FSM?\n#### Option 1\n-------\nThe design process for a digital FSM typically begins with the development of an abstract model. This model is then used to determine the functions for the next-state variables and output signals. Once these functions have been determined, the FSM can be implemented using flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for a digital FSM typically consists of six steps: developing an abstract model, specifying I/O behavior, completing the specification, choosing a state representation, calculating logic expressions, and implementing with flip-flops and gates.""
 }
]","{
 ""id"": 19
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are some examples of counters?\n#### Option 1\n-------\nCounters are digital devices that can keep track of the number of events that occur over a period of time. They are often used in applications where it is important to know how many times something happens, such as in manufacturing or security. Counters can be simple devices that just count the number of events, or they can be more complex devices that also keep track of the time between events.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe note provides several examples of counters, which illustrate the basic process of translating a state transition diagram into an implementation based on flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nCounters are devices that keep track of the number of times something happens. They are often used in applications where a precise count is needed, such as in scientific experiments, manufacturing processes, and data collection. There are many different types of counters, each with its own advantages and disadvantages. Some of the most common types of counters include binary counters, ring counters, and Gray code counters.""
 }
]","{
 ""id"": 20
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the need for FSM initialization?\n#### Option 1\n-------\nThe need for FSM initialization arises when the number of states in the FSM is not a power of two. In this case, the FSM cannot be reset to its original state using only the flip-flops and logic gates. To solve this problem, a multiplexer is used. The multiplexer allows the FSM to be reset to its original state by selecting the correct input.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe need for FSM initialization is illustrated by a counter with a number of states that is not a power of two.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe need for FSM initialization arises when the number of states in the FSM is not a power of two. In such cases, the FSM cannot be implemented using flip-flops and logic gates alone. Multiplexers must be used to select the correct state.""
 }
]","{
 ""id"": 21
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the design process for a digital FSM work?\n#### Option 1\n-------\nThe design process for a digital FSM typically begins with the development of an abstract model. This model is then used to determine the next-state variables and output signals. The next-state variables and output signals are then implemented using flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for a digital FSM starts with an abstract model, which is then translated into an implementation with flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for a digital FSM typically follows six steps: \n\n1. Develop an abstract model. This step involves translating the description of the FSM into a model with states and desired behavior. \n\n2. Specify I/O behavior. In this step, the input and output behavior of the FSM is formalized. All input and output must be in the form of bits. \n\n3. Complete the specification. This step involves making any implicit assumptions clear and making any other decisions necessary to the design. \n\n4. Choose a state representation. In this step, an internal representation for the bits necessary to encode the state of the FSM is selected. \n\n5. Calculate logic expressions. In this step, logic expressions for the next-state variables and the output signals are derived. \n\n6. Implement with flip-flops and gates. In this step, the FSM is implemented using flip-flops and gates.""
 }
]","{
 ""id"": 22
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to have an abstract model when designing an FSM?\n#### Option 1\n-------\nIt is important to have an abstract model when designing an FSM because it allows for a clear understanding of the desired behavior of the FSM. The abstract model can be used to simplify the implementation by providing semantic knowledge about the desired behavior of the FSM. Additionally, the choice of representation for the FSM's internal state can affect the complexity of the implementation, and designs that are more intuitive and easier for humans to understand typically make the best designs in terms of other metrics, such as logic complexity.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nHaving an abstract model helps to simplify the implementation of an FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt is important to have an abstract model when designing an FSM because it allows the designer to capture the intent of the description and to make any implicit assumptions clear. By formalizing the model, the designer can also start to specify the I/O behavior for the FSM. This makes it easier to develop an implementation of the FSM as a digital system.""
 }
]","{
 ""id"": 23
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the choice of representation for the FSM's internal state affect the complexity of the implementation?\n#### Option 1\n-------\nThe choice of representation for the FSM's internal state can affect the complexity of the implementation in a number of ways. For example, if the internal state is represented as a binary number, the number of states that can be represented is limited by the number of bits in the number. If the internal state is represented as a decimal number, the number of states that can be represented is limited by the number of digits in the number. If the internal state is represented as an alphabetical string, the number of states that can be represented is limited by the number of characters in the string.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe choice of representation for the FSM's internal state can affect the complexity of the implementation by making it more difficult for humans to understand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe choice of representation for the FSM's internal state can affect the complexity of the implementation in a number of ways. First, if the representation is not well-chosen, it can lead to a large number of states that are not easily distinguishable from one another. This can make the implementation more complex, as the logic expressions for the next-state variables and output signals must be more complex in order to correctly encode the desired behavior. Second, if the representation is not well-chosen, it can lead to a large number of states that are not easily reachable from the initial state. This can again make the implementation more complex, as the logic expressions for the next-state variables and output signals must be more complex in order to correctly encode the desired behavior. Finally, if the representation is not well-chosen, it can lead to a large number of states that are not easily reset to the initial state. This can make the implementation even more complex, as the logic expressions for the next-state variables and output signals must be even more complex in order to correctly encode the desired behavior.""
 }
]","{
 ""id"": 24
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the six steps in the design process?\n#### Option 1\n-------\nThe six steps in the design process are as follows: develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe six steps in the design process are developing an abstract model, specifying I/O behavior, completing the specification, choosing a state representation, calculating logic expressions, and implementing with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe six steps in the design process are:\n\n1. Develop an abstract model\n2. Specify I/O behavior\n3. Complete the specification\n4. Choose a state representation\n5. Calculate logic expressions\n6. Implement with flip-flops and gates""
 }
]","{
 ""id"": 25
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 26
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the last step in the design process?\n#### Option 1\n-------\nThe last step in the design process is to implement the FSM with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe last step in the design process is to implement the FSM with gates and flip-flops.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe last step in the design process is to implement the FSM with flip-flops and gates.""
 }
]","{
 ""id"": 27
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 28
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does Step 2 involve?\n#### Option 1\n-------\nIn Step 2, we formalize the model, starting with its input and output behavior. If we eventually plan to develop an implementation of our FSM as a digital system (which is not the only choice, of course!), all input and output must consist of bits. Often, input and/or output specifications may need to match other digital systems to which we plan to connect our FSM. In fact, most problems in developing large digital systems today arise because of incompatibilities when composing two or more separately designed pieces (or modules) into an integrated system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStep 2 involves formalizing the model, starting with its input and output behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn Step 2, we translate our description in human language into a model with states and desired behavior. We simply try to capture the intent of the description and are not particularly thorough nor exact.""
 }
]","{
 ""id"": 29
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the final step in the design process?\n#### Option 1\n-------\nThe final step in the design process is to implement the logic expressions with gates and flip-flops.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe final step in the design process is to implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe final step in the design process is to implement the FSM with flip-flops and gates.""
 }
]","{
 ""id"": 30
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to have compatible digital systems when developing large digital systems?\n#### Option 1\n-------\nIt is important to have compatible digital systems when developing large digital systems because incompatibilities can lead to problems when composing two or more separately designed pieces into an integrated system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIncompatibilities when composing two or more separately designed pieces can lead to problems in developing large digital systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt is important to have compatible digital systems when developing large digital systems because incompatibilities can lead to problems when composing two or more separately designed pieces into an integrated system. For example, if two digital systems are not compatible, they may not be able to communicate with each other properly, which can lead to errors.""
 }
]","{
 ""id"": 31
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does abstraction simplify the implementation process?\n#### Option 1\n-------\nAbstraction is a powerful tool that can be used to simplify the implementation process in a number of ways. \n\nFirst, abstraction can be used to hide complexity. For example, when designing a state machine, we can use abstraction to hide the details of the state transition functions, making the design process simpler and more efficient. \n\nSecond, abstraction can be used to make the design process more modular. By modularity, we mean the ability to design and implement different parts of a system independently of each other. This is particularly important in the context of state machine design, where different states may need to be implemented by different people or teams. \n\nThird, abstraction can be used to improve the quality of a design. This is because abstraction can help us to identify and isolate errors and design flaws. \n\nFourth, abstraction can be used to reduce the cost of a design. This is because abstraction can help us to reuse design components, which can save time and money. \n\nFinally, abstraction can be used to improve the flexibility of a design. This is because abstraction can help us to change the implementation of a design without affecting the rest of the system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nBy Step {step-logic}, our design is a complete specification in terms of bits, and we need merely derive logic expressions for the next-state variables and the output signals.  This process is no different than for combinational logic, and should already be fairly familiar to you.\\n\\nFinally, in Step {step-gates}, we translate our logic expressions into gates and use flip-flops (or registers) to hold the internal state bits of the FSM.  In later notes, we use more complex building blocks when implementing an FSM, building up abstractions in order to simplify the design process in much the same way that we have shown for combinational logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAbstraction is the process of simplifying a complex system by identifying the essential characteristics of the system and ignoring the non-essential characteristics. In the context of finite state machine design, abstraction can simplify the implementation process by identifying the essential states and transitions of the machine and ignoring the non-essential states and transitions. For example, consider a simple counter that can count up or down depending on the input. The essential states of the machine are the states corresponding to the numbers 0, 1, 2, 3, and so on. The non-essential states are the states corresponding to the numbers 1/2, 3/4, 5/6, and so on. By ignoring the non-essential states, we can simplify the implementation of the machine.""
 }
]","{
 ""id"": 32
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it helpful to use a computer to select an internal representation for small designs?\n#### Option 1\n-------\nIt can be helpful to use a computer to select an internal representation for small designs because the computer can optimize the implementation. This can lead to a simpler design that is easier to build correctly.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIt can help to optimize the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt is helpful to use a computer to select an internal representation for small designs because it can optimize the implementation. For example, a computer can select a representation that is simpler and easier to build correctly.""
 }
]","{
 ""id"": 33
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 34
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does step two entail?\n#### Option 1\n-------\nIn Step 2, we formalize the model by specifying the input and output behavior. This ensures that all input and output will consist of bits, which will be compatible with other digital systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStep two begins to formalize the model, starting with its input and output behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn Step 2, we formalize the model by specifying the input and output behavior. This includes determining the format of the input and output signals and how they will be used by the FSM. For example, if we are designing a counter, we will need to specify the input signal (e.g., a clock signal) and the output signal (e.g., a count value). We will also need to specify how the input and output signals will be used by the FSM. For example, the input signal may be used to trigger a state transition, and the output signal may be used to indicate the current state of the FSM.""
 }
]","{
 ""id"": 35
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How do you choose a state representation in step four?\n#### Option 1\n-------\nIn Step {step-repn}, we select an internal representation\nfor the bits necessary to encode the state of our FSM.  In practice,\nfor small designs, this representation can be selected by a computer \nin such a way as to optimize the implementation.  However, for large\ndesigns, such as the LC-3 instruction set architecture that we\nstudy later in this class, humans do most of the work by hand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIn Step {step-repn}, we select an internal representation for the bits necessary to encode the state of our FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are a few considerations that go into choosing a state representation for an FSM. The first is the number of states in the FSM. If the number of states is a power of two, then a simple binary representation can be used. If the number of states is not a power of two, then a more complex representation may be necessary. The second consideration is the number of inputs to the FSM. If there are a large number of inputs, then a more complex representation may be necessary. The third consideration is the number of outputs from the FSM. If there are a large number of outputs, then a more complex representation may be necessary. Finally, if the FSM is to be interfaced with other digital systems, then the representation must be compatible with those systems.""
 }
]","{
 ""id"": 36
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the six steps in the design process?\n#### Option 1\n-------\nThe six steps in the design process are as follows: develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe six steps in the design process are: develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe six steps in the design process are:\n\n1. Develop an abstract model\n2. Specify I/O behavior\n3. Complete the specification\n4. Choose a state representation\n5. Calculate logic expressions\n6. Implement with flip-flops and gates""
 }
]","{
 ""id"": 37
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 38
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the fourth step in the design process?\n#### Option 1\n-------\nThe fourth step in the design process is to choose a state representation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIn Step {step-repn}, we select an internal representation for the bits necessary to encode the state of our FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe fourth step in the design process is to choose a state representation.""
 }
]","{
 ""id"": 39
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to develop an abstract model?\n#### Option 1\n-------\nIt is important to develop an abstract model because it allows you to capture the intent of the description and are not\nparticularly thorough nor exact.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIt is important to develop an abstract model to try and capture the intent of the description, and to be as thorough and exact as possible.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt is important to develop an abstract model because it allows us to capture the intent of the description and to make any implicit assumptions clear. By doing so, we can simplify the design and make it easier to build correctly.""
 }
]","{
 ""id"": 40
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does specifying the I/O behavior help formalize the model?\n#### Option 1\n-------\nSpecifying the I/O behavior helps formalize the model by making it clear what the inputs and outputs of the FSM will be. This helps to ensure that the FSM will be compatible with other digital systems it is connected to. In addition, specifying the I/O behavior helps to make any implicit assumptions clear and to make any other decisions necessary to the design.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSpecifying the I/O behavior begins to formalize the model by translating the description into a model with states and desired behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn Step {step-io}, we begin to formalize the model, starting with its input and output behavior. If we eventually plan to develop an implementation of our FSM as a digital system (which is not the only choice, of course!), all input and output must consist of bits. Often, input and/or output specifications may need to match other digital systems to which we plan to connect our FSM. In fact, { most problems in developing large digital systems today arise because of incompatibilities when composing two or more separately designed pieces} (or { modules}) into an integrated system. Once we know the I/O behavior for our FSM, in Step {step-complete} we start to make any implicit assumptions clear and to make any other decisions necessary to the design.""
 }
]","{
 ""id"": 41
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why might you choose to leave something undecided in the design process?\n#### Option 1\n-------\nYou might choose to leave something undecided in the design process in order to simplify the design with \""don't care\"" entries in the logic formulation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIn order to simplify the design with \""don't care\"" entries in the logic formulation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nOne reason you might choose to leave something undecided in the design process is if you hope to simplify the design with \""don't care\"" entries in the logic formulation. Another reason might be if you are trying to leverage meaningful information from the design when selecting the representation, leading to an implementation that is simpler and is easier to build correctly.""
 }
]","{
 ""id"": 42
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 43
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What does step two involve?\n#### Option 1\n-------\nIn Step {step-io}, we formalize the model, starting with its\ninput and output behavior.  If we eventually plan to develop an\nimplementation of our FSM as a digital system (which is not the \nonly choice, of course!), all input and output\nmust consist of bits.  Often, input and/or output specifications\nmay need to match other digital systems to which we plan to connect\nour FSM.  In fact, { most problems in developing large digital systems\ntoday arise because of incompatibilities when composing two or more\nseparately designed pieces} (or { modules}) into an integrated system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIn Step 2, we formalize the model, starting with its input and output behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn Step 2, we translate our description in human language into a model with states and desired behavior. At this stage, we simply try to capture the intent of the description and are not particularly thorough nor exact.""
 }
]","{
 ""id"": 44
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the last step in the design process?\n#### Option 1\n-------\nThe last step in the design process is to implement the FSM with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nImplementing with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe last step in the design process is to implement the FSM with flip-flops and gates.""
 }
]","{
 ""id"": 45
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the six steps in the design process?\n#### Option 1\n-------\nThe six steps in the design process are:\n\n1. Develop an abstract model\n2. Specify I/O behavior\n3. Complete the specification\n4. Choose a state representation\n5. Calculate logic expressions\n6. Implement with flip-flops and gates""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe six steps in the design process are: develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe six steps in the design process are:\n\n1. Develop an abstract model\n2. Specify I/O behavior\n3. Complete the specification\n4. Choose a state representation\n5. Calculate logic expressions\n6. Implement with flip-flops and gates""
 }
]","{
 ""id"": 46
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 47
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of Step 3 in the design process?\n#### Option 1\n-------\nThe purpose of Step 3 is to complete the specification of the FSM. This includes making any implicit assumptions clear and making any other decisions necessary to the design.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of Step 3 is to complete the specification.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of Step 3 in the design process is to complete the specification. This includes making any implicit assumptions clear and making any other decisions necessary to the design.""
 }
]","{
 ""id"": 48
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the design process for an FSM differ from the design process of other digital systems?\n#### Option 1\n-------\nThe design process for an FSM is similar to the design process for other digital systems in that it begins with a description of the system in human language, which is then formalized into a model with states and desired behavior. However, there are some key differences. First, all input and output for an FSM must be in the form of bits. Second, the internal representation for the bits encoding the state of the FSM must be selected. And finally, the logic expressions for the next-state variables and the output signals must be derived.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for an FSM includes six steps: developing an abstract model, specifying I/O behavior, completing the specification, choosing a state representation, calculating logic expressions, and implementing with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for an FSM differs from the design process of other digital systems in a few key ways. First, when designing an FSM, it is important to develop an abstract model of the system. This abstract model will capture the states and desired behavior of the FSM. Second, when specifying the I/O behavior of an FSM, it is important to ensure that all input and output are in the form of bits. This is necessary in order to develop an implementation of the FSM as a digital system. Finally, when choosing a state representation for an FSM, it is important to consider how the representation will simplify the implementation of the FSM.""
 }
]","{
 ""id"": 49
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to have compatible input and output specifications when designing an FSM?\n#### Option 1\n-------\nIt is important to have compatible input and output specifications when designing an FSM because otherwise the FSM will not be able to interact properly with other digital systems. This can lead to problems in developing large digital systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nMost problems in developing large digital systems arise because of incompatibilities when composing two or more separately designed pieces into an integrated system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt is important to have compatible input and output specifications when designing an FSM because incompatible specifications can lead to problems when composing two or more separately designed pieces into an integrated system. For example, if the input and output specifications for two FSMs are not compatible, then the two FSMs may not be able to communicate with each other properly. This can lead to errors and unexpected behavior.""
 }
]","{
 ""id"": 50
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can abstraction be used to simplify the implementation of an FSM?\n#### Option 1\n-------\nAbstraction can be used to simplify the implementation of an FSM by hiding the details of the implementation from the user. This allows the user to focus on the functionality of the FSM, rather than the details of the implementation. Additionally, abstraction can be used to simplify the design process by allowing the designer to focus on the functionality of the FSM, rather than the details of the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAbstraction can be used to simplify the implementation of an FSM by breaking the design down into smaller, more manageable pieces.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAbstraction can be used to simplify the implementation of an FSM by hiding the details of the implementation from the user. This allows the user to focus on the functionality of the FSM, rather than on the details of the implementation. For example, a user may want to design an FSM that counts the number of 1s in a binary number. The user can abstract away the details of the implementation, such as the number of flip-flops needed, and focus on the functionality of the FSM.""
 }
]","{
 ""id"": 51
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is a Gray code?\n#### Option 1\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a code used to identify two successive values in a digital system where only one value can change at a time. The most common type of Gray code is an n-bit code where each successive value differs from the previous value in only one bit. For example, a 3-bit Gray code can represent the eight values 000, 001, 011, 010, 110, 111, 101, and 100.""
 }
]","{
 ""id"": 52
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe purpose of a Gray code counter is to cycle through all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter used in electronic systems that counts in a Gray code sequence. Gray code is a binary code in which each successive pair of numbers differ in only one bit. This type of counter is often used in applications where a digital input must be changed only one bit at a time, such as in rotary encoders.""
 }
]","{
 ""id"": 53
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How does a Gray code counter work?\n#### Option 1\n-------\nA Gray code counter is a type of counter that uses a Gray code, which is a code in which consecutive patterns differ in only one bit. The counter cycles through all of the possible bit patterns of a certain length, and the output values are determined by the internal state of the FSM. To design a Gray code counter, you first need to create a transition diagram that shows all of the possible states the counter can be in. From there, you can fill in the K-maps for the next-state values and derive algebraic expressions for them. Finally, you can use the next-state logic to implement the counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter that uses a Gray code to generate its output. The Gray code is a sequence of binary numbers in which each successive number differs from the previous number in only one bit. This type of counter is often used in applications where a digital input must be changed gradually, such as in color sequencing or motor control.""
 }
]","{
 ""id"": 54
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a Gray code?\n#### Option 1\n-------\nA Gray code is a code in which two successive values differ in only one bit. It is also known as a 'reflected binary code', because the value of the code word is reflected about the middle of the code word. For example, a Gray code for a four-bit word would be: 0000, 0001, 0011, 0010, 0110, 0111, 0101, 0100, 1100, 1101, 1111, 1110, 1010, 1011, 1001, 1000.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a code in which two successive values differ in only one bit. It is also known as a reflected binary code. Gray codes are often used in applications where it is necessary to minimize the number of bits that change when a value is incremented or decremented. For example, a Gray code sequence can be used to determine the position of a shaft encoder.""
 }
]","{
 ""id"": 55
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nA Gray code counter is a type of counter that uses a Gray code, which is a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit. This type of counter is often used in applications where it is important to avoid errors when transitioning between states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter used in electronic devices that counts in a Gray code sequence. Gray code is a type of binary code in which each successive pair of numbers differ in only one bit. This type of counter is often used in applications where a digital input must be changed only one bit at a time, such as in rotary encoders or optical encoders.""
 }
]","{
 ""id"": 56
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a Gray code counter work?\n#### Option 1\n-------\nA Gray code counter is a type of counter that cycles through all possible bit patterns of a certain length. Consecutive patterns in a Gray code counter differ in only one bit.\n\nIn a two-bit Gray code counter with no inputs, the states simply form a loop. The counter moves from one state to the next each cycle. The output values for each state are the same as the internal state values of the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n[ 'A Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.', 'With no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle.']""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter that uses a Gray code to count through a sequence of numbers. The advantage of using a Gray code is that it ensures that only one bit changes at a time between successive numbers in the sequence. This makes Gray code counters more robust than other types of counters, which can experience errors if more than one bit changes at a time. \n\nTo understand how a Gray code counter works, let's first consider a simple two-bit Gray code sequence: 00, 01, 11, 10. As you can see, each successive number in the sequence differs from the previous number by only one bit. For example, the number 01 differs from 00 in that the first bit is 1 instead of 0. \n\nNow, let's say we want to use a Gray code counter to count from 0 to 3. We can do this by starting at 0 and then counting up in Gray code order. So, the sequence would be: 00, 01, 11, 10, 00, 01, 11, 10, ... \n\nNotice that when we reach the end of the Gray code sequence (10), we simply wrap around and start again at 0. We can continue counting in this way until we reach the number 3. \n\nSo, a Gray code counter is simply a digital counter that uses a Gray code sequence to count. The advantage of using a Gray code is that it ensures that only one bit changes at a time""
 }
]","{
 ""id"": 57
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a Gray code?\n#### Option 1\n-------\nA Gray code is a code in which each successive pair of numbers differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a code used to represent numbers in a way that minimizes the number of bits that need to be changed to represent the next number in the sequence. Gray codes are often used in applications where a digital input or output is required to change state gradually, such as in rotary encoders.""
 }
]","{
 ""id"": 58
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter used to generate a Gray code, which is a type of code used to ensure that only one bit changes between successive numbers in a sequence. Gray code counters are often used in applications where a digital signal must be converted to an analog signal, or vice versa, in order to minimize errors.""
 }
]","{
 ""id"": 59
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a Gray code counter work?\n#### Option 1\n-------\nA Gray code counter is a type of counter that uses a Gray code to generate its output. A Gray code is a code in which consecutive code words differ in only one bit. The advantage of using a Gray code is that it minimizes the number of bits that must be changed when going from one code word to the next. \n\nThe way a Gray code counter works is by having a series of flip-flops that are connected together in a loop. The output of each flip-flop is connected to the input of the next flip-flop in the loop. The output of the last flip-flop in the loop is connected to the input of the first flip-flop in the loop. \n\nThe flip-flops are configured so that they toggle on each clock cycle. This causes the output of the flip-flops to change in a Gray code pattern. \n\nThe number of flip-flops in the loop determines the length of the Gray code. For example, a two-bit Gray code has four possible output values (00, 01, 11, 10). A three-bit Gray code has eight possible output values (000,001,011,010,110,111,101,100). \n\nThe main advantage of using a Gray code is that it minimizes the number of bits that must be changed when going from one code word to the next. For example, when going from 01 to 11 in a""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter that uses a Gray code to generate its output. A Gray code is a sequence of binary numbers in which each successive number differs from the previous number in only one bit. The advantage of using a Gray code is that it minimizes the number of bits that must be changed when the counter is incremented or decremented. \n\nFor example, a two-bit Gray code counter will have the following output sequence: 00, 01, 11, 10. Notice that when the counter is incremented from 01 to 11, only one bit changes (from 0 to 1). Similarly, when the counter is decremented from 11 to 10, only one bit changes (from 1 to 0). This is in contrast to a regular binary counter, which would have the following output sequence: 00, 01, 10, 11. In this case, when the counter is incremented from 01 to 10, two bits change (from 0 to 1 and from 1 to 0). \n\nGray code counters are often used in applications where a digital signal must be converted to an analog signal, such as in digital-to-analog converters (DACs). This is because Gray code counters can minimize the amount of change in the analog signal when the digital input is changed.""
 }
]","{
 ""id"": 60
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the inputs to the counter?\n#### Option 1\n-------\nThe inputs to the counter are limited to functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe inputs to the counter are functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe inputs to the counter are typically limited to functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 }
]","{
 ""id"": 61
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the outputs of the counter?\n#### Option 1\n-------\nThe outputs of the counter are the internal state values S_1S_0 and the output Z_1Z_0.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe outputs of the counter are the internal state values S_1S_0 and the output values Z_1Z_0.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe outputs of the counter are the internal state values S_1S_0 and the output values Z_1Z_0.""
 }
]","{
 ""id"": 62
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nA Gray code counter is a type of counter that uses a Gray code, which is a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit. Gray code counters are typically used for applications where it is important to minimize errors, such as in communication systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter used to count in a Gray code sequence. Gray code is a binary code in which each successive pair of numbers differ in only one bit. This type of counter is often used in applications where a digital input must be changed only one bit at a time, such as in rotary encoders.""
 }
]","{
 ""id"": 63
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a two-bit Gray code counter work?\n#### Option 1\n-------\nA fully-specified transition diagram for a two-bit Gray code counter appears below. With no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle. Each state in the diagram is marked with the internal state value S_1S_0 (before the ``/'') and the output Z_1Z_0 (after the ``/''), which are always equal for this counter. Based on the transition diagram, we can fill in the K-maps for the next-state values S_1^+ and S_0^+ as shown to the right of the transition diagram, then derive algebraic expressions in the usual way to obtain S_1^+=S_0 and S_0^+={{S_1}}. We then use the next-state logic to develop the implementation shown on the far right, completing our first counter design.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe states in the diagram form a loop, with the counter moving from one state to the next each cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter that uses a Gray code to count through its states. A Gray code is a sequence of binary numbers in which each successive number differs from the previous number by only one bit. This type of counter is often used in applications where a digital input must be changed only one bit at a time, such as in some types of rotary encoders. \n\nFor a two-bit Gray code counter, there are four possible states, represented by the numbers 0, 1, 2, and 3. The output of the counter cycles through these states in the following order: 0, 1, 3, 2, 0, 1, 3, 2, ... \n\nThe logic expressions for a two-bit Gray code counter are as follows:\n\nS_1^+ = S_0\n\nS_0^+ = {{S_1}}\n\nBased on these expressions, the implementation of the counter is as follows:\n\nThe two-bit Gray code counter is a type of digital counter that uses a Gray code to count through its states. A Gray code is a sequence of binary numbers in which each successive number differs from the previous number by only one bit. This type of counter is often used in applications where a digital input must be changed only one bit at a time, such as in some types of rotary encoders. \n\nFor a two-bit Gray code counter, there""
 }
]","{
 ""id"": 64
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the inputs to a two-bit Gray code counter?\n#### Option 1\n-------\nThe inputs to a two-bit Gray code counter are typically limited to functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe inputs to a two-bit Gray code counter are functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are no inputs to a two-bit Gray code counter. The states simply form a loop, with the counter moving from one state to the next each cycle.""
 }
]","{
 ""id"": 65
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the transition diagram for a two-bit Gray code counter?\n#### Option 1\n-------\nThe transition diagram for a two-bit Gray code counter is shown below. With no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle. Each state in the diagram is marked with the internal state value S_1S_0 (before the ``/'') and the output Z_1Z_0 (after the ``/''), which are always equal for this counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe transition diagram for a two-bit Gray code counter is a loop over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA two-bit Gray code counter is a type of counter that cycles through all possible combinations of two bits, with each consecutive pattern differing in only one bit. A fully-specified transition diagram for such a counter appears below. With no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle. Each state in the diagram is marked with the internal state value S_1S_0 (before the \""/\"") and the output Z_1Z_0 (after the \""/\""), which are always equal for this counter.\n\nBased on the transition diagram, we can fill in the K-maps for the next-state values S_1^+ and S_0^+ as shown to the right of the transition diagram, then derive algebraic expressions in the usual way to obtain S_1^+=S_0 and S_0^+={{S_1}}. We then use the next-state logic to develop the implementation shown on the far right, completing our first counter design.""
 }
]","{
 ""id"": 66
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a Gray code?\n#### Option 1\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a code where two successive values differ in only one bit. It is often used in counters because it is easy to detect when the value has changed. For example, a two-bit Gray code goes from 00 to 01 to 11 to 10, where each successive value differs in only one bit.""
 }
]","{
 ""id"": 67
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter that is used to count in a Gray code sequence. A Gray code sequence is a sequence of binary numbers in which each successive number differs from the previous number in only one bit. Gray code counters are used in applications where it is important to minimize the possibility of errors when counting. For example, Gray code counters are often used in applications where a digital count must be converted to an analog signal, such as in digital-to-analog converters.""
 }
]","{
 ""id"": 68
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a Gray code counter work?\n#### Option 1\n-------\nA Gray code counter is a type of counter that uses a Gray code to count. A Gray code is a code in which consecutive code words differ in only one bit. The advantage of using a Gray code is that it minimizes the number of errors that can occur when counting. \n\nThe way a Gray code counter works is by having a series of states that it cycles through. Each state is represented by a code word. The code words for consecutive states differ in only one bit. The advantage of using a Gray code is that it minimizes the number of errors that can occur when counting. \n\nThe way a Gray code counter works is by having a series of states that it cycles through. Each state is represented by a code word. The code words for consecutive states differ in only one bit. \n\nThe advantage of using a Gray code is that it minimizes the number of errors that can occur when counting.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter that uses a Gray code to generate its output. A Gray code is a sequence of binary numbers in which each successive number differs from the previous number in only one bit. The advantage of using a Gray code is that it minimizes the number of bits that must be changed when the counter is incremented or decremented. \n\nFor example, consider a Gray code counter with two bits. The output of such a counter would be a sequence of numbers in which each successive number differs from the previous number in only one bit. The output might look like this: 00, 01, 11, 10. Notice that when the counter is incremented from 01 to 11, only one bit changes (from 0 to 1). Similarly, when the counter is decremented from 11 to 10, only one bit changes (from 1 to 0). \n\nThe advantage of using a Gray code is that it minimizes the number of bits that must be changed when the counter is incremented or decremented. This can be important in applications where the output of the counter is used to control some other system, and we want to minimize the number of changes to that system.""
 }
]","{
 ""id"": 69
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a Gray code?\n#### Option 1\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a sequence of binary numbers in which each successive number differs from the previous number by only one bit. Gray codes are often used in applications where a digital input or output must be read or written sequentially, such as in counters, shift registers, and digital-to-analog converters.""
 }
]","{
 ""id"": 70
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a two-bit Gray code counter?\n#### Option 1\n-------\nA two-bit Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit. This type of counter is typically used to simplify the design of digital logic circuits.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a two-bit Gray code counter is to count in Gray code, which is a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter used to generate a Gray code, which is a code where consecutive patterns differ in only one bit. Gray code counters are often used in applications where a digital input must be changed only one bit at a time, such as in rotary encoders.""
 }
]","{
 ""id"": 71
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the counter move from one state to the next?\n#### Option 1\n-------\nThe two-bit Gray code counter moves from one state to the next based on the value of the input. If the input is 0, the counter will move to the next state in the sequence. If the input is 1, the counter will move to the previous state in the sequence. The inputs and outputs of the two-bit Gray code counter are the same, with the output being the internal state of the FSM. The next state expressions for the two-bit Gray code counter are S_1^+=S_0 and S_0^+={{S_1}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe counter moves from one state to the next based on the internal state value S_1S_0 and the output Z_1Z_0, which are always equal for this counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe counter moves from one state to the next based on the input signals. The inputs to a counter, if any, are typically limited to functions such as starting and stopping the counter, controlling the counting  direction, and resetting the counter to a particular state.  A fully-specified transition diagram for  a two-bit Gray code counter appears below. With no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle.  Each state in the diagram is marked with the internal state value S_1S_0  (before the ``/'') and the output Z_1Z_0 (after the ``/''), which are  always equal for this counter.  Based on the transition diagram, we can fill in the K-maps for the  next-state values S_1^+ and S_0^+ as shown to the right of the transition diagram, then  derive algebraic expressions in the usual way to obtain S_1^+=S_0 and S_0^+={{S_1}}.  We then use the next-state logic to develop the implementation shown on the far right, completing our first counter design.""
 }
]","{
 ""id"": 72
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe purpose of a Gray code counter is to simplify the design of the next-state logic by explicitly identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Gray code counter is to create a counter that moves from one state to the next each cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter used to generate a Gray code, which is a type of code used to ensure that only one bit changes between successive states. Gray code counters are often used in applications where it is important to avoid errors when transitioning between states, such as in communication systems or when measuring position.""
 }
]","{
 ""id"": 73
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the benefits of using a Gray code counter over a traditional binary counter?\n#### Option 1\n-------\nThere are a few benefits of using a Gray code counter over a traditional binary counter. \n\nFirst, Gray code counters can be more easily implemented in hardware. This is because the state transitions in a Gray code counter are always between adjacent states, which simplifies the logic required to generate the next state. \n\nSecond, Gray code counters are more resistant to errors. This is because, with a Gray code counter, only one bit changes value at a time. This means that if there is an error in one bit, it is less likely to propagate to the other bits. \n\nFinally, Gray code counters are more efficient in terms of power consumption. This is because, with a Gray code counter, only one bit changes value at a time. This means that there are fewer transitions, and thus less power is required.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nGray code counters have the benefit of only changing one bit at a time, which prevents errors when counting.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are several benefits of using a Gray code counter over a traditional binary counter. First, Gray code counters are more resistant to errors caused by electrical noise. This is because only one bit changes value at a time in a Gray code counter, whereas in a binary counter, multiple bits may change value simultaneously. This makes Gray code counters more suitable for applications where electrical noise is a concern. Second, Gray code counters are easier to design and implement than binary counters. This is because the logic required to generate a Gray code is simpler than the logic required to generate a binary code. Finally, Gray code counters have the advantage of being self-clocking. This means that they do not require a separate clock signal in order to operate, which can simplify both the design and implementation of a Gray code counter.""
 }
]","{
 ""id"": 74
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are some of the challenges that come with designing a Gray code counter?\n#### Option 1\n-------\nSome of the challenges that come with designing a Gray code counter include:\n\n1) The need to carefully order the inputs and outputs to simplify understanding of the design.\n\n2) The need to identify and make use of common algebraic terms and sub-expressions to reduce design complexity.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe main challenge is that the next-state logic equations are more complex than for a regular counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nGray code counters are digital counters where the output changes by only one bit for each input clock pulse. This is in contrast to traditional digital counters, which can have multiple bits changing at the same time. The main advantage of Gray code counters is that they are more resistant to errors caused by electrical noise. This is because only one bit changes at a time, so the chance of multiple bits changing at the same time and causing an error is much lower.\n\nThere are some challenges that come with designing Gray code counters. One challenge is that the design is more complex than a traditional digital counter. This is because the output has to change by only one bit at a time, which requires extra logic to be added to the design. Another challenge is that Gray code counters are not as widely used as traditional digital counters, so there is less information available to help with the design process.""
 }
]","{
 ""id"": 75
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the value of S_2^+?\n#### Option 1\n-------\nS_2^+ = S_2 S_0 + S_1 {{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_2^+ = S_2 S_0 + S_1 {{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe value of S_2^+ is the value of S_2 in the next clock cycle, and S_2^+ in an FSM implemented as a digital system is a Boolean expression based on the current state and the inputs.""
 }
]","{
 ""id"": 76
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the value of S_1^+?\n#### Option 1\n-------\nThe value of S_1^+ is {{S_2}} S_0 + S_1 {{S_0}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_1^+ = {{S_2}} S_0 + S_1 {{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe value of S_1^+ is the value of S_1 in the next clock cycle.""
 }
]","{
 ""id"": 77
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the value of S_0^+?\n#### Option 1\n-------\nThe value of S_0^+ is {{S_2}} {{S_1}} + S_2 S_1.\n\nAdding a third bit to a Gray code counter increases design complexity because the equations for the next-state logic become more complex.\n\nIt is important to order the inputs and outputs of a logic diagram so that it is easy to read and check the correctness of the logic.\n\nYou can reduce design complexity by identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_0^+ = {{S_2}} {{S_1}} + S_2 S_1""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAdding a third bit to a Gray code counter increases design complexity because it requires more flip-flops and more logic gates. It is important to order the inputs and outputs of a logic diagram because it makes the design easier to understand and implement. You can reduce design complexity by identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 }
]","{
 ""id"": 78
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the common term for S_2^+ and S_1^+?\n#### Option 1\n-------\nThe common term for S_2^+ and S_1^+ is S_1{{S_0}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe common term for S_2^+ and S_1^+ is S_1{{S_0}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe common term for S_2^+ and S_1^+ is \""carry.\""""
 }
]","{
 ""id"": 79
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many inputs and outputs are in the transition diagram?\n#### Option 1\n-------\nThere are three inputs and three outputs in the transition diagram.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe transition diagram has 3 inputs and 3 outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two inputs and two outputs in the transition diagram.""
 }
]","{
 ""id"": 80
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does a fully-specified transition diagram look like?\n#### Option 1\n-------\nA fully-specified transition diagram for a three-bit Gray code counter appears to the right.  As before, with no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle.\\n\\nEach state in the diagram is marked with the internal state value S_2S_1S_0 (before ``/'') and the output Z_2Z_1Z_0 (after ``/'').""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA fully-specified transition diagram has states marked with the internal state value S_2S_1S_0 (before ``/'') and the output Z_2Z_1Z_0 (after ``/'').""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA fully-specified transition diagram is a diagram that shows all of the possible states that a system can be in, as well as all of the possible transitions between those states. The diagram includes both the current state and the next state for each transition.""
 }
]","{
 ""id"": 81
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe purpose of a Gray code counter is to count in a sequence that minimizes the number of bits that change between successive states. This makes the counter more resistant to errors, since only one bit changes at a time.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Gray code counter is to create a counter that moves from one state to the next each cycle, with each state having a unique value.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter used to generate a Gray code, which is a type of code used to ensure that only one bit changes at a time when transitioning between successive numbers. Gray code counters are often used in applications where a digital signal must be converted to an analog signal, such as in digital-to-analog converters (DACs).""
 }
]","{
 ""id"": 82
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the benefits of using a Gray code counter?\n#### Option 1\n-------\nThere are several benefits to using a Gray code counter over a traditional binary counter. \n\nFirst, Gray code counters are more resistant to errors caused by electrical noise. This is because, with a Gray code counter, only one bit changes value at a time. This means that, if there is a transient error that causes one bit to flip, it will only affect that one bit. In a binary counter, on the other hand, all bits may change value at once, so a transient error could cause multiple bits to flip, leading to a more significant error. \n\nSecond, Gray code counters are more efficient in terms of the number of logic gates required. This is because, with a Gray code counter, only one bit changes value at a time. This means that only one logic gate is required to implement the next-state logic. In a binary counter, on the other hand, all bits may change value at once, so all bits would need their own logic gate, leading to a more complex design. \n\nThird, Gray code counters are more flexible in terms of the order in which states are visited. This is because, with a Gray code counter, only one bit changes value at a time. This means that the order in which states are visited can be controlled by simply changing the order of the bits in the Gray code. In a binary counter, on the other hand, all bits may change value at once, so the order in which states are""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe benefits of using a Gray code counter are that they are easy to design and implement, and they allow for easy identification of common algebraic terms and sub-expressions.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are several benefits to using a Gray code counter. First, it is easy to detect when the counter has changed states, since only one bit will change at a time. This can be useful, for example, in applications where an accurate count is important, such as in a system that is keeping track of the number of rotations of a motor. Second, Gray code counters are less likely to produce erroneous counts due to electrical noise or other interference, since only one bit changes at a time. This can be important in applications where a high degree of accuracy is required, such as in a system that is measuring very small changes in position or velocity.""
 }
]","{
 ""id"": 83
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a Gray code counter work?\n#### Option 1\n-------\nA Gray code counter is a type of counter that uses a Gray code to produce a sequence of states. \n\nA Gray code is a code in which each successive pair of numbers differ by only one bit. \n\nThe advantage of using a Gray code is that it minimizes the number of transitions between states, which can reduce the amount of power consumption. \n\nA fully-specified transition diagram for such a counter appears to the right.  As before, with no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle. \n\nEach state in the diagram is marked with the internal state value S_2S_1S_0 (before ``/'') and the output Z_2Z_1Z_0 (after ``/''). \n\n\n\nBased on the transition diagram, we can fill in the K-maps for the next-state values S_2^+, S_1^+, and S_0^+ as shown to the right, then derive algebraic expressions.  The results are more complex this time. \n\n\n\nFor our next-state logic, we obtain:\n{eqnarray*}\nS_2^+ &=& S_2 S_0 + S_1 {{S_0}} \nS_1^+ &=& {{S_2}} S_0 + S_1 {{S_0""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a counter that uses a Gray code as the basis for the state sequence.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of digital counter that uses a Gray code to count. The main advantage of using a Gray code is that it minimizes the number of bits that change between successive states, which can be useful when interfacing with other digital devices. \n\nThere are two main types of Gray code counters: binary and Gray. In a binary Gray code counter, the output is a binary number whose bits represent the states of the counter. In a Gray code counter, the output is a Gray code, which is a sequence of binary numbers that differ in only one bit. \n\nThe main difference between a Gray code counter and a binary counter is the way in which the states are represented. In a Gray code counter, the states are represented by a Gray code, which is a sequence of binary numbers that differ in only one bit. In a binary counter, the states are represented by a binary number, which can have multiple bits that change between successive states. \n\nThe advantage of using a Gray code counter is that it minimizes the number of bits that change between successive states, which can be useful when interfacing with other digital devices.""
 }
]","{
 ""id"": 84
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does this design enable you to reduce the complexity of the algebraic equations for the next-state logic?\n#### Option 1\n-------\nThe design enables you to reduce the complexity of the algebraic equations for the next-state logic by explicitly identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThis design allows you to reduce the complexity of the algebraic equations for the next-state logic by explicitly identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n""
 }
]","{
 ""id"": 85
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the importance of ordering the vertical lines carrying the current state values and their inverses back to the next state logic inputs?\n#### Option 1\n-------\nOrdering the vertical lines helps to simplify understanding the diagram. In particular, they are ordered from left to right (on the left side of the figure) as S_0{{S_0}}S_1{{S_1}}S_2{{S_2}}. When designing any logic diagram, be sure to make use of a reasonable order so as to make it easy for someone (including yourself!) to read and check the correctness of the logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nOrdering the vertical lines carrying the current state values and their inverses back to the next state logic inputs makes it easy for someone to read and check the correctness of the logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe importance of ordering the vertical lines carrying the current state values and their inverses back to the next state logic inputs is that it simplifies understanding the diagram. In particular, it is easier to read and check the correctness of the logic if the lines are ordered from left to right (on the left side of the figure) as {{S_0}}S_0{{S_1}}S_1{{S_2}}S_2.""
 }
]","{
 ""id"": 86
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How would a reasonable order make it easy for someone to read and check the correctness of the logic?\n#### Option 1\n-------\nWhen designing any logic diagram, it is important to use a reasonable order so that it is easy for someone to read and check the correctness of the logic. For example, when designing a counter with three bits, the vertical lines carrying the current state values and their inverses back to the next state logic inputs can be ordered from left to right (on the left side of the figure) as {{S_0}}S_0{{S_1}}S_1{{S_2}}S_2. This order makes it easy to check the correctness of the logic by reading the diagram from left to right.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA reasonable order would make it easy for someone to read and check the correctness of the logic by organizing the inputs and outputs in a way that is easy to follow.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are a few different ways to order the bits in a bit-sliced adder, but a reasonable order would be to start with the least significant bit and move to the left. This is the order that humans typically use when adding two binary numbers, and it makes it easy for someone to read and check the correctness of the logic.""
 }
]","{
 ""id"": 87
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a Three-Bit Gray Code Counter?\n#### Option 1\n-------\nA Three-Bit Gray Code Counter is a type of digital counter that uses a Gray code to generate its state sequence. \n\nA Gray code is a type of code in which each successive code word differs from the previous code word by only one bit. \n\nThe Three-Bit Gray Code Counter has three bits, which means that it can represent eight different states. \n\nThe Three-Bit Gray Code Counter is a type of digital counter that uses a Gray code to generate its state sequence. A Gray code is a type of code in which each successive code word differs from the previous code word by only one bit. The Three-Bit Gray Code Counter has three bits, which means that it can represent eight different states. \n\nThe Three-Bit Gray Code Counter is a type of digital counter that uses a Gray code to generate its state sequence. A Gray code is a type of code in which each successive code word differs from the previous code word by only one bit. The Three-Bit Gray Code Counter has three bits, which means that it can represent eight different states. \n\nThe Three-Bit Gray Code Counter is a type of digital counter that uses a Gray code to generate its state sequence. A Gray code is a type of code in which each successive code word differs from the previous code word by only one bit. The Three-Bit Gray Code Counter has three bits, which means that it can represent eight different states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA digital circuit that goes through all possible three-bit numbers, in a sequence where only one bit changes at a time.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a type of binary counter where each successive state differs from the previous state in only one bit. A three-bit Gray code counter therefore has eight states, each of which is represented by a three-bit binary number. The states of a three-bit Gray code counter progress as follows: 000, 001, 011, 010, 110, 111, 101, 100.""
 }
]","{
 ""id"": 88
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Three-Bit Gray Code Counter?\n#### Option 1\n-------\nThe purpose of a Three-Bit Gray Code Counter is to count in Gray code, which is a code where each successive value differs by only one bit. This counter is made up of three bits, so it can count from 0 to 7 in Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Three-Bit Gray Code Counter is to count in binary, while only changing one bit at a time.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Three-Bit Gray Code Counter is a device that produces a sequence of binary numbers in which each successive number differs from the previous number in only one bit. This type of counter is often used in applications where a digital output needs to be converted to an analog signal, such as in a digital-to-analog converter.""
 }
]","{
 ""id"": 89
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a Three-Bit Gray Code Counter work?\n#### Option 1\n-------\nA Three-Bit Gray Code Counter works by adding a third bit to the counter and using a Gray code as the basis for the state sequence. \n\nThe counter moves from one state to the next each cycle, with each state being marked with the internal state value S_2S_1S_0 (before \""/\"") and the output Z_2Z_1Z_0 (after \""/\""). \n\nThe next-state values S_2^+, S_1^+, and S_0^+ are filled in based on the transition diagram, and algebraic expressions are derived. \n\nThe common term S_1{{S_0}} becomes a single AND gate in the implementation of the counter. \n\nThe vertical lines carrying the current state values and their inverses back to the next state logic inputs are ordered from left to right (on the left side of the figure) as {{S_0}}S_0{{S_1}}S_1{{S_2}}S_2.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe Three-Bit Gray Code Counter uses a Gray code as the basis for the state sequence, with each state in the diagram marked with the internal state value S_2S_1S_0 (before ``/'') and the output Z_2Z_1Z_0 (after ``/'').""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Three-Bit Gray Code Counter is a counter that counts in a Gray code. A Gray code is a code in which consecutive patterns differ in only one bit. A Three-Bit Gray Code Counter has three bits, so it can count up to eight. The Three-Bit Gray Code Counter has a state diagram that shows the sequence of states that the counter goes through. The state diagram is used to fill in the K-maps for the next-state values. The next-state values are then used to derive algebraic expressions for the next-state logic. The next-state logic is used to implement the counter.""
 }
]","{
 ""id"": 90
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the algebraic expression for S_2^+?\n#### Option 1\n-------\nS_2^+ = S_2 S_0 + S_1 {{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_2^+ = S_2 S_0 + S_1 {{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe algebraic expression for S_2^+ is S_2(S_1S_0).""
 }
]","{
 ""id"": 91
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the algebraic expression for S_1^+?\n#### Option 1\n-------\nThe algebraic expression for S_1^+ is {{S_2}} S_0 + S_1 {{S_0}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_1^+ = {{S_2}} S_0 + S_1 {{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nS_1^+ = S_1{S_0}+{S_1}S_0 = S_1{S_0}""
 }
]","{
 ""id"": 92
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the algebraic expression for S_0^+?\n#### Option 1\n-------\nThe algebraic expression for S_0^+ is {{S_2}} {{S_1}} + S_2 S_1.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_0^+ = S_2S_1 + S_2S_0 + S_1S_0""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe algebraic expression for S_0^+ is S_0.""
 }
]","{
 ""id"": 93
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the counter move from one state to the next?\n#### Option 1\n-------\nThe counter moves from one state to the next by cycling through the states. With no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe counter moves from one state to the next each cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe counter moves from one state to the next based on the input from the user. If the user presses the \""halt\"" button, the counter moves to the \""halt\"" state. If the user presses the \""go\"" button, the counter moves to the \""count\"" state.""
 }
]","{
 ""id"": 94
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of using a Gray code basis for the state sequence?\n#### Option 1\n-------\nThe purpose of using a Gray code basis for the state sequence is to ensure that only one bit changes at a time. This makes the counter more robust and less likely to produce incorrect results.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe Gray code basis is used so that only one bit changes at a time between states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are a few reasons for using a Gray code basis for the state sequence. First, it ensures that only one bit changes at a time, which can be helpful for certain applications. Second, it can make the state sequence easier to detect and correct if errors occur. Finally, it can make the state sequence easier to compress, which can save space in memory.""
 }
]","{
 ""id"": 95
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to order the vertical lines carrying the current state values and their inverses back to the next state logic inputs?\n#### Option 1\n-------\nIt is important to order the vertical lines carrying the current state values and their inverses back to the next state logic inputs in a reasonable way so as to make it easy for someone to read and check the correctness of the logic. For example, in the design above, the lines are ordered from left to right (on the left side of the figure) as {{S_0}}S_0{{S_1}}S_1{{S_2}}S_2. This makes it easy to see which inputs are connected to which outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIt is important to order the vertical lines carrying the current state values and their inverses back to the next state logic inputs so as to make it easy for someone to read and check the correctness of the logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt is important to order the vertical lines carrying the current state values and their inverses back to the next state logic inputs in a way that makes it easy for someone to read and check the correctness of the logic. For example, if the lines are ordered from left to right as {{S_0}}S_0{{S_1}}S_1{{S_2}}S_2, then it is easy to see that the logic is correct.""
 }
]","{
 ""id"": 96
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the color mapping for a three-bit RGB encoding system?\n#### Option 1\n-------\nThe color mapping for a three-bit RGB encoding system is as follows:\n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are eight colors in a three-bit RGB encoding system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe color mapping for a three-bit RGB encoding system is a way of representing colors using three bits. The color mapping for such a system is shown to the right. Imagine that you are charged with creating a counter to drive a light through a sequence of colors. The light takes an RGB input as just described, and the desired pattern is {off (black) yellow violet green blue} You immediately recognize that you merely need a counter with five states. How many flip-flops will we need? At least three, since _2 (5)=3. Given that we need three flip-flops, and that the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values. A fully-specified transition diagram for our color sequencer appears to the right. The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB. As before, we can use the transition diagram to fill in K-maps for the next-state values S_2^+, S_1^+, and S_0^+, as shown to the right. For each of the three states not included in our transition diagram, we have inserted x's into the K-maps to indicate \""don't care.\"" As you know, we can treat each x as either a 0 or a 1, whichever produces better results (where \""""
 }
]","{
 ""id"": 97
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops are needed to create a counter to drive a light through a sequence of colors?\n#### Option 1\n-------\nThree flip-flops are needed to create a counter to drive a light through a sequence of colors.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThree flip-flops are needed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAt least three flip-flops are needed to create a counter to drive a light through a sequence of colors. This is because the colors we need to produce as outputs are all unique bit patterns, and we need three flip-flops to store these unique bit patterns.""
 }
]","{
 ""id"": 98
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the desired pattern for the light?\n#### Option 1\n-------\nThe desired pattern for the light is {off (black)     yellow     violet     green     blue}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe desired pattern is {off (black)     yellow     violet     green     blue}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe desired pattern for the light is a three-bit red-green-blue (RGB) encoding for colors. The color mapping for such a system is shown to the right. Imagine that you are charged with creating a counter to drive a light through a sequence of colors. The light takes an RGB input as just described, and the desired pattern is {off (black) yellow violet green blue} You immediately recognize that you merely need a counter with five states. How many flip-flops will we need? At least three, since _2 (5)=3. Given that we need three flip-flops, and that the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values. A fully-specified transition diagram for our color sequencer appears to the right. The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB. As before, we can use the transition diagram to fill in K-maps for the next-state values S_2^+, S_1^+, and S_0^+, as shown to the right. For each of the three states not included in our transition diagram, we have inserted x's into the K-maps to indicate \""don't care.\"" As you know, we can treat each x as either a 0 or a 1, whichever produces better results (""
 }
]","{
 ""id"": 99
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops will we need?\n#### Option 1\n-------\nAt least three, since _2 (5)=3.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThree flip-flops are needed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAt least three, since _2 (5)=3.""
 }
]","{
 ""id"": 100
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Given that we need three flip-flops, can the counter's internal state directly be used as our output values?\n#### Option 1\n-------\nYes, the counter's internal state can be used as our output values because the colors we need to produce as outputs are all unique bit patterns.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nYes, because the colors we need to produce as outputs are all unique bit patterns.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nYes, the counter's internal state can be used as our output values. This is because all of the colors we need to produce as outputs are unique bit patterns. For example, if we need to produce the color black, we can use the bit pattern 000. Similarly, if we need to produce the color blue, we can use the bit pattern 001.""
 }
]","{
 ""id"": 101
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the fully-specified transition diagram for our color sequencer?\n#### Option 1\n-------\nThe fully-specified transition diagram for our color sequencer is as follows: \n\n{c|l}\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe transition diagram for our color sequencer is shown to the right, with states looping and marked with the internal state value S_2S_1S_0 and the output RGB.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe fully-specified transition diagram for our color sequencer appears to the right. The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB. As before, we can use the transition diagram to fill in K-maps for the next-state values S_2^+, S_1^+, and S_0^+, as shown to the right. For each of the three states not included in our transition diagram, we have inserted x's into the K-maps to indicate \""don't care.\"" As you know, we can treat each x as either a 0 or a 1, whichever produces better results (where \""better\"" usually means simpler equations). The terms that we have chosen for our algebraic equations are illustrated in the K-maps. The x's within the ellipses become 1s in the implementation, and the x's outside of the ellipses become 0s.\n\nFor our next-state logic, we obtain:\n\nS_2^+ = S_2 S_1 + {{S_1}} {{S_0}}\n\nS_1^+ = S_2 S_0 + {{S_1}} {{S_0}}\n\nS_0^+ = S_1\n\nAgain our equations for S_2^+ and S_1^+ share a common term, which becomes a single AND gate""
 }
]","{
 ""id"": 102
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops are needed to create a counter to drive a light through a sequence of colors?\n#### Option 1\n-------\nThree flip-flops are needed to create a counter to drive a light through a sequence of colors.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAt least three flip-flops are needed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAt least three flip-flops are needed to create a counter to drive a light through a sequence of colors. This is because the colors we need to produce as outputs are all unique bit patterns, and we need three flip-flops to store these unique bit patterns.""
 }
]","{
 ""id"": 103
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of using a three-bit red-green-blue encoding for colors?\n#### Option 1\n-------\nThe purpose of using a three-bit red-green-blue encoding for colors is to create a color map that can be used to produce a desired color pattern. This color map is created by using a counter with five states. The states are represented by the internal state value S_2S_1S_0 and the output RGB. The terms that are chosen for the algebraic equations are illustrated in the K-maps. The x's within the ellipses become 1s in the implementation, and the x's outside of the ellipses become 0s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe RGB color model is an additive color model in which red, green, and blue light are added together in various ways to reproduce a broad array of colors.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of using a three-bit red-green-blue encoding for colors is to produce a range of colors that can be used to create a color palette for a given image. This encoding is also known as the RGB color model. The RGB color model is an additive color model in which red, green, and blue light are added together in various ways to reproduce a wide array of colors. The name of the model comes from the initials of the three additive primary colors, red, green, and blue.""
 }
]","{
 ""id"": 104
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the desired pattern for the light?\n#### Option 1\n-------\nThe desired pattern for the light is {off (black) yellow violet green blue}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n{off (black)     yellow     violet     green     blue}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe desired pattern for the light is a three-bit red-green-blue (RGB) encoding for colors. The color mapping for such a system is shown to the right. Imagine that you are charged with creating a counter to drive a light through a sequence of colors. The light takes an RGB input as just described, and the desired pattern is {off (black) yellow violet green blue} You immediately recognize that you merely need a counter with five states. How many flip-flops will we need? At least three, since _2 (5)=3. Given that we need three flip-flops, and that the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values. A fully-specified transition diagram for our color sequencer appears to the right. The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB. As before, we can use the transition diagram to fill in K-maps for the next-state values S_2^+, S_1^+, and S_0^+, as shown to the right. For each of the three states not included in our transition diagram, we have inserted x's into the K-maps to indicate \""don't care.\"" As you know, we can treat each x as either a 0 or a 1, whichever produces better results (""
 }
]","{
 ""id"": 105
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the color mapping for a three-bit RGB encoding system?\n#### Option 1\n-------\nThe color mapping for a three-bit RGB encoding system is as follows:\n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are eight colors in a three-bit RGB encoding system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe color mapping for a three-bit RGB encoding system is shown to the right. The color mapping for such a system is shown to the right. Imagine that you are charged with creating a counter to drive a light through a sequence of colors. The light takes an RGB input as just described, and the desired pattern is {off (black) yellow violet green blue} You immediately recognize that you merely need a counter with five states. How many flip-flops will we need? At least three, since _2 (5)=3. Given that we need three flip-flops, and that the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values. A fully-specified transition diagram for our color sequencer appears to the right. The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB. As before, we can use the transition diagram to fill in K-maps for the next-state values S_2^+, S_1^+, and S_0^+, as shown to the right. For each of the three states not included in our transition diagram, we have inserted x's into the K-maps to indicate \""don't care.\"" As you know, we can treat each x as either a 0 or a 1, whichever produces better results (where \""better\"" usually means""
 }
]","{
 ""id"": 106
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops are needed to create a counter to drive a light through a sequence of colors?\n#### Option 1\n-------\nAt least three flip-flops are needed to create a counter to drive a light through a sequence of colors. This is because there are five colors in the desired sequence, and _2 (5)=3. Therefore, three flip-flops are needed to create a counter to drive a light through a sequence of colors.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThree flip-flops are needed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAt least three flip-flops are needed to create a counter to drive a light through a sequence of colors. This is because the colors we need to produce as outputs are all unique bit patterns, and we need three flip-flops to store these unique bit patterns.""
 }
]","{
 ""id"": 107
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the desired pattern for the light?\n#### Option 1\n-------\nThe color mapping for a three-bit RGB encoding system is shown to the right. The light takes an RGB input as just described, and the desired pattern is {off (black) yellow violet green blue}. You immediately recognize that you merely need a counter with five states.  At least three, since _2 (5)=3.  Given that we need three flip-flops, and that the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values.  A fully-specified transition diagram for our color sequencer appears to the right.  The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB.  As before, we can use the transition diagram to fill in K-maps for the next-state values S_2^+, S_1^+, and S_0^+, as shown to the right.  For each of the three states not included in our transition diagram, we have inserted x's into the K-maps to indicate ``don't care.''  As you know, we can treat each x as either a 0 or a 1, whichever produces better results (where ``better'' usually means simpler equations).  The terms that we have chosen for our algebraic equations are illustrated in the K-maps.  The x's within the ellipses become 1s in the""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe desired pattern is {off (black) yellow violet green blue}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe desired pattern for the light is {off (black) yellow violet green blue}. A three-bit RGB encoding system is needed to create a counter to drive the light through the sequence of colors. The color mapping for such a system is shown below.\n\nThe light takes an RGB input as just described, and the desired pattern is {off (black) yellow violet green blue}. You immediately recognize that you merely need a counter with five states. How many flip-flops will we need? At least three, since _2 (5)=3. Given that we need three flip-flops, and that the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values.\n\nA fully-specified transition diagram for our color sequencer appears below. The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB. As before, we can use the transition diagram to fill in K-maps for the next-state values S_2^+, S_1^+, and S_0^+, as shown below. For each of the three states not included in our transition diagram, we have inserted x's into the K-maps to indicate \""don't care.\"" As you know, we can treat each x as either a 0 or a 1, whichever produces better results (where \""better\""""
 }
]","{
 ""id"": 108
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the color mapping work for a three-bit RGB system?\n#### Option 1\n-------\nThe color mapping for a three-bit RGB system encodes colors as follows:\n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe color mapping for a three-bit RGB system is as follows: RGB 000 is black, RGB 001 is blue, RGB 010 is green, RGB 011 is cyan, RGB 100 is red, RGB 101 is violet, RGB 110 is yellow, and RGB 111 is white.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n""
 }
]","{
 ""id"": 109
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it necessary to use at least three flip-flops?\n#### Option 1\n-------\nIt is necessary to use at least three flip-flops because the colors we need to produce as outputs are all unique bit patterns, and we need to use the counter's internal state directly as our output values.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nBecause the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, it is necessary to use at least three flip-flops because the colors that need to be produced as outputs are all unique bit patterns. In the second context, it is necessary to use at least three flip-flops because the FSM needs to be able to move out of the WHITE state.""
 }
]","{
 ""id"": 110
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many states are in the loop for the fully-specified transition diagram?\n#### Option 1\n-------\nThere are 8 states in the loop for the fully-specified transition diagram.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are 8 states in the loop.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are five states in the loop for the fully-specified transition diagram.""
 }
]","{
 ""id"": 111
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the color mapping for a three-bit red-green-blue encoding system?\n#### Option 1\n-------\nThe color mapping for a three-bit red-green-blue encoding system is as follows:\n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe color mapping is shown to the right, with the states forming a loop and marked with the internal state value S_2S_1S_0 and the output RGB.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe color mapping for a three-bit red-green-blue encoding system is as follows:\n\nRed: 000\n\nGreen: 001\n\nBlue: 010\n\nCyan: 011\n\nYellow: 100\n\nViolet: 101\n\nWhite: 110\n\nBlack: 111""
 }
]","{
 ""id"": 112
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops are needed to create a counter that drives a light through a sequence of colors?\n#### Option 1\n-------\nAt least three flip-flops are needed to create a counter that drives a light through a sequence of colors. This is because the number of states required (5) is greater than the number of states that can be represented with two flip-flops (3).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThree flip-flops are needed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAt least three flip-flops are needed to create a counter that drives a light through a sequence of colors. This is because the colors we need to produce as outputs are all unique bit patterns, and we need three flip-flops to store these unique bit patterns.""
 }
]","{
 ""id"": 113
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the transition diagram for a fully-specified color sequencer?\n#### Option 1\n-------\nThe transition diagram for a fully-specified color sequencer is shown in the figure to the right. The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe transition diagram for a fully-specified color sequencer is a loop of states that are marked with the internal state value S_2S_1S_0 and the output RGB.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe transition diagram for a fully-specified color sequencer is shown to the right. The states form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB. As before, we can use the transition diagram to fill in K-maps for the next-state values S_2^+, S_1^+, and S_0^+, as shown to the right. For each of the three states not included in our transition diagram, we have inserted x's into the K-maps to indicate \""don't care.\"" As you know, we can treat each x as either a 0 or a 1, whichever produces better results (where \""better\"" usually means simpler equations). The terms that we have chosen for our algebraic equations are illustrated in the K-maps. The x's within the ellipses become 1s in the implementation, and the x's outside of the ellipses become 0s.\n\nFor our next-state logic, we obtain:\n\nS_2^+ = S_2 S_1 + S_1 S_0\n\nS_1^+ = S_2 S_0 + S_1 S_0\n\nS_0^+ = S_1\n\nAgain our equations for S_2^+ and S_1^+ share a common term, which becomes a single AND gate in the implementation shown to the right.""
 }
]","{
 ""id"": 114
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the color mapping for a three-bit RGB encoding system?\n#### Option 1\n-------\nThe color mapping for a three-bit RGB encoding system is as follows:\n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are eight colors in a three-bit RGB encoding system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe color mapping for a three-bit RGB encoding system is shown to the right. The color mapping for such a system is shown to the right. Imagine that you are charged with creating a counter to drive a light through a sequence of colors. The light takes an RGB input as just described, and the desired pattern is {off (black) yellow violet green blue} You immediately recognize that you merely need a counter with five states. How many flip-flops will we need? At least three, since _2 (5)=3. Given that we need three flip-flops, and that the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values. A fully-specified transition diagram for our color sequencer appears to the right. The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB. As before, we can use the transition diagram to fill in K-maps for the next-state values S_2^+, S_1^+, and S_0^+, as shown to the right. For each of the three states not included in our transition diagram, we have inserted x's into the K-maps to indicate \""don't care.\"" As you know, we can treat each x as either a 0 or a 1, whichever produces better results (where \""better\"" usually means""
 }
]","{
 ""id"": 115
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the desired pattern for the light?\n#### Option 1\n-------\nThe desired pattern for the light is {off (black)     yellow     violet     green     blue}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe desired pattern is {off (black) yellow violet green blue}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe desired pattern for the light is a three-bit red-green-blue (RGB) encoding for colors. The color mapping for such a system is shown to the right. Imagine that you are charged with creating a counter to drive a light through a sequence of colors. The light takes an RGB input as just described, and the desired pattern is {off (black) yellow violet green blue} You immediately recognize that you merely need a counter with five states. How many flip-flops will we need? At least three, since _2 (5)=3. Given that we need three flip-flops, and that the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values. A fully-specified transition diagram for our color sequencer appears to the right. The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB. As before, we can use the transition diagram to fill in K-maps for the next-state values S_2^+, S_1^+, and S_0^+, as shown to the right. For each of the three states not included in our transition diagram, we have inserted x's into the K-maps to indicate \""don't care.\"" As you know, we can treat each x as either a 0 or a 1, whichever produces better results (""
 }
]","{
 ""id"": 116
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops are needed to create a counter to drive the light through a sequence of colors?\n#### Option 1\n-------\nThree flip-flops are needed to create a counter to drive the light through a sequence of colors.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThree flip-flops are needed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAt least three flip-flops are needed to create a counter to drive the light through a sequence of colors. This is because the colors we need to produce as outputs are all unique bit patterns, and we need three flip-flops to store these unique bit patterns.""
 }
]","{
 ""id"": 117
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why does the system need at least three flip-flops?\n#### Option 1\n-------\nThe system needs at least three flip-flops because the colors we need to produce as outputs are all unique bit patterns.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe system needs at least three flip-flops because there are five states and _2 (5)=3.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe system needs at least three flip-flops because the colors we need to produce as outputs are all unique bit patterns.""
 }
]","{
 ""id"": 118
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many states are in the loop?\n#### Option 1\n-------\nThere are five states in the loop.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are five states in the loop.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are five states in the loop in the first context, and six states in the loop in the second context.""
 }
]","{
 ""id"": 119
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does the 'x' mean in the K-map?\n#### Option 1\n-------\nThe 'x' in the K-map indicates a don't care condition. This means that the output will be the same regardless of whether the input is a 0 or 1.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n\""The 'x' in the K-map means 'don't care.'\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe 'x' in the K-map means that the corresponding minterm is not included in the function.""
 }
]","{
 ""id"": 120
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops is unknown unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state of the three flip-flops is unknown and may cause the light to stay white indefinitely.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is 0.""
 }
]","{
 ""id"": 121
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe FSM can get into the unexpected states if the three flip-flops have an initial state that is not 0s and 1s. To address this issue, we can add a few AND gates and a  input (active low) to our design. This will allow us to assert  by setting it to 0, which will move the FSM to state 000 in the next cycle and put it into the BLACK state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM's initial state may not be 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM can get into unexpected states in two ways. The first way is if the flip-flops are not properly initialized. The second way is if the inputs to the FSM are not properly controlled.""
 }
]","{
 ""id"": 122
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nPlugging into the equations or looking into the K-maps gives (of course) the same answer: the next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, if the FSM is in an unexpected state, it will move to the initial state of the three flip-flops. In the second context, if the FSM is in an unexpected state, it will move to the state specified by the I_2I_1I_0 input.""
 }
]","{
 ""id"": 123
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is undefined.""
 }
]","{
 ""id"": 124
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is unknown. The FSM may get into unexpected states if the initial state is not 0s and 1s. \n\nWe can add a few AND gates and an INIT input (active low) to our design, as shown in the dashed box in the figure. In this case, when we assert INIT by setting it to 0, the FSM moves to state 000 in the next cycle, putting it into the BLACK state. \n\nWe may sometimes want a more powerful initialization mechanism---one that allows us to force the FSM into any specific state in the next cycle.  In such a case, we can add multiplexers to each of our flip-flop inputs, allowing us to use the INIT input to choose between normal operation (INIT=0) of the FSM and forcing the FSM into the next state given by I_2I_1I_0 (when INIT=1).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state of the three flip-flops in our implementation is unknown, which could lead to the FSM getting into unexpected states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM can get into unexpected states in two ways. The first way is if the flip-flops are not properly reset. The second way is if the inputs to the FSM are not properly initialized.""
 }
]","{
 ""id"": 125
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWhen a system is in an unexpected state, it may enter into an undefined state. In our implementation, the three flip-flops may enter into an undefined state. To avoid this, we can add a few AND gates and an input (active low), as shown in the dashed box in the figure to the right. In this case, when we assert the input by setting it to 0, the FSM moves to state 000 in the next cycle, putting it into the BLACK state.""
 }
]","{
 ""id"": 126
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why does the light sometimes glow cyan or red briefly before turning white?\n#### Option 1\n-------\nThe light is initially in the S_2S_1S_0=111 state. In such a state, the light would appear white, since RGB=S_2S_1S_0=111. However, the FSM does not move out of the WHITE state (ever).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM is in an unexpected state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two possible reasons for this behavior. First, it is possible that the FSM is getting into the S_2S_1S_0=111 state by chance, due to the randomness of the input signal. In such a case, the light would appear white, since RGB=S_2S_1S_0=111. However, the next state would be the S_2^+S_1^+S_0^+=111 state, and the light would stay white indefinitely. Second, it is also possible that the FSM is getting into the S_2S_1S_0=111 state due to a glitch in the input signal. In such a case, the light would appear white for a brief period of time, before the FSM corrects itself and continues with the desired sequence.""
 }
]","{
 ""id"": 127
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is unknown. The FSM may get into the unexpected states if the initial state is not 0s and 1s. We can add a few AND gates and a reset input (active low) to force the FSM into the BLACK state. Alternatively, we can add multiplexers to each of our flip-flop inputs, allowing us to use the INIT input to choose between normal operation (INIT=0) of the FSM and forcing the FSM into the next state given by I_2I_1I_0 (when INIT=1).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state of the three flip-flops in our implementation is unknown, which could lead to the FSM getting into unexpected states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM can get into unexpected states due to errors in the design, implementation, or operation of the FSM. For example, if the inputs to the FSM are not properly synchronized, the FSM may \""glitch\"" and enter an unexpected state. Another example is if the FSM is not reset properly, it may also enter an unexpected state.""
 }
]","{
 ""id"": 128
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is unknown. We need to add extra logic to our design in order to force the FSM into a specific state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state is unknown and could be anything, which is why we need an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is 0.""
 }
]","{
 ""id"": 129
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is not well-defined. Without an explicit mechanism for initialization, the flip-flops may be in any arbitrary state. This can lead to unexpected behavior from the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state of the three flip-flops is unknown and may not be 0s and 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is 0s and 1s.""
 }
]","{
 ""id"": 130
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe FSM can get into unexpected states if the initial state is not properly set. To properly set the initial state, we can add extra logic to our design that will allow us to force the FSM into any specific state in the next cycle. This can be done by adding multiplexers to each of our flip-flop inputs, and using the INIT input to choose between normal operation (INIT=0) of the FSM and forcing the FSM into the next state given by I_2I_1I_0 (when INIT=1).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM's initial state may not be 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM can get into unexpected states in two ways. The first way is if the flip-flops are not properly initialized. The second way is if the inputs to the FSM are not properly synchronized.""
 }
]","{
 ""id"": 131
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, if the FSM is in an unexpected state, it will move to the next state in the next cycle. In the second context, if the user presses the \""halt\"" button, the counter will retain its current state until the user presses the \""go\"" button.""
 }
]","{
 ""id"": 132
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is undefined.""
 }
]","{
 ""id"": 133
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is unknown. The FSM can get into the unexpected states if the initial state is not 0s and 1s. To address this issue, we can add a few AND gates and an INIT input (active low) as shown in the dashed box in the figure. In this case, when we assert INIT by setting it to 0, the FSM moves to state 000 in the next cycle, putting it into the BLACK state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM's initial state may not be 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM can get into unexpected states in two ways. The first way is through the flip-flop design. As you know, a flip-flop is built from a pair of latches, and we can make use of the internal reset lines on these latches to force each flip-flop into the 0 state (or the 1 state) using an additional input. Alternatively, we can add some extra logic to our design. Consider adding a few AND gates and a input (active low), as shown in the dashed box in the figure to the right. In this case, when we assert by setting it to 0, the FSM moves to state 000 in the next cycle, putting it into the BLACK state. The approach taken here is for clarity; one can optimize the design, if desired. For example, we could simply connect as an extra input into the three AND gates on the left rather than adding new ones, with the same effect.\n\nWe may sometimes want a more powerful initialization mechanism---one that allows us to force the FSM into any specific state in the next cycle. In such a case, we can add multiplexers to each of our flip-flop inputs, allowing us to use the INIT input to choose between normal operation (INIT=0) of the FSM and forcing the FSM into the next state given by I_2I_1I_0 (when INIT=1).""
 }
]","{
 ""id"": 134
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nPlugging into the equations or looking into the K-maps gives (of course) the same answer: the next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, if the FSM is in an unexpected state, the initial state of the three flip-flops is unknown. In the second context, if the user presses the \""halt\"" button, the counter will retain its current state.""
 }
]","{
 ""id"": 135
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the FSM move out of the WHITE state?\n#### Option 1\n-------\nThe FSM does not move out of the WHITE state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM does not move out of the WHITE state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the abstract model, the FSM moves out of the WHITE state when the ``go'' button is pressed. In the implementation, the FSM moves out of the WHITE state when the INIT input is asserted.""
 }
]","{
 ""id"": 136
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is 0s and 1s.""
 }
]","{
 ""id"": 137
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can we make use of the internal reset lines on these latches to force each flip-flop into the 0 state?\n#### Option 1\n-------\nWe can add a few AND gates and a  input (active low), as shown in the dashed box in the figure. In this case, when we assert  by setting it to 0, the FSM moves to state 000 in the next cycle, putting it into the BLACK state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nBy adding an extra input, we can make the FSM move to state 000 in the next cycle, putting it into the BLACK state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWhen we assert the INIT input by setting it to 0, the FSM moves to state 000 in the next cycle, putting it into the BLACK state. Alternatively, we can add some extra logic to our design to allow us to force the FSM into any specific state in the next cycle. For example, we could add multiplexers to each of our flip-flop inputs, allowing us to use the INIT input to choose between normal operation (INIT=0) of the FSM and forcing the FSM into the next state given by I_2I_1I_0 (when INIT=1).""
 }
]","{
 ""id"": 138
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state may not be 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is 0s and 1s.""
 }
]","{
 ""id"": 139
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nWhat is the initial state of the three flip-flops in our implementation?\\n\nThe initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization. Initialization can work in two ways. The first approach makes use of the flip-flop design. As you know, a flip-flop is built from a pair of latches, and we can make use of the internal reset lines on these latches to force each flip-flop into the 0 state (or the 1 state) using an additional input. Alternatively, we can add some extra logic to our design. Consider adding a few AND gates and a input (active low), as shown in the dashed box in the figure to the right. In this case, when we assert by setting it to 0, the FSM moves to state 000 in the next cycle, putting it into the BLACK state. The approach taken here is for clarity; one can optimize the design, if desired. For example, we could simply connect as an extra input into the three AND gates on the left rather than adding new ones, with the same effect. We may sometimes want a more powerful initialization mechanism\u2014one that allows us to force the FSM into any specific state in the next cycle. In such a case, we can add multiplexers to each of our flip-flop inputs, allowing us to use the INIT input to choose between normal operation (INIT=0)""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM's initial state may not be 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM can get into unexpected states in two ways. The first way is if the flip-flops are not properly initialized. The second way is if the inputs to the FSM are not properly synchronized.""
 }
]","{
 ""id"": 140
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nPlugging into the equations or looking into the K-maps gives (of course) the same answer: the next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWhen a system is in an unexpected state, it may either stay in that state or transition to another state. The initial state of the three flip-flops in our implementation is unknown unless we have an explicit mechanism for initialization. We can add a few AND gates and an input (active low) to initialize the FSM in the desired state.""
 }
]","{
 ""id"": 141
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is undefined.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state may not be 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is 0s and 1s.""
 }
]","{
 ""id"": 142
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe FSM can get into the unexpected states if the initial state of the three flip-flops is not 0s and 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM's initial state may not be 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM can get into unexpected states in two ways. The first way is if the flip-flops are not properly initialized. The second way is if the inputs to the FSM are not properly synchronized.""
 }
]","{
 ""id"": 143
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nPlugging into the equations or looking into the K-maps gives (of course) the same answer: the next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, if the FSM is in an unexpected state, it will move to the initial state of 000. In the second context, if the FSM is in an unexpected state, it will move to the next state given by I_2I_1I_0.""
 }
]","{
 ""id"": 144
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why does the light sometimes glow cyan or red briefly before turning white?\n#### Option 1\n-------\nThe light is briefly glowing cyan or red because the FSM is in an unexpected state. The FSM is in an unexpected state because the initial state of the three flip-flops is unknown.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM is in an unexpected state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe light sometimes glows cyan or red briefly before turning white because the FSM is in one of the extra states that are not part of the design. These extra states are caused by the choice of next-state expressions, which are not unique.""
 }
]","{
 ""id"": 145
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe FSM can get into unexpected states if the initial state of the three flip-flops is not properly set. One way to address this is by adding a few AND gates and an INIT input (active low). This will allow the FSM to move to state 000 in the next cycle, putting it into the BLACK state. Another way to address this is by adding multiplexers to each of the flip-flop inputs, allowing the INIT input to choose between normal operation (INIT=0) of the FSM and forcing the FSM into the next state given by I_2I_1I_0 (when INIT=1).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state of the three flip-flops in our implementation is unknown, which can lead to the FSM getting into unexpected states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM can get into unexpected states in two ways. The first way is if the flip-flops are not properly initialized. The second way is if the inputs to the FSM are not properly synchronized.""
 }
]","{
 ""id"": 146
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is unknown. We need to add extra logic to our design in order to force the FSM into a specific state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state of the three flip-flops is unknown and could be anything.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is 0s and 1s. We can use the INIT input to choose between normal operation (INIT=0) of the FSM and forcing the FSM into the next state given by I_2I_1I_0 (when INIT=1).""
 }
]","{
 ""id"": 147
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of an abstract model?\n#### Option 1\n-------\nThe purpose of an abstract model is to provide a simplified representation of a system. Abstract models are often used to design and analyze complex systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of an abstract model is to provide a simplified representation of a system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAn abstract model is a simplified representation of a system, usually created for the purpose of understanding or analyzing that system. In the context of digital systems, an abstract model might be used to understand the behavior of a system or to design a new system. In the context of instruction processing, an abstract model might be used to understand the behavior of a processor or to design a new processor.""
 }
]","{
 ""id"": 148
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are some design choices that were made in this context?\n#### Option 1\n-------\nA few design choices were made in this context. First, the counter retains the current state of the system when \""halt\"" is pressed. Second, the counter is designed to stop when the user presses \""halt\"" and to resume counting when the user presses \""go.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design choices made were that the counter would retain its current state when 'halt' was pressed, and that pressing 'halt' in state { COUNT B} would take the counter to state { HALT C}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nSome design choices that were made in this context include the following:\n\n- The choice to use a finite state machine (FSM) to model the behavior of the system.\n- The choice to use a clocked synchronous FSM implementation, in which the FSM's internal state bits are stored in flip-flops.\n- The choice to include outputs for each state in the FSM.\n- The choice to assume that outputs depend only on the state of the FSM.""
 }
]","{
 ""id"": 149
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between a next-state table and a transition diagram?\n#### Option 1\n-------\nA next-state table lists the states, while each of the other columns lists states to which the FSM transitions after a clock cycle for a particular input combination. A transition diagram provides exactly the same information in graphical form.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA next-state table lists the states, while each of the other columns lists states to which the FSM transitions after a clock cycle for a particular input combination. A transition diagram is a graphical representation of states and transitions between them.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main difference between a next-state table and a transition diagram is that a next-state table is a more abstract way of representing an FSM, while a transition diagram is a more concrete and specific way of representing an FSM. \n\nA next-state table simply lists the possible states of an FSM and the inputs that lead to each state. It does not specify how the FSM should behave in each state, or what the output of the FSM should be in each state. \n\nA transition diagram, on the other hand, specifies the behavior of an FSM in each state, and the output of the FSM in each state. It is therefore a more specific and concrete representation of an FSM.""
 }
]","{
 ""id"": 150
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of an FSM?\n#### Option 1\n-------\nThe purpose of an FSM is to model the behavior of a system. In this case, the FSM models the behavior of a two-bit Gray code counter. The FSM is designed to start and stop the counting based on user input.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of an FSM is to model the behavior of a system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of an FSM is to model the behavior of a system. This can be useful in understanding the system's behavior, in designing an implementation of the system, or in testing the system. For example, an FSM can be used to model the behavior of a digital circuit, such as a counter. The FSM can be used to determine the next state of the circuit based on the current state and the inputs. The FSM can also be used to generate test vectors for the circuit.""
 }
]","{
 ""id"": 151
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the inputs and outputs of an FSM?\n#### Option 1\n-------\nThe inputs of an FSM are the signals that the FSM uses to determine its next state. The outputs of an FSM are the signals that the FSM produces based on its current state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe inputs and outputs of an FSM are the current state and the next state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn an FSM, the inputs and outputs are typically bits. However, in some cases, the inputs and outputs may need to match other digital systems to which the FSM is connected. For example, if the FSM is part of a larger digital system, the inputs and outputs of the FSM may need to be compatible with the other parts of the system.""
 }
]","{
 ""id"": 152
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the states of an FSM?\n#### Option 1\n-------\nThe states of an FSM are the states that the FSM can be in at any given time. In this design, there are four counting states and four halted states. The purpose of the states is to represent the different possible states that the FSM can be in. The FSM transitions to the next state after a clock cycle for a particular input combination.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM has four counting states and four halted states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe states of an FSM represent the different possible states that the machine can be in at any given time. The FSM transitions to the next state after a clock cycle for a particular input combination. The purpose of the states is to represent the different possible states that the machine can be in at any given time. There are four counting states and four halted states.""
 }
]","{
 ""id"": 153
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between 'counting' and 'halted' states?\n#### Option 1\n-------\nIn the 'counting' state, the counter cycles through the states indefinitely. In the 'halted' state, the counter retains its current value until the 'go' button is pressed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nCounting states represent uninterrupted counting, in which the counter cycles through these states indefinitely. A user can stop the counter in any state by pressing the ``halt'' button, causing the counter to retain its current value until the user presses the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two main differences between counting and halted states. First, in a counting state, the system is actively counting and outputting a value, while in a halted state, the system is inactive and does not output a value. Second, in a counting state, the system may transition to a different state in response to an input, while in a halted state, the system will remain in the same state regardless of input.""
 }
]","{
 ""id"": 154
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many states are in the second version of the table?\n#### Option 1\n-------\nThe second version of the table has four counting states and four halted states, for a total of eight states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n8""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are four states in the second version of the table.""
 }
]","{
 ""id"": 155
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does pressing the 'halt' button do when the counter is in a 'halted' state?\n#### Option 1\n-------\nPressing the 'halt' button when the counter is in a 'halted' state has no effect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nPressing the 'halt' button has no effect when the counter is in a 'halted' state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWhen the counter is in a halted state, pressing the 'halt' button has no effect.""
 }
]","{
 ""id"": 156
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the two states in the first column of the table?\n#### Option 1\n-------\nThe two states in the first column of the table are counting and halted.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe two states are \""counting\"" and \""halted.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two states in the first column of the table are LOCKED and DRIVER.""
 }
]","{
 ""id"": 157
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the four counting states?\n#### Option 1\n-------\nThe four counting states are { COUNT A}, { COUNT B}, { COUNT C}, and { COUNT D}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe four counting states are { COUNT A}, { COUNT B}, { COUNT C}, and { COUNT D}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe four counting states are:\n\n1. COUNT A: The state in which the counter is counting up from 0 to 3.\n\n2. COUNT B: The state in which the counter is counting down from 3 to 0.\n\n3. COUNT C: The state in which the counter is counting up from 0 to 1.\n\n4. COUNT D: The state in which the counter is counting down from 1 to 0.""
 }
]","{
 ""id"": 158
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of the ``halt'' button?\n#### Option 1\n-------\nThe purpose of the ``halt'' button is to provide a mechanism for stopping and starting the counter. The table implies that if the counter is halted, the \""halt\"" button has no additional effect. A user can stop the counter in any state by pressing the \""halt\"" button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of the ``halt'' button is to stop the counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two reasons why it is important to have a mechanism for stopping and starting the counter. First, if the user wants to change the value of the counter, they need to be able to stop it so that they can enter the new value. Second, if the user wants to inspect the current value of the counter, they need to be able to stop it so that they can read the value.\n\nThe table implies that if the counter is halted, the \""halt\"" button has no additional effect because the counter is already in the halted state.\n\nThe user can stop the counter in any state by pressing the \""halt\"" button.""
 }
]","{
 ""id"": 159
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of an FSM?\n#### Option 1\n-------\nThe purpose of an FSM is to model the behavior of a system. In this case, the FSM models the behavior of a two-bit Gray code counter. The FSM can be used to determine the next state of the system based on the current state and the inputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of an FSM is to model the behavior of a system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of an FSM is to model the behavior of a system. This can be useful in understanding the system's behavior, designing an implementation, or both. For example, an FSM can be used to model the behavior of a digital circuit, such as a counter. By understanding the behavior of the counter, we can design an implementation that is simpler and easier to build correctly.""
 }
]","{
 ""id"": 160
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the benefits of using an FSM?\n#### Option 1\n-------\nThere are several benefits of using an FSM:\n\n1. FSMs are easy to design and implement.\n2. FSMs are easy to understand and debug.\n3. FSMs can be used to model complex systems.\n4. FSMs can be used to design efficient digital circuits.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nFSMs are benefits because they are easy to design, test, and implement. They are also easy to change if the requirements of the system change.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are several benefits to using an FSM in design. First, FSMs can be used to model complex systems in a way that is easy for humans to understand. Second, FSMs can be used to simplify the implementation of complex systems by breaking them down into smaller, more manageable pieces. Finally, FSMs can be used to optimize the performance of complex systems by choosing an efficient state representation.""
 }
]","{
 ""id"": 161
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does an FSM work?\n#### Option 1\n-------\nFSMs work by reading in a input and changing states based on that input. In our example, we have a two-bit Gray code counter. This counter has two states, counting and halted. The counter cycles through these states indefinitely. A user can stop the counter in any state by pressing the \""halt\"" button, causing the counter to retain its current value until the user presses the \""go\"" button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Finite State Machine (FSM) is a model of behavior composed of a finite number of states, transitions between those states, and actions.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAn FSM works by transitioning from one state to another in response to an input. The specific behavior of an FSM is determined by its state transition diagram, which specifies the states, inputs, and outputs, as well as the conditions for transitioning from one state to another.""
 }
]","{
 ""id"": 162
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of an FSM?\n#### Option 1\n-------\nThe purpose of an FSM is to model the behavior of a system. In this case, the FSM models the behavior of a two-bit Gray code counter. The FSM can be used to determine the next state of the system based on the current state and the inputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of an FSM is to model the behavior of a system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of an FSM is to model the behavior of a system. In particular, an FSM can be used to model the behavior of a digital system. A digital system is a system that uses digital signals, which are signals that can take on only a finite number of values. An FSM can be used to model the behavior of a digital system by specifying the behavior of the system in terms of a state transition diagram. The state transition diagram specifies the states of the system and the transitions between those states.""
 }
]","{
 ""id"": 163
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the inputs and outputs of an FSM?\n#### Option 1\n-------\nThe inputs to an FSM are the signals that the FSM uses to determine its next state. The outputs of an FSM are the signals that the FSM produces based on its current state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe inputs and outputs of an FSM are the current state and the next state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, the inputs and outputs of an FSM are the abstract model and the desired behavior. In the second context, the inputs and outputs of an FSM are the input and output behavior.""
 }
]","{
 ""id"": 164
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the states of an FSM?\n#### Option 1\n-------\nThere are four states in an FSM: counting, halted, no input, and go button. The counter knows when to stop and start again because of the two different buttons. The purpose of the two different buttons is to move between the states. If the user pressed both buttons at the same time, the counter would reset.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM has two states, counting and halted, and uses two buttons to transition between them.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe states of an FSM are the different conditions that the machine can be in at any given time. The machine changes state in response to input signals, and the output signals depend on the current state of the machine. In the design process, we first develop an abstract model of the machine, specifying the states and the desired behavior. We then specify the input and output behavior, and complete the specification by making any other necessary decisions. Finally, we choose a state representation and calculate the logic expressions for the next-state variables and the output signals.""
 }
]","{
 ""id"": 165
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the two control buttons?\n#### Option 1\n-------\nThe two control buttons are the ``halt'' button and the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe \""halt\"" button is H, and the \""go\"" button is G.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two control buttons are the L button to request a serving of lychee ice cream, and the M button to request a serving of mango ice cream.""
 }
]","{
 ""id"": 166
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does a two-bit Gray code represent?\n#### Option 1\n-------\nA two-bit Gray code is a code that represents two-bit numbers in a way that only one bit changes between successive numbers. Gray codes are often used in applications where it is important to minimize the number of bits that change between successive numbers, such as in digital communications.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA two-bit Gray code is a code that represents two-bit numbers in a way that only one bit changes between successive numbers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA two-bit Gray code represents two bits of information. The first bit is the most significant bit (MSB), and the second bit is the least significant bit (LSB). The two bits are represented as a single unit, with the MSB being the first bit and the LSB being the second bit.""
 }
]","{
 ""id"": 167
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the uninterrupted counting cycle labeled with?\n#### Option 1\n-------\nThe uninterrupted counting cycle is labeled with to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe uninterrupted counting cycle is labeled with 'to indicate that it continues until we press H.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe uninterrupted counting cycle is labeled with a 'continue' symbol to indicate that it continues until we press the Halt button.""
 }
]","{
 ""id"": 168
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the input behavior?\n#### Option 1\n-------\nThe input behavior is that each of the two control buttons provides a single bit of input. The ``halt'' button we call H, and the ``go'' button we call G.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe input behavior is two control buttons, H for halt and G for go.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe input behavior is that when a user presses more than one button, the outputs are unspecified. The root of the problem is that while we don't care about the value of any particular output marked \""x\"" for any particular input combination, we do actually care about the relationship between the outputs.""
 }
]","{
 ""id"": 169
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the output behavior?\n#### Option 1\n-------\nThe output behavior is a two-bit Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe output is a two-bit Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAssuming that the user only presses one button at a time, the output behavior is as follows: if none of the buttons are pushed (LBM=000), we get no ice cream (C_M=00 and C_L=00); if we request lychee ice cream (LBM=100), the outputs are C_L=10 and C_M=00, so we get a full serving of lychee and no mango; if we request a blend (LBM=010), the outputs are C_L=01 and C_M=01, giving us half a serving of each flavor; finally, if we request mango ice cream (LBM=001), we get no lychee but a full serving of mango.\n\nHowever, if a user presses more than one button, the ice cream cup may overflow. For example, if the user presses the lychee and mango buttons (LBM=101), the outputs are C_L=10 and C_M=10, so our dispenser releases a full serving of each flavor, or two servings total. Another example is pressing lychee and blend (LBM=110); in this case, the outputs are C_L=11 and C_M=01.""
 }
]","{
 ""id"": 170
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What do the buttons 'halt' and 'go' do?\n#### Option 1\n-------\nThe \""halt\"" button H and the \""go\"" button G provide input to the system. The \""halt\"" button H stops the system from counting and the \""go\"" button G allows the system to continue counting.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe \""halt\"" button we call H, and the \""go\"" button we call G.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe \""halt\"" button halts the counter, and the \""go\"" button resumes counting.""
 }
]","{
 ""id"": 171
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""Why use a two-bit Gray code for the output?\n#### Option 1\n-------\nThere are a few reasons for why we might use a two-bit Gray code for the output. \n\nFirst, Gray codes are designed to minimize the number of changes that need to be made to the code when moving from one number to the next. This can be helpful when we want to avoid potential errors that might occur if the code were to change too rapidly. \n\nSecond, using a Gray code can help to ensure that only one bit changes at a time. This can be helpful in situations where we need to minimize the amount of change happening at any given time, such as when we are monitoring a slowly changing signal. \n\nOverall, using a Gray code can help to make our design more robust and reliable.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nGray code ensures that only one bit changes at a time.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two main reasons for using a two-bit Gray code for the output. First, it allows for more efficient use of the output bits. Second, it makes it easier to detect errors in the output.\n\nThe first reason is due to the way that Gray codes are constructed. In a Gray code, each successive output value differs from the previous one by only one bit. This means that, for a two-bit Gray code, the output values will be either 00, 01, 10, or 11. In comparison, if we were to use a two-bit binary code, the output values could be any combination of two bits, such as 00, 01, 10, 11, 100, 101, 110, or 111. This means that, with a two-bit Gray code, we can use the output bits more efficiently because there are fewer possible output values.\n\nThe second reason is that Gray codes are easier to detect errors in. This is because, with a Gray code, if there is an error in one bit, it will only affect one output value. For example, if the input is 01 and the output is 10, we know that there is an error in one bit. In contrast, if we were using a two-bit binary code, an error in one bit could affect any number of output values. For example, if the input is 01 and the output is 11, we don't know if the error is in the first or""
 }
]","{
 ""id"": 172
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How does this choice of output allow us to redraw the transition diagram?\n#### Option 1\n-------\nThe choice of output allows us to redraw the transition diagram because it provides a two-bit Gray code. With this code, we can mark the states with output values Z_1Z_0 and transition arcs with our two input buttons, G and H. The uninterrupted counting cycle is then labeled with to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWith these choices, we can redraw the transition diagram as show to the right.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWhen we add the counter to our design, the state of the counter is technically part of the state of our FSM, but we can treat it somewhat abstractly. For example, we only plan to make use of the counter value in the ALARM state, so we ignore the counter bits in the three other states. In other words, S_1S_0=10 means that the system is in the LOCKED state regardless of the counter's value.\n\nWe expand the ALARM state into T separate states based on the value of the counter. As shown in the figure, we name the states ALARM(1) through ALARM(T). All of these alarm states use S_1S_0=01, but they can be differentiated using a \""timer\"" (the counter value).""
 }
]","{
 ""id"": 173
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the significance of labeling the uninterrupted counting cycle with ?\n#### Option 1\n-------\nThe significance of labeling the uninterrupted counting cycle with is to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe uninterrupted counting cycle is labeled with to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe significance of labeling the uninterrupted counting cycle with is that it indicates that the counting will continue until the user presses the Halt button. This is useful in specifying the behavior of the system, since it allows us to systematically consider all possible input conditions from all possible states.""
 }
]","{
 ""id"": 174
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the two control buttons?\n#### Option 1\n-------\nThe two control buttons are the ``halt'' button and the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe \""halt\"" button is H, and the \""go\"" button is G.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two control buttons are the power button and the reset button.""
 }
]","{
 ""id"": 175
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What does a two-bit Gray code represent?\n#### Option 1\n-------\nA two-bit Gray code is a code that is used to represent a binary number in a way that minimizes the number of changes required when the number represented by the code is incremented or decremented by one.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA two-bit Gray code is a code that represents two-bit numbers in a way that only one bit changes between successive numbers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a type of code used to represent numbers in a way that minimizes the number of bits that need to be changed when the number represented by the code is incremented or decremented. A two-bit Gray code can represent four different numbers: 00, 01, 10, and 11.""
 }
]","{
 ""id"": 176
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the uninterrupted counting cycle labeled with?\n#### Option 1\n-------\nThe uninterrupted counting cycle is labeled with to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe uninterrupted counting cycle is labeled with to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe uninterrupted counting cycle is labeled with a Gray code. This code is used to indicate the output of the counter. The code is read from left to right, and the first bit indicates the most significant bit (MSB). The second bit indicates the least significant bit (LSB).""
 }
]","{
 ""id"": 177
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the two input buttons?\n#### Option 1\n-------\nThe two input buttons are the ``halt'' button and the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe two input buttons are \""halt\"" and \""go.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two input buttons on a computer: the left button and the right button.""
 }
]","{
 ""id"": 178
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the output behavior?\n#### Option 1\n-------\nThe output behavior is a two-bit Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe output is a two-bit Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAssuming that the user only presses one button at a time, the output behavior is as follows. If none of the buttons are pushed (LBM=000), the outputs are C_L=00 and C_M=00, indicating no ice cream. If the user requests lychee ice cream (LBM=100), the outputs are C_L=10 and C_M=00, indicating a full serving of lychee and no mango. If the user requests a blend (LBM=010), the outputs are C_L=01 and C_M=01, indicating half a serving of each flavor. Finally, if the user requests mango ice cream (LBM=001), the outputs are C_L=00 and C_M=10, indicating no lychee but a full serving of mango.""
 }
]","{
 ""id"": 179
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does the uninterrupted counting cycle label mean?\n#### Option 1\n-------\nThe uninterrupted counting cycle label means that the cycle continues until the H button is pressed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe uninterrupted counting cycle label means that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, the uninterrupted counting cycle label means that the counter will continue counting until the user presses the halt button. In the second context, the uninterrupted counting cycle label means that the counter will continue counting until the user presses the go button.""
 }
]","{
 ""id"": 180
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the Gray code work?\n#### Option 1\n-------\nThe Gray code is a way of representing numbers in a way that only one bit changes between successive numbers. This is useful for digital devices, like our example, because it minimizes the number of changes that need to be made to the output. The two-bit Gray code is shown to the right.\\n""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe Gray code is a two-bit code that specifies the output behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe Gray code is a code used to represent numbers in a way that minimizes the number of bits that need to be changed to represent a different number. The code is named after Frank Gray, who introduced the code in 1953. \n\nThe Gray code is based on the binary number system, but the bits are arranged in a way that minimizes the number of changes that need to be made to represent a different number. For example, in the binary number system, the number \""10\"" can be represented as \""1010\"" or \""1100\"". In the Gray code, the number \""10\"" can be represented as \""11\"" or \""10\"", which only requires one bit to be changed. \n\nThe Gray code is often used in applications where a small number of bits need to be changed to represent a different number, such as in electrical or optical systems.""
 }
]","{
 ""id"": 181
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the effect of button H?\n#### Option 1\n-------\nButton H has the effect of halting the system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nButton H halts the cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe effect of button H is to halt the counter. If the counter is already halted, pressing button H has no effect.""
 }
]","{
 ""id"": 182
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the effect of button G?\n#### Option 1\n-------\nPressing button G has the effect of incrementing the state by one. In other words, it changes the output value from Z_1Z_0 to Z_1'Z_0', where Z_1' and Z_0' are the next values in the Gray code sequence.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nButton G starts the machine.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe effect of button G is to gate the D latch, which controls whether or not Q mirrors the value of D. If WE is 1, then Q=D. If WE is 0, then Q can occupy either of the two possible states, regardless of the value of D.""
 }
]","{
 ""id"": 183
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the two control buttons?\n#### Option 1\n-------\nThe two control buttons are the ``halt'' button and the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe \""halt\"" button is H, and the \""go\"" button is G.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n\\n\n\nThe two control buttons are the power button and the reset button.""
 }
]","{
 ""id"": 184
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the output behavior?\n#### Option 1\n-------\nThe output behavior is a two-bit Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe output is a two-bit Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe output behavior of a digital design is the result of the logical operations performed on the input signals. In our design, the output values correspond to the care button presses. If a user presses more than one button, the logic squashes all button presses. Only a single 1 value at a time can pass through to the wires on the right of the figure.""
 }
]","{
 ""id"": 185
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What does the transition diagram look like?\n#### Option 1\n-------\nThe transition diagram looks like a figure with states marked with output values Z_1Z_0 and transition arcs labeled in terms of the two input buttons, G and H. The uninterrupted counting cycle is labeled with to indicate that it continues until the H button is pressed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe transition diagram has states marked with output values Z_1Z_0, transition arcs labeled in terms of the two input buttons, G and H, and an uninterrupted counting cycle that continues until the H button is pressed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe transition diagram looks like this:\n\n[INSERT DIAGRAM]\n\nThe blue annotation in the diagram indicates the arc that we must adjust.  But thirty or sixty seconds is a large  number of clock cycles, and our FSM must keep track of the time. Do we need to draw all of the states?  Instead of following the design process that we outlined earlier, let's think about how we can modify our existing design to incorporate the new functionality.  In order to keep track of time, we use a binary counter.  Let's say that we want our timeout to be T cycles.  When we enter the alarm state, we want to set the counter's value  to T-1, then let the counter count down until it reaches 0, at  which point a timeout occurs.  To load the initial value, our counter should have a parallel load  capability that sets the counter value when input LD=1.  When LD=0, the counter counts down.   The counter also has an output Z that indicates that the counter's  value is currently zero, which we can use to indicate a timeout on the alarm.  You should be able to build such a counter based on what you have learned earlier in the class.  Here, we will assume that we can just make use of it.  How many bits do we need in our counter?  The answer depends on T. If we add the counter to""
 }
]","{
 ""id"": 186
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the two control buttons?\n#### Option 1\n-------\nThe two control buttons are the ``halt'' button and the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe \""halt\"" button is H, and the \""go\"" button is G.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two control buttons: an L button to request a serving of lychee ice cream, and an M button to request a serving of mango ice cream.""
 }
]","{
 ""id"": 187
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the output behavior?\n#### Option 1\n-------\nThe output behavior is that the machine outputs a two-bit Gray code. With these choices, we can redraw the transition diagram. In this figure, the states are marked with output values Z_1Z_0 and transition arcs are labeled in terms of our two input buttons, G and H. The uninterrupted counting cycle is labeled with to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe output is a two-bit Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, the output behavior is undefined. This is because the specification leaves some decisions unspecified, so any of the possible answers is indeed acceptable. As a concrete example, if we design logic to control an ice cream dispenser, the dispenser has two flavors, lychee and mango, but also allows us to create a blend of the two flavors. For each of the two flavors, our logic must output two bits to control the amount of ice cream that comes out of the dispenser. The two-bit C_L[1:0] output of our logic must specify the number of half-servings of lychee ice cream as a binary number, and the two-bit C_M[1:0] output must specify the number of half-servings of mango ice cream. Thus, for either flavor, 00 indicates none of that flavor, 01 indicates one-half of a serving, and 10 indicates a full serving. Inputs to our logic will consist of three buttons: an L button to request a serving of lychee ice cream, a B button to request a blend\u2014half a serving of each flavor, and an M button to request a serving of mango ice cream. Each button produces a 1 when pressed and a 0 when not pressed. Let's start with the assumption that the user only presses one button at a time. In this case, we can treat input combinations in which more than one button is pressed as \""""
 }
]","{
 ""id"": 188
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does the uninterrupted counting cycle label mean?\n#### Option 1\n-------\nThe uninterrupted counting cycle label means that the cycle continues until the H button is pressed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe uninterrupted counting cycle label means that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe uninterrupted counting cycle label means that the counter will continue counting until the user presses the halt button.""
 }
]","{
 ""id"": 189
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the Gray code work?\n#### Option 1\n-------\nThe Gray code is a system for representing numbers in a way that minimizes the number of changes required when moving from one number to another. \n\nFor example, consider the numbers 0, 1, 2, and 3. In a regular binary system, these would be represented as 0000, 0001, 0010, and 0011. If we wanted to represent these same numbers using a Gray code, we would instead use the following: 0000, 0001, 0011,0010. \n\nAs you can see, the only difference between each number in the Gray code is a single bit. This makes it much easier to move from one number to another, as only a single bit needs to be changed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe Gray code is a two-bit code that provides a single bit of input. The code is named after its inventor, Frank Gray.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe Gray code is a system for encoding numbers so that two successive numbers differ in only one digit. This system is often used in digital electronics, because it ensures that only one wire changes state when the number represented by the code is incremented or decremented.\n\nThe most common Gray code, the binary Gray code, is used to represent numbers in binary form. In this system, each successive number differs from the previous number in only one bit. For example, the numbers 0, 1, 2, and 3 can be represented as follows:\n\n0000\n0001\n0011\n0010\n\nThe Gray code can also be used to represent numbers in other number systems, such as decimal or hexadecimal. In these cases, each successive number differs from the previous number in only one digit. For example, the numbers 0, 1, 2, 3, 4, 5, 6, and 7 can be represented in decimal Gray code as follows:\n\n0000\n0001\n0011\n0010\n0110\n0111\n0101\n0100\n\nSimilarly, the numbers 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F can be represented in hexadecimal Gray code as follows:\n\n0000\n0001\n0011\n0010\n0110\n0111\n0101\n0100\n1100\n1101\n1111\n1110""
 }
]","{
 ""id"": 190
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the significance of the two-bit output?\n#### Option 1\n-------\nThe significance of the two-bit output is that it encodes the states of the system. The output is in a Gray code, which is a code that ensures that only one bit changes at a time. This is important for ensuring that the system transitions smoothly between states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe two-bit output is a Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two-bit output is significant because it represents the result of the comparison between the two input numbers. The output is a 1 if the first number is greater than the second number, and a 0 if the first number is less than or equal to the second number.""
 }
]","{
 ""id"": 191
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What would happen if we only had one control button?\n#### Option 1\n-------\nIf we only had one control button, we would not be able to control the machine as effectively. For example, we would not be able to halt the machine or go back to a previous state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf we only had one control button, we would not be able to specify input and output behavior digitally.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIf we only had one control button, the ice cream dispenser would dispense one scoop of ice cream.""
 }
]","{
 ""id"": 192
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""[\""\\n-What should happen if a user presses the ``go'' button (HG=01)?\n#### Option 1\n-------\nFor the ``go'' button, we choose to ignore it while counting, and have the ``halt'' button override it. Thus, if HG=01 when the counter is in state { COUNT A}, the counter moves to state { COUNT B}. And, if HG=11, the counter moves to state { HALT A}.\n\nFor the ``halt'' button, we choose to have it override the ``go'' button. Thus, if HG=10 when the counter is in state { HALT A}, the counter moves back to state { HALT A}. And, if HG=11, the counter moves back to state { HALT A}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe go button is ignored while counting, and the halt button overrides the go button. If HG=01 when the counter is in state { COUNT A}, the counter moves to state { COUNT B}. And, if HG=11, the counter moves to state { HALT A}. For consistency, we decide that ``halt'' overrides ``go,'' but does nothing special if it alone is pressed while the counter is halted. Thus, input patterns HG=10 and HG=11 also take state { HALT A} back to itself.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first context is that when we press ``go'' (HG=01), the counter moves to the { COUNT B} state, and that the counter remains halted in state { HALT A} if no buttons are pressed (HG=00). What if the ``halt'' button is pressed (HG=10), or both buttons are pressed (HG=11)? For consistency, we decide that ``halt'' overrides ``go,'' but does nothing special if it alone is pressed while the counter is halted. Thus, input patterns HG=10 and HG=11 also take state { HALT A} back to itself. Here the arc could be labeled HG=00,10,11 or, equivalently, HG=00,1x or HG=x0,11.\n\nThe second context is that we have ordered the rows of the state table in Gray code order to simplify transcription of K-maps.\n\nThe answer to the question is that, in the first context, if the ``halt'' button is pressed (HG=10), or both buttons are pressed (HG=11), then state { HALT A} goes back to itself. In the second context, this is represented by the arc being labeled HG=00,10,11 or, equivalently, HG=00,1x or HG=x0,11.""
 }
]","{
 ""id"": 193
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What should happen if a user presses the ``go'' button (HG=01)?\n#### Option 1\n-------\nIf the user presses the ``go'' button while the counter is in state { COUNT A}, the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf HG=01 when the counter is in state { COUNT A}, the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, the user presses the ``go'' button (HG=01), and the counter moves to the { COUNT B} state. In the second context, the user presses the ``go'' button (HG=01), and the counter moves to the { COUNT B} state, and the counter remains halted in state { HALT A} if no buttons are pressed (HG=00).""
 }
]","{
 ""id"": 194
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Or if the user presses both buttons (HG=11)?\n#### Option 1\n-------\nIf the user presses both buttons (HG=11), the counter moves to state { HALT A}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe ``halt'' button overrides the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIf the user presses both buttons (HG=11), the counter remains halted in state { HALT A}.""
 }
]","{
 ""id"": 195
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What if the ``halt'' button is pressed (HG=10), or both buttons are pressed (HG=11)?\n#### Option 1\n-------\n[ \""The counter moves to the { COUNT B} state when a user presses the ``go'' button (HG=01) because the ``halt'' button overrides the ``go'' button. The counter remains halted in state { HALT A} if no buttons are pressed (HG=00) because the ``halt'' button overrides the ``go'' button. If the ``halt'' button is pressed (HG=10), or both buttons are pressed (HG=11), the counter moves back to state { HALT A}.\"", \""The counter moves to the { COUNT B} state when a user presses the ``go'' button (HG=01) because the ``halt'' button overrides the ``go'' button. The counter remains halted in state { HALT A} if no buttons are pressed (HG=00) because the ``halt'' button overrides the ``go'' button. If the ``halt'' button is pressed (HG=10), or both buttons are pressed (HG=11), the counter moves back to state { HALT A}.\""]""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe counter moves to the { COUNT B} state when a user presses the ``go'' button (HG=01) because the ``halt'' button overrides the ``go'' button. The counter remains halted in state { HALT A} if no buttons are pressed (HG=00) because the ``halt'' button overrides the ``go'' button. The ``halt'' button does nothing special if it alone is pressed while the counter is halted.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe counter moves to the { COUNT B} state when a user presses the ``go'' button (HG=01) because that is the transition specified in the design. The counter remains halted in state { HALT A} if no buttons are pressed (HG=00) because that is also the transition specified in the design. If the ``halt'' button is pressed (HG=10), or both buttons are pressed (HG=11), then the counter remains in the { HALT A} state because that is the transition specified in the design.""
 }
]","{
 ""id"": 196
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""[\""\\n1. ?\n#### Option 1\n-------\nThe state table form can make the missing parts of the specification even more obvious. \n\nFor our counter, the symmetry between counting states makes the problem \nsubstantially simpler.  Let's write out part of a list of states and\npart of a state table with one \ncounting state and one halt state, as shown to the right.\nFour values of the inputs HG \nare possible (recall that N bits allow 2^N possible patterns).\nWe list the columns in Gray code order, since we may want to\ntranscribe this table into K-maps later.\n\n{\n\n& \nfirst counting state& { COUNT A}& counting, output Z_1Z_0=00\n  first halted state&  { HALT A}& halted, output Z_1Z_0=00\n\n\n{c|cccc}\n&{HG}\n        state&            00&            01&          11&           10 \n{ COUNT A}& { COUNT B}&   unspecified& unspecified& { HALT A}\n { HALT A}&  { HALT A}& { COUNT B}& unspecified&  unspecified\n\n\n\nLet's start with the { COUNT A} state.  \n\nWe know that if neither button is pressed (HG=00), we want \nthe counter to move to the { COUNT""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe answer must summarize the topic in a few words. Context :  {Completing the Specification}\n\nNow we need to think about how the system should behave if something \noutside of our initial expectations occurs.  Having drawn out a partial\ntransition diagram can help with this process, since we can use the\ndiagram to systematically consider all possible input conditions from\nall possible states.  The state table form can make the missing\nparts of the specification even more obvious.\n\n\n\n\nFor our counter, the symmetry between counting states makes the problem \nsubstantially simpler.  Let's write out part of a list of states and\npart of a state table with one \ncounting state and one halt state, as shown to the right.\nFour values of the inputs HG \nare possible (recall that N bits allow 2^N possible patterns).\nWe list the columns in Gray code order, since we may want to\ntranscribe this table into K-maps later.\n\n\n{\n\n& \nfirst counting state& { COUNT A}& counting, output Z_1Z_0=00\n  first halted state&  { HALT A}& halted, output Z_1Z_0=00\n\n\n{c|cccc}\n&{HG}\n        state&            00&            01&          11&           10 \n{ COUNT A}& {""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWhat are the differences between the two contexts?\n\nThe two contexts are the academic context and the formal context. The academic context is the context in which you are expected to be able to explain your work to others in an academic setting, such as in a classroom or a research lab. The formal context is the context in which you are expected to be able to explain your work to others in a formal setting, such as in a court of law or in a business meeting.\n\nThe main difference between the two contexts is the level of formality. In the academic context, you are expected to be able to explain your work in a way that is clear and concise, but you are not expected to be overly formal. In the formal context, you are expected to be able to explain your work in a way that is both clear and concise, and you are also expected to be very formal.\n\nAnother difference between the two contexts is the audience. In the academic context, you are typically speaking to other academics, who will already have some knowledge of the topic you are discussing. In the formal context, you may be speaking to people who have no prior knowledge of the topic, and so you will need to be able to explain your work in a way that is easy to understand.""
 }
]","{
 ""id"": 197
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What should happen if a user presses the ``go'' button (HG=01)?\n#### Option 1\n-------\nIf the user presses the ``go'' button while the counter is in state { COUNT A}, the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, the user presses the ``go'' button (HG=01), and the counter moves to the { COUNT B} state. In the second context, the user presses the ``go'' button (HG=01), and the counter moves to the { COUNT B} state, and the counter remains halted in state { HALT A} if no buttons are pressed (HG=00).""
 }
]","{
 ""id"": 198
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Or if the user presses both buttons (HG=11)?\n#### Option 1\n-------\nIf the user presses both buttons (HG=11), the counter moves to state { HALT A}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWe choose to ignore the ``go'' button while counting, and to have the ``halt'' button override the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, if the user presses both buttons (HG=11), the counter will move to the COUNT B state. In the second context, if the user presses both buttons (HG=11), the counter will remain in the HALT A state.""
 }
]","{
 ""id"": 199
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What if the ``halt'' button is pressed (HG=10), or both buttons are pressed (HG=11)?\n#### Option 1\n-------\nIf the ``halt'' button is pressed (HG=10), the counter moves to state { HALT A}. If both buttons are pressed (HG=11), the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf the ``halt'' button is pressed (HG=10), the counter moves to state { HALT A}. If both buttons are pressed (HG=11), the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIf the \""halt\"" button is pressed (HG=10), the counter remains in the halted state. If both buttons are pressed (HG=11), the \""halt\"" button takes precedence and the counter remains in the halted state.""
 }
]","{
 ""id"": 200
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What should happen if a user presses the ``go'' button (HG=01)?\n#### Option 1\n-------\nIf the user presses the ``go'' button while the counter is in state { COUNT A}, the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf HG=01 when the counter is in state { COUNT A}, the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, the user presses the ``go'' button (HG=01), and the counter moves to the { COUNT B} state. In the second context, the user presses the ``go'' button (HG=01), and the counter moves to the { COUNT B} state, and the counter remains halted in state { HALT A} if no buttons are pressed (HG=00).""
 }
]","{
 ""id"": 201
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Or if the user presses both buttons (HG=11)?\n#### Option 1\n-------\nIf the user presses both buttons (HG=11), the counter moves to state { HALT A}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe ``halt'' button overrides the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIf the user presses both buttons (HG=11), the counter remains halted in state { HALT A}.""
 }
]","{
 ""id"": 202
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What if the ``halt'' button is pressed (HG=10), or both buttons are pressed (HG=11)?\n#### Option 1\n-------\n[\""The counter moves to the first counting state if the user presses the ``go'' button (HG=01). If the user presses the ``halt'' button (HG=10), the counter moves to the first halted state. If the user presses both buttons (HG=11), the counter moves to the first halted state.\"", \""The counter moves to the first counting state if the user presses the ``go'' button (HG=01). If the user presses the ``halt'' button (HG=10), the counter moves to the first halted state. If the user presses both buttons (HG=11), the counter moves to the first halted state.\""]""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe counter moves to the first counting state when the ``go'' button is pressed (HG=01). If HG=01 when the counter is in state { COUNT A}, the counter moves to state { COUNT B}. And, if HG=11, the counter moves to state { HALT A}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, if the user presses the ``go'' button (HG=01), the counter moves to the first counting state. If the user presses the ``halt'' button (HG=10), or both buttons are pressed (HG=11), the counter remains halted in state { HALT A}.\n\nIn the second context, if the user presses the ``go'' button (HG=01), the counter moves to the { COUNT B} state. If the user presses the ``halt'' button (HG=10), or both buttons are pressed (HG=11), the counter remains halted in state { HALT A}.""
 }
]","{
 ""id"": 203
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""[\""?\n#### Option 1\n-------\n\""\n\nIn order to complete the specification, we need to think about how the system should behave if something outside of our initial expectations occurs. Drawing out a partial transition diagram can help with this process, since we can use the diagram to systematically consider all possible input conditions from all possible states. The state table form can make the missing parts of the specification even more obvious.\n\nFor our counter, the symmetry between counting states makes the problem substantially simpler. We can write out part of a list of states and part of a state table with one counting state and one halt state, as shown to the right.\n\nFour values of the inputs HG are possible (recall that N bits allow 2^N possible patterns). We list the columns in Gray code order, since we may want to transcribe this table into K-maps later.\n\nState:         COUNT A          HALT A\n\nInput:         00                00\n\nOutput:        COUNT B           HALT A\n\nInput:         01                01\n\nOutput:        COUNT B           HALT A\n\nInput:         11                11\n\nOutput:        HALT A            HALT A\n\nInput:         10                10\n\nOutput:        HALT A            HALT A\n\nLet's start with the COUNT A state. We know that if neither button is pressed (HG=00), we want the counter to move to the COUNT B state""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design is not fully specified without deciding what should happen if a user presses the ``go'' button (HG=01) while the counter is in state { COUNT A}, or if the user presses both buttons (HG=11).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nContext - implementation of  a specification  implies decisions} about these details, so decisions should only be left  unspecified if any of the possible answers is indeed acceptable.  As a concrete example, let's design logic to control an ice cream  dispenser.  The dispenser has two flavors, lychee and mango, but also allows us to create a blend of the two flavors. For each of the two flavors, our logic must output two bits to control the amount of ice cream that comes out of the dispenser. The two-bit C_L[1:0] output of our logic must specify the number  of half-servings of lychee ice cream as a binary number, and the two-bit C_M[1:0] output must specify the number of  half-servings of mango ice cream.  Thus, for either flavor, 00 indicates none of that flavor, 01 indicates one-half of a serving, and  10 indicates a full serving.  Inputs to our logic will consist of three buttons: an L button to request a serving of lychee ice cream, a B button to request a blend---half a serving of each flavor, and an M button to request a serving of mango ice cream.  Each button produces a 1  when pressed and a 0 when not pressed.    Let's start with the assumption that the user only presses one button at a time.  In this case, we""
 }
]","{
 ""id"": 204
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What should happen if a user presses the ``go'' button (HG=01)?\n#### Option 1\n-------\nIf HG=01 when the counter is in state { COUNT A}, the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf HG=01 when the counter is in state { COUNT A}, the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, the user presses the ``go'' button (HG=01), and the counter moves to the { COUNT B} state. In the second context, the user presses the ``go'' button (HG=01), and the counter moves to the { COUNT B} state, and the counter remains halted in state { HALT A} if no buttons are pressed (HG=00).""
 }
]","{
 ""id"": 205
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What if the user presses the ``halt'' button (HG=10), or both buttons are pressed (HG=11)?\n#### Option 1\n-------\nFor consistency, we decide that ``halt'' overrides ``go,'' but does nothing special if it alone is pressed while the counter is halted.  Thus, input patterns HG=10 and HG=11 also take state { HALT A} back to itself.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n``halt'' overrides ``go,'' but does nothing special if it alone is pressed while the counter is halted.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two possible contexts for this question:\n\n1) The context of the design of a finite state machine (FSM)\n2) The context of the operation of a finite state machine (FSM)\n\n1) In the context of the design of a finite state machine, if the user presses the ``halt'' button (HG=10), or both buttons are pressed (HG=11), the FSM will remain in the halted state.\n\n2) In the context of the operation of a finite state machine, if the user presses the ``halt'' button (HG=10), the FSM will remain in the halted state. If both buttons are pressed (HG=11), the FSM will go to the counting state.""
 }
]","{
 ""id"": 206
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many possible patterns are there for the inputs HG?\n#### Option 1\n-------\nThere are four possible patterns for the inputs HG.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are four possible patterns for the inputs HG.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are eight possible patterns for the inputs HG. These are:\n\nHG=00\nHG=01\nHG=10\nHG=11\n\nHG=000\nHG=001\nHG=010\nHG=011""
 }
]","{
 ""id"": 207
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What should happen if a user presses the ``go'' button (HG=01)?\n#### Option 1\n-------\nIf the user presses the ``go'' button while the counter is in state { COUNT A}, the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf HG=01 when the counter is in state { COUNT A}, the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWhen the ``go'' button is pressed (HG=01), the counter moves to the { COUNT B} state, and the output changes to Z_1Z_0=01.""
 }
]","{
 ""id"": 208
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Or if the user presses both buttons (HG=11)?\n#### Option 1\n-------\nIf the user presses both buttons (HG=11), the counter moves to state { HALT A}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe ``halt'' button overrides the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIf the user presses both buttons (HG=11), the counter will remain in the same state.""
 }
]","{
 ""id"": 209
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What if the ``halt'' button is pressed (HG=10), or both buttons are pressed (HG=11)?\n#### Option 1\n-------\nIf the ``halt'' button is pressed (HG=10), the counter moves to state { HALT A}. If both buttons are pressed (HG=11), the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf the ``halt'' button is pressed (HG=10), the counter moves to state { HALT A}. If both buttons are pressed (HG=11), the counter moves to state { COUNT B}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIf the \""halt\"" button is pressed (HG=10), the counter will remain in the halted state. If both buttons are pressed (HG=11), the \""halt\"" button will take precedence and the counter will remain in the halted state.""
 }
]","{
 ""id"": 210
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to consider all possible input conditions from all possible states when completing the specification?\n#### Option 1\n-------\nIt is important to consider all possible input conditions from all possible states when completing the specification because any implementation of our system will imply answers, and thus we must be careful.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSo that any implementation of the system will have well-defined behavior, and to avoid confusion for the user.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWhen designing a sequential circuit, it is important to consider all possible input conditions from all possible states in order to ensure that the circuit will function correctly. This is because a sequential circuit's output depends not only on the current input, but also on the previous state of the circuit. If all possible input conditions and states are not considered, the circuit may produce incorrect results.\n\nFor example, consider a simple sequential circuit with two inputs (A and B) and two outputs (X and Y). The output of the circuit depends on both the current input and the previous state of the circuit. If the previous state was A=1 and B=0, then the output will be X=1 and Y=0. However, if the previous state was A=0 and B=1, then the output will be X=0 and Y=1. Thus, it is important to consider all possible input combinations and all possible previous states when designing the circuit.\n\nSimilarly, when designing a state machine, it is important to consider all possible input combinations and all possible states. This is because the output of the state machine depends on both the current input and the current state. If all possible input combinations and states are not considered, the state machine may produce incorrect results.\n\nFor example, consider a state machine with two inputs (A and B) and two outputs (X and Y). The output of the state machine depends on both the current input and the current state""
 }
]","{
 ""id"": 211
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can a transition diagram help with this process?\n#### Option 1\n-------\nA transition diagram can help with this process by allowing us to systematically consider all possible input conditions from all possible states. The state table form can make the missing parts of the specification even more obvious.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA transition diagram can help with this process by allowing us to systematically consider all possible input conditions from all possible states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA transition diagram can help with this process by providing a visual representation of the states and transitions of the FSM. This can be helpful in understanding the behavior of the FSM and in deriving the logic expressions for the next-state variables and output signals.""
 }
]","{
 ""id"": 212
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What should be done if a part of the design is left unspecified?\n#### Option 1\n-------\nIf a part of the design is left unspecified, then any implementation of the system will imply answers. Therefore, it is important to be careful when leaving parts of the design unspecified.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAny implementation of the system will imply answers, so be careful when leaving parts of the design unspecified.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIf a part of the design is left unspecified, it is important to decide whether any of the possible answers is indeed acceptable. If not, decisions should be made about these details. As a concrete example, let's design logic to control an ice cream dispenser. The dispenser has two flavors, lychee and mango, but also allows us to create a blend of the two flavors. For each of the two flavors, our logic must output two bits to control the amount of ice cream that comes out of the dispenser. The two-bit C_L[1:0] output of our logic must specify the number of half-servings of lychee ice cream as a binary number, and the two-bit C_M[1:0] output must specify the number of half-servings of mango ice cream. Thus, for either flavor, 00 indicates none of that flavor, 01 indicates one-half of a serving, and 10 indicates a full serving. Inputs to our logic will consist of three buttons: an L button to request a serving of lychee ice cream, a B button to request a blend---half a serving of each flavor, and an M button to request a serving of mango ice cream. Each button produces a 1 when pressed and a 0 when not pressed.\n\nLet's start with the assumption that the user only presses one button at a time. In this case, we can treat input combinations in which more""
 }
]","{
 ""id"": 213
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many states does an FSM need in order to have eight states?\n#### Option 1\n-------\nAn FSM needs at least three state bits to have eight states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAn FSM needs at least three state bits to have eight states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAn FSM needs at least eight states in order to have eight states. This is because each state corresponds to a unique combination of input values and output values. For example, if an FSM has two input values (A and B) and two output values (X and Y), then it would need at least four states in order to have eight states.""
 }
]","{
 ""id"": 214
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does it mean when we say that \""abstraction in selecting a representation \\ntends to produce better designs?\n#### Option 1\n-------\nWhen we say that abstraction in selecting a representation tends to produce better designs, we mean that it is often easier to design and debug a design when we start with a representation that makes sense to a human, even if it requires more bits than are strictly necessary. The resulting implementation will be easier to design and to debug than an implementation in which only the global behavior has any meaning.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nChoosing a state representation that is easy for a human to understand produces designs that are easier to design and debug.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are many ways to represent a system, and the choice of representation can have a significant impact on the quality of the resulting design. In general, abstraction in selecting a representation tends to produce better designs. For example, consider a logic slice that compares two bits at a time. In general, we can optimize logic for any number of bits and then apply multiple copies of the resulting logic in space (a generalization of the bit-sliced approach), or in time (a generalization of the serialization approach), or in a combination of the two. Sometimes these tradeoffs may happen at a higher level. As mentioned in Notes Set 2.3, computer software uses the carry out of an adder to perform addition of larger groups of bits (over multiple clock cycles) than is supported by the processor's adder hardware. In computer system design, engineers often design hardware elements that are general enough to support this kind of extension in software.\n\nAs a concrete example of the possible tradeoffs, consider a serial comparator design based on the {2-bit} slice variant. This approach leads to a serial design with 24 gates and 10 inverters, which is not much larger than our earlier serial design. In terms of gate delays, however, the new design is identical, meaning that we finish a comparison in half the time. More realistic area and timing metrics show slightly more difference between the two designs. These differences can dominate the results if we blindly scale the idea""
 }
]","{
 ""id"": 215
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between the state listing and the state table?\n#### Option 1\n-------\nThe state listing is a list of all of the possible states that the FSM can be in, along with a description of what the output will be in each state. The state table is a more concise way of representing the same information. It is a table with the states listed in the left column and the outputs listed in the right column.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe state listing includes the output for each state, while the state table does not.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe state listing is a list of all the possible states that the FSM can be in, along with a description of what each state represents. The state table is a table that shows the next state of the FSM given the current state and the inputs.""
 }
]","{
 ""id"": 216
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many state bits are necessary to keep track of the current state?\n#### Option 1\n-------\nAt least three state bits are necessary to keep track of the current state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThree state bits are necessary.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n""
 }
]","{
 ""id"": 217
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the effect of choosing a representation for an FSM's states on design complexity?\n#### Option 1\n-------\nThe choice of representation for an FSM's states can dramatically affect the design complexity. For a design as simple as a counter, you could just let a computer implement all possible representations (there aren't more than 840, if we consider simple symmetries) and select one according to whatever metrics are interesting.\n\nFor bigger designs, however, the number of possibilities quickly becomes impossible to explore completely.\n\nFortunately, use of abstraction in selecting a representation also tends to produce better designs for a wide variety of metrics (such as design complexity, area, power consumption, and performance).\n\nThe right strategy is thus often to start by selecting a representation that makes sense to a human, even if it requires more bits than are strictly necessary. The resulting implementation will be easier to design and to debug than an implementation in which only the global behavior has any meaning.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe choice of representation for an FSM's states can dramatically affect the design complexity.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe effect of choosing a representation for an FSM's states on design complexity can be significant. For small designs, this representation can be selected by a computer in such a way as to optimize the implementation. However, for large designs, such as the LC-3 instruction set architecture, humans do most of the work by hand. In the later examples, we show how even a small design can leverage meaningful information from the design when selecting the representation, leading to an implementation that is simpler and is easier to build correctly.""
 }
]","{
 ""id"": 218
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the strategy for selecting a representation that makes sense to a human?\n#### Option 1\n-------\nThe right strategy is to start by selecting a representation that makes sense to a human, even if it requires more bits than are strictly necessary. The resulting implementation will be easier to design and to debug than an implementation in which only the global behavior has any meaning.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe right strategy is to start by selecting a representation that makes sense to a human, even if it requires more bits than are strictly necessary.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe strategy for selecting a representation that makes sense to a human is to use abstraction to simplify the implementation. By Step {step-logic}, our design is a complete specification in terms of bits, and we need merely derive logic expressions for the next-state variables and the output signals.""
 }
]","{
 ""id"": 219
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to choose a state representation that makes sense to a human?\n#### Option 1\n-------\nThe right strategy is to start by selecting a representation that makes sense to a human, even if it requires more bits than are strictly necessary. The resulting implementation will be easier to design and to debug than an implementation in which only the global behavior has any meaning.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe resulting implementation will be easier to design and to debug than an implementation in which only the global behavior has any meaning.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are several reasons why it is important to choose a state representation that makes sense to a human. First, humans are more likely to be able to understand and debug a design if it is in a form that they can easily comprehend. Second, a design that is easy for humans to understand is also likely to be easier to implement correctly. Finally, a design that is easy for humans to understand is also likely to be simpler and require less logic to implement.""
 }
]","{
 ""id"": 220
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can abstraction help when selecting a state representation?\n#### Option 1\n-------\nAbstraction can help when selecting a state representation by allowing the designer to focus on the global behavior of the system, rather than on the details of the implementation. This can lead to a simpler and more efficient design.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nChoosing a representation that makes sense to a human, even if it requires more bits than are strictly necessary, will result in an implementation that is easier to design and to debug.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAbstraction can help when selecting a state representation by allowing the designer to focus on the functionality of the system rather than the details of the implementation. For example, a designer may want to create a system that counts from 0 to 3 in binary. One way to represent the states of this system is to use a two-bit Gray code. However, if the designer is only interested in the functionality of the system, they may choose to use a simpler state representation, such as a two-bit binary code. This will allow the designer to focus on the functionality of the system and not worry about the details of the implementation.""
 }
]","{
 ""id"": 221
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it helpful to order the rows of a state table in Gray code order when transcribing to K-maps?\n#### Option 1\n-------\nWhen the rows of a state table are in Gray code order, it means that only one bit changes between adjacent states. This makes it easier to transcribe to K-maps because we only need to consider one bit at a time.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIt is helpful to order the rows of a state table in Gray code order when transcribing to K-maps because it simplifies transcription of K-maps.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main reason for ordering the rows of a state table in Gray code order when transcribing to K-maps is to minimize the number of logic gates required in the final implementation. This is because, in a Gray code ordering, only one bit changes value from one row to the next. This means that, when translating the state table into K-maps, only one variable will change value per row. This can be a significant simplification when implementing the design in hardware.""
 }
]","{
 ""id"": 222
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""['\\nQ] What factors should be considered when choosing a state representation for an FSM?\n#### Option 1\n-------\nThere are a few key factors to consider when choosing a state representation for an FSM. The first is the number of states the FSM has. The more states there are, the more complex the design will be. The second factor is the use of abstraction. Abstraction can simplify the design and make it easier to understand. The third factor is the human factor. It is often best to start by selecting a state representation that makes sense to a human, even if it requires more bits. This will make the design easier to understand and debug.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe right strategy is to start by selecting a representation that makes sense to a human, which will result in an easier design.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are several factors to consider when choosing a state representation for an FSM. The number of states, the I/O behavior, and the desired behavior of the FSM all play a role in determining the best representation. Additionally, the choice of representation can affect the complexity of the design. It is often best to start by selecting a state representation that makes sense to a human, even if it requires more bits. This can help simplify the design and make it easier to build correctly.""
 }
]","{
 ""id"": 223
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""[\""\\n-What does it mean when states can be 'labeled with internal state and outputs'?\n#### Option 1\n-------\nThe purpose of abstraction when choosing a state representation is to make it easier to design and debug the implementation. It is often better to start with a representation that makes sense to a human, even if it requires more bits, because the resulting implementation will be easier to design and to debug than an implementation in which only the global behavior has any meaning. The benefits of using Gray code order when transcription K-maps is that it simplifies transcription of K-maps.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIt is often better to start with a representation that makes sense to a human, even if it requires more bits, because the resulting implementation will be easier to design and to debug.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAbstraction is a powerful tool that can be used to simplify the design process. When choosing a state representation, it is often better to start with a representation that makes sense to a human, even if it requires more bits. This can help to reduce the complexity of the design.""
 }
]","{
 ""id"": 224
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Rather than implementing the design as two-level logic, what does it mean to take advantage of our design's symmetry?\n#### Option 1\n-------\nTaking advantage of our design's symmetry means that we can further simplify the logic by reducing the number of gates required. This comes at the expense of longer, slower paths.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIt means to further simplify the logic (we reduce gate count at the expense of longer, slower paths).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA design's symmetry can be exploited in two ways: by using it to simplify the design, or by using it to improve the design's performance.\n\nWhen using symmetry to simplify a design, designers exploit the fact that symmetrical designs often have simpler implementations than their non-symmetrical counterparts. For example, a symmetrical design may require fewer gates or less wiring than a non-symmetrical design. This can lead to a simpler and more efficient design.\n\nWhen using symmetry to improve performance, designers exploit the fact that symmetrical designs often have better performance characteristics than their non-symmetrical counterparts. For example, a symmetrical design may be faster or use less power than a non-symmetrical design. This can lead to a more efficient design.""
 }
]","{
 ""id"": 225
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the variable HOLD?\n#### Option 1\n-------\nHOLD is a variable that is used to determine whether or not the counter should advance in the current cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe variable HOLD is a summary of when the counter should retain its current value in the next cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe variable HOLD is a Boolean variable that is true when the counter should hold its current value, and false when the counter should count. In the counting states, when S_2=0, the counter stops (moves into a halted state without changing value) when H is true. In the halted states, when S_2=1, the counter stops (stays in a halted state) when H+ is true.""
 }
]","{
 ""id"": 226
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of separating out the logic for deciding whether to advance the counter from the logic for advancing the counter itself?\n#### Option 1\n-------\nThe purpose of separating out the logic for deciding whether to advance the counter from the logic for advancing the counter itself is to enable a more simplified design. This separation also allows for the design to be more easily verified for correctness.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nBy using semantic meaning in our choice of representation, we are able to separate out the logic for deciding whether to advance the counter fairly cleanly from the logic for advancing the counter itself.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of separating out the logic for deciding whether to advance the counter from the logic for advancing the counter itself is to enable the design to be more easily implemented using two-level logic. This separation also has the advantage of simplifying the logic, as only the HOLD bit is used to determine whether or not the counter should advance in the current cycle.""
 }
]","{
 ""id"": 227
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the value of HOLD?\n#### Option 1\n-------\nHOLD is a variable that determines whether or not the counter should advance in the current cycle. If HOLD=1, the counter retains its state. If HOLD=0, the counter counts.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nHOLD is the value that determines whether the counter should advance in the current cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe value of HOLD is determined by the value of S_2 and the state of the machine. If S_2 is 0, then HOLD is 1 if the machine is in a halted state. If S_2 is 1, then HOLD is 1 if the machine is in a counting state.""
 }
]","{
 ""id"": 228
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" When is the value of HOLD 1?\n#### Option 1\n-------\nThe value of HOLD is 1 when the ``halt'' button is pressed or when the counter is already halted and the ``go'' button is not pressed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nHOLD is 1 when S_2 is 1 or when H is 1.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the first context, the value of HOLD is 1 when the counter is halted (S_2=1) or when the counter is already halted and the \""go\"" button is not pressed (H+S_2=1).\n\nIn the second context, the value of HOLD is 1 when the counter is halted (S_2=1) or when the counter is already halted and the \""go\"" button is not pressed (H+S_2=1).""
 }
]","{
 ""id"": 229
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" When is the value of HOLD 0?\n#### Option 1\n-------\nHOLD is 0 when S_2 is 0 and H is 1, or when S_2 is 1 and H+ is 1.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nHOLD is 0 when the ``go'' button is pressed while the counter is in a halted state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe value of HOLD is 0 when the counter is counting and H is true, or when the counter is halted and H+ is true.""
 }
]","{
 ""id"": 230
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is abstraction a powerful tool?\n#### Option 1\n-------\nAbstraction is a powerful tool because it allows designers to separate out the logic for deciding whether or not to advance the counter fairly cleanly from the logic for advancing the counter itself. This makes the design process much simpler and more efficient.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAbstraction is a powerful tool because it allows for the separate out the logic for deciding whether to advance the counter fairly cleanly from the logic for advancing the counter itself.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n\\n\n\nAbstraction is a powerful tool because it allows us to design complex systems from simpler components.  For example, an electronic circuit can be designed by starting with a set of basic logic gates and combining them into more complex circuits.  Similarly, a computer program can be written by combining simpler subroutines into more complex routines.  In both cases, the designer can focus on the functionality of the system, without worrying about the details of the implementation.  This makes the design process more efficient and can lead to better results.""
 }
]","{
 ""id"": 231
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can you use abstraction to simplify a design?\n#### Option 1\n-------\nAbstraction can be used to simplify a design by separating out the logic for deciding whether or not to advance the counter from the logic for advancing the counter itself. This enables the designer to focus on the functionality of the design, rather than on the details of the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nBy using semantic meaning in our choice of representation, we can separate out the logic for deciding whether to advance the counter fairly cleanly from the logic for advancing the counter itself.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAbstraction can be used to simplify a design by breaking it down into smaller, more manageable parts. For example, in the context of a logic slice design, we can optimize the logic for a specific number of bits and then apply multiple copies of the resulting logic in space (a generalization of the bit-sliced approach), or in time (a generalization of the serialization approach), or in a combination of the two. In the context of a finite state machine, we can use abstraction to identify the states needed for the design and the outputs for each state. This allows us to simplify the design by focusing on one part at a time.""
 }
]","{
 ""id"": 232
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the benefits of using abstraction in design?\n#### Option 1\n-------\nThere are several benefits to using abstraction in design. First, it can help to simplify the logic by separating out the decision of whether or not to advance the counter from the logic for advancing the counter itself. This can make the design easier to understand and verify. Second, it can help to reduce the gate count, which can improve the speed and performance of the design. Finally, it can help to make the design more modular and easier to change or extend in the future.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAbstraction enables designers to separate out the logic for deciding whether to advance the counter fairly cleanly from the logic for advancing the counter itself, simplifying the design and reducing the gate count.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are several benefits of using abstraction in design. Firstly, it allows for the creation of more general and reusable designs. For example, by designing a bit-sliced adder circuit, we can create adders of any size, rather than having to design a separate circuit for each specific size. Secondly, abstraction can simplify the design process by breaking down a complex task into smaller, more manageable parts. This can make the design process more efficient and less error-prone. Finally, abstraction can aid communication between designers, as it can provide a common language and understanding of the design process.""
 }
]","{
 ""id"": 233
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""['\\n\\n1. ?\n#### Option 1\n-------\n1. Rather than implementing the design as two-level logic, let's try to take advantage of our design's symmetry to further simplify the logic (we reduce gate count at the expense of longer, slower paths).\n\nLooking back to the last transition diagram, in which the arcs were labeled with logical expressions, let's calculate an expression for when the counter should retain its current value in the next cycle. We call this variable HOLD. In the counting states, when S_2=0, the counter stops (moves into a halted state without changing value) when H is true. In the halted states, when S_2=1, the counter stops (stays in a halted state) when H+ is true. We can thus write\n\nHOLD = S_2  H + S_2 H + S_2 \nHOLD = H + S_2 \n\nIn other words, the counter should hold its current value (stop counting) if we press the ``halt'' button or if the counter was already halted and we didn't press the ``go'' button. As desired, the current value of the counter (S_1S_0) has no impact on this decision. You may have noticed that the expression we derived for HOLD also matches S_2^+, the next-state value of S_2 in the K-map on the previous page.\n\nNow let's re-write our""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe HOLD variable is used to determine whether or not the counter should advance in the current cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n\\n\\n2. \n\nContext - tradeoffs in the sparsity of code words with error  detection and correction capabilities.']      {   }   blank 3rd page     {Example: Bit-Sliced Addition}  In this set of notes, we illustrate basic logic design using integer addition as an example.  By recognizing and mimicking the structured  approach used by humans to perform addition, we introduce an important  abstraction for logic design.  We follow this approach to design an adder known as a ripple-carry adder, then discuss some of the  implications of the approach and highlight how the same approach can  be used in software.  In the next set of notes, we use the same technique to design a comparator for two integers.  {One Bit at a Time}  Many of the operations that we want to perform on groups of bits can  be broken down into repeated operations on individual bits.  When we add two binary numbers, for example, we first add the least significant bits, then move to the second least significant, and so on. As we go, we may need to carry from lower bits into higher bits.  When we compare two (unsigned) binary numbers with the same number of bits, we usually start with the most significant bits and move downward in significance until we find a difference or reach the end of the two  numbers.  In the latter case, the two numbers are equal.""
 }
]","{
 ""id"": 234
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between a two-level logic and a three-level logic?\n#### Option 1\n-------\nA two-level logic is a logic that only has two possible states, 0 and 1. A three-level logic is a logic that has three possible states, 0, 1, and 2.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA two-level logic has only two possible states, while a three-level logic has three possible states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA two-level logic is a logic function that can be expressed using only two levels of logic gates. A three-level logic is a logic function that can be expressed using three levels of logic gates.\n\nThe main difference between a two-level logic and a three-level logic is that a three-level logic can represent a wider range of logic functions than a two-level logic. This is because a three-level logic can use AND, OR, and NOT gates, while a two-level logic can only use AND and OR gates.\n\nFor example, consider the function f(x,y,z) = x'y + xy'z. This function can be expressed using a three-level logic, but not a two-level logic.""
 }
]","{
 ""id"": 235
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does abstraction help simplify the design process?\n#### Option 1\n-------\nAbstraction is a powerful tool that can help simplify the design process. By abstracting away certain details, we can focus on the overall structure of the design and on the functionality that we want to achieve. In the example above, abstraction allowed us to separate out the logic for deciding whether or not to advance the counter from the logic for actually advancing the counter. This made the design simpler and easier to understand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAbstraction helps simplify the design process by breaking a design down into smaller, more manageable parts.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAbstraction is a powerful tool that can help simplify the design process by allowing designers to focus on the essential features of a system while ignoring irrelevant details. By abstracting away unnecessary details, designers can more easily see the big picture and identify potential problems or areas for improvement. In addition, abstraction can help designers reuse existing design solutions to solve new problems, which can save time and effort.""
 }
]","{
 ""id"": 236
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the advantage of using a Gray code counter over a traditional binary counter?\n#### Option 1\n-------\nThere are a few advantages of using a Gray code counter over a traditional binary counter. One advantage is that a Gray code counter can be more easily implemented in hardware. This is because a Gray code counter only requires two flip-flops, while a traditional binary counter requires four flip-flops. This means that a Gray code counter is more space-efficient. Another advantage of using a Gray code counter is that it is more resistant to errors. This is because a Gray code counter only changes one bit at a time, while a traditional binary counter can change multiple bits at a time. This means that there is less of a chance for an error to occur in a Gray code counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nGray code counters have the advantage of only changing one bit at a time between states, which prevents errors when reading the value of the counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two main advantages of using a Gray code counter over a traditional binary counter. First, a Gray code counter can be constructed with fewer components than a traditional binary counter. This is because a Gray code counter only requires a single flip-flop for each bit, whereas a traditional binary counter requires two flip-flops for each bit. This can lead to a significant reduction in cost and complexity for Gray code counters. Second, Gray code counters are more resistant to errors than traditional binary counters. This is because a Gray code counter will only change one bit at a time, whereas a traditional binary counter will change two bits at a time. This makes it less likely that an error will propagate through the system.""
 }
]","{
 ""id"": 237
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the value of HOLD?\n#### Option 1\n-------\nHOLD is a variable that determines whether or not the counter should advance in the current cycle. If HOLD=1, the counter retains its state. If HOLD=0, the counter counts.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nHOLD=H+S_2""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe value of HOLD is determined by the value of S_2 and the state of the machine. If S_2 is 0, then the machine is in a counting state and HOLD is 1. If S_2 is 1, then the machine is in a halted state and HOLD is 0.""
 }
]","{
 ""id"": 238
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" When is the counter halted?\n#### Option 1\n-------\nThe counter is halted when S_2=0 and H is true, or when S_2=1 and H+ is true.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe counter is halted when S_2=0 and H is true, or when S_2=1 and H+ is true.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe counter is halted when the user presses the ``halt'' button, and it resumes counting when the user presses the ``go'' button.""
 }
]","{
 ""id"": 239
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the next state of the counter when HOLD=0?\n#### Option 1\n-------\nThe next state of the counter when HOLD=0 is S_2^+=0, S_1^+=S_0, and S_0^+={{S_1}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe next state of the counter is S_2^+S_1^+S_0^+=0S_0{{S_1}}, which is shorthand for S_2^+=0, S_1^+=S_0, and S_0^+={{S_1}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the high-level design, the counter will advance to the next state when HOLD=0. In the low-level design, the expression for the next state of the counter is S_2^+ = H + S_2, so the counter will advance to the next state when HOLD=0 and H=1.""
 }
]","{
 ""id"": 240
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the significance of the HOLD variable?\n#### Option 1\n-------\nThe HOLD variable is used to determine whether or not the counter should advance in the current cycle. If HOLD=1, the counter will retain its state, and if HOLD=0, the counter will count.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe HOLD variable is used to determine whether or not the counter should advance in the current cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n""
 }
]","{
 ""id"": 241
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How does the value of HOLD determine whether or not the counter advances?\n#### Option 1\n-------\nThe value of HOLD determines whether or not the counter advances by controlling the muxes between the next state logic and the flip-flops. If HOLD is 1, the counter advances. If HOLD is 0, the counter does not advance.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWhen HOLD=1, the counter retains its state, and when HOLD=0, it counts.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe value of HOLD determines whether or not the counter advances based on the following two contexts:\n\n1) In the counting states, when S_2=0, the counter stops (moves into a halted state without changing value) when H is true. In the halted states, when S_2=1, the counter stops (stays in a halted state) when H+ is true.\n\n2) The counter should hold its current value (stop counting) if we press the ``halt'' button or if the counter was already halted and we didn't press the ``go'' button.""
 }
]","{
 ""id"": 242
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""Why is abstraction a powerful tool?\n#### Option 1\n-------\nAbstraction is a powerful tool because it allows us to separate out the logic for deciding whether or not to advance the counter fairly cleanly from the logic for advancing the counter itself. This separation of concerns makes the design much simpler and easier to understand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAbstraction is a powerful tool because it allows us to separate out the logic for deciding whether or not to advance the counter fairly cleanly from the logic for advancing the counter itself.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAbstraction is a powerful tool because it allows us to design logic that is more efficient and easier to use than logic that is designed by hand. For example, consider the design of an adder. By using abstraction, we can design an adder that is more efficient than a human engineer could design by hand. In addition, abstraction allows us to reuse specific pieces of hardware, which can lead to more efficient designs. Finally, many tasks today are executed in software, which is designed to leverage the fairly general logic available via an instruction set architecture. By using abstraction, we can design software that is more efficient and easier to use than software that is designed by hand.""
 }
]","{
 ""id"": 243
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""['\\n\\n1. ?\n#### Option 1\n-------\nThe HOLD variable is used to determine whether or not the counter should advance in the current cycle. If HOLD=1, the counter retains its state, and if HOLD=0, it counts.\n\nThe next-state logic for S_1^+ and S_0^+ when HOLD=1 reduces to S_1^+=S_1 and S_0^+=S_0; in other words, the counter stops counting and simply stays in its current state. When HOLD=0, these equations become S_1^+=S_0 and S_0^+={{S_1}}, which produces the repeating sequence for S_1S_0 of 00, 01, 11, 10, as desired.\n\nIn the counting states, S_2=0, and the HOLD value simplifies to HOLD=H. Until we push the ``halt'' button, S_2 remains 0, and the counter continues to count in the correct sequence. When H=1, HOLD=1, and the counter stops at its current value (S_2^+S_1^+S_0^+=1S_1S_0, which is shorthand for S_2^+=1, S_1^+=S_1, and S_0^+=S_0).\n\nIn any of the halted states, S_2=1, and we can""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe HOLD variable is used to determine whether or not the counter should advance in the current cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n\\n\\nContext - tradeoffs in the sparsity of code words with error detection and correction capabilities.']      {   }   blank 3rd page     {Example: Bit-Sliced Addition}  In this set of notes, we illustrate basic logic design using integer addition as an example.  By recognizing and mimicking the structured  approach used by humans to perform addition, we introduce an important  abstraction for logic design.  We follow this approach to design an adder known as a ripple-carry adder, then discuss some of the  implications of the approach and highlight how the same approach can  be used in software.  In the next set of notes, we use the same technique to design a comparator for two integers.  {One Bit at a Time}  Many of the operations that we want to perform on groups of bits can  be broken down into repeated operations on individual bits.  When we add two binary numbers, for example, we first add the least significant bits, then move to the second least significant, and so on. As we go, we may need to carry from lower bits into higher bits.  When we compare two (unsigned) binary numbers with the same number of bits, we usually start with the most significant bits and move downward in significance until we find a difference or reach the end of the two  numbers.  In the latter case, the two numbers are equal.  When we build combinational logic to""
 }
]","{
 ""id"": 244
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of the HOLD variable?\n#### Option 1\n-------\nThe HOLD variable is used to determine whether or not the counter should advance in the current cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe HOLD variable is used to determine whether or not the counter should advance in the current cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe HOLD variable is used to determine whether or not the counter should advance in the current cycle.""
 }
]","{
 ""id"": 245
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the value of HOLD determine whether or not the counter should advance?\n#### Option 1\n-------\nThe value of HOLD determines whether or not the counter should advance by controlling the muxes between the next state logic and the flip-flops. If HOLD is 1, the counter will retain its state. If HOLD is 0, the counter will advance.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWhen HOLD=1, the counter retains its state, and when HOLD=0, it counts.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe value of HOLD determines whether or not the counter should advance by determining whether the current state is a counting state or a halted state. If the current state is a counting state, then the counter should advance when HOLD is true. If the current state is a halted state, then the counter should advance when HOLD is false.""
 }
]","{
 ""id"": 246
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between the counting states and halted states?\n#### Option 1\n-------\nThe counting states are when S_2=0 and the halted states are when S_2=1. In the counting states, when S_2=0, the counter stops (moves into a halted state without changing value) when H is true. In the halted states, when S_2=1, the counter stops (stays in a halted state) when H+ is true.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIn the counting states, when S_2=0, the counter stops (moves into a halted state without changing value) when H is true. In the halted states, when S_2=1, the counter stops (stays in a halted state) when H+ is true.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe difference between the counting states and halted states is that in the counting states, the output is a two-bit Gray code, while in the halted states, the output is a single bit. The counting states are also symmetrical, while the halted states are not.""
 }
]","{
 ""id"": 247
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the value of HOLD?\n#### Option 1\n-------\nHOLD is a variable that determines whether or not the counter should advance in the current cycle. If HOLD=1, the counter retains its state. If HOLD=0, the counter counts.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nHOLD=H+S_2""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n""
 }
]","{
 ""id"": 248
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" When is the value of S_2^+ equal to 1?\n#### Option 1\n-------\nS_2^+ is equal to 1 when HOLD is equal to 1.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_2^+ is equal to 1 when HOLD is equal to 1.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe value of S_2^+ is equal to 1 when the counter is halted or when the counter was already halted and the \""go\"" button was not pressed.""
 }
]","{
 ""id"": 249
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the next state of S_1S_0 when HOLD=0?\n#### Option 1\n-------\nThe next state of S_1S_0 when HOLD=0 is S_0{{S_1}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_1^+=S_0 and S_0^+={{S_1}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe next state of S_1S_0 when HOLD=0 is that the counter will advance by one. This can be seen in the K-map for S_1^+S_0^+ in the low-level design, where the expression for when HOLD=0 matches that of a 2-to-1 mux.""
 }
]","{
 ""id"": 250
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the HOLD bit simplify the logic for determining whether or not the counter should advance in the current cycle?\n#### Option 1\n-------\nWhen HOLD=1, the next-state logic for S_1^+ and S_0^+ \nreduces to S_1^+=S_1 and S_0^+=S_0;\nin other words, the counter stops counting and simply stays in its \ncurrent state.  When HOLD=0, these equations become\nS_1^+=S_0 and S_0^+={{S_1}}, which produces the repeating\nsequence for S_1S_0 of 00, 01, 11, 10.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe HOLD bit is used to determine whether or not the counter should advance in the current cycle. When HOLD=1, the counter retains its state, and when HOLD=0, it counts.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n""
 }
]","{
 ""id"": 251
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between a good and bad representation?\n#### Option 1\n-------\nA good representation is one that is easy to work with and understand. A bad representation is one that is difficult to work with and understand. In the context of state machines, a good representation is one that makes it easy to verify the correctness of the machine's behavior. A bad representation is one that makes it difficult to verify the correctness of the machine's behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA good representation is one in which states can be easily distinguished from one another. A bad representation is one in which states are difficult to distinguish from one another.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA good representation is one that is easy to understand and work with. A bad representation is one that is difficult to understand or work with. For example, a good representation of a Boolean function is one that is easy to understand and work with, while a bad representation is one that is difficult to understand or work with.""
 }
]","{
 ""id"": 252
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to have a good representation?\n#### Option 1\n-------\nIt is important to have a good representation because it can impact the behavior of the system. A bad representation can lead to incorrect results.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf we choose a bad representation, it is difficult to verify the implementation's behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two primary reasons why it is important to have a good representation. The first is that a good representation can help reduce the number of errors that occur in a digital system. The second is that a good representation can help improve the efficiency of a digital system.\n\nAs we have seen with parity, one strategy that we can use to provide such error tolerance is the use of representations in which only some of the patterns actually represent values. Let's call such patterns code words. In other words, the code words in a representation are those patterns that correspond to real values of information. Other patterns in the representation have no meaning. As a tool to help us understand error tolerance, let's define a measure of the distance between code words in a representation. Given two code words X and Y, we can calculate the number N_ of bits that must change to transform X into Y. Such a calculation merely requires that we compare the patterns bit by bit and count the number of places in which they differ. Notice that this relationship is symmetric: the same number of changes are required to transform Y into X, so N_=N_. We refer to this number N_ as the Hamming distance between code word X and code word Y.\n\nThe Hamming distance between two code words tells us how many bit errors are necessary in order for a digital system to mistake one code word for the other. Given a representation, we can calculate the minimum Hamming distance between any pair""
 }
]","{
 ""id"": 253
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the consequences of having a bad representation?\n#### Option 1\n-------\nThe consequences of having a bad representation can be seen in the table and diagram above. If we choose a bad representation, the implementation's behavior will be incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf we choose a bad representation, it can be difficult to verify the implementation's behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe consequences of having a bad representation can be significant. A bad representation can lead to an incorrect understanding of the function being represented, which can in turn lead to errors in the implementation of that function. In the context of Boolean functions, a bad representation can lead to an incorrect understanding of the logical structure of the function, which can in turn lead to errors in the implementation of the function. In the context of multi-metric optimization, a bad representation can lead to an incorrect understanding of the tradeoffs between the various metrics, which can in turn lead to sub-optimal designs.""
 }
]","{
 ""id"": 254
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the impact of a poorly chosen state representation?\n#### Option 1\n-------\nA poorly chosen state representation can lead to incorrect implementation of an FSM. In the table and diagram above, the states are not represented correctly, which would lead to the incorrect implementation of the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf we choose a bad representation, it is difficult to verify the correctness of the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA poorly chosen state representation can have a number of impacts. In the first context, a poorly chosen state representation can result in a loss of information. For example, if a state is represented by a 3-bit unsigned integer, and an error occurs that changes one of the bits, the resulting value may no longer be a valid state. In the second context, a poorly chosen state representation can result in errors that are not detected. For example, if a state is represented by a 3-bit unsigned integer, and an error occurs that changes one of the bits, the resulting value may still be a valid state, but the parity of the value will be incorrect.""
 }
]","{
 ""id"": 255
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can we verify that an implementation with a poor state representation is correct?\n#### Option 1\n-------\nWe can verify that an implementation with a poor state representation is correct by testing it against a known good implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nVerifying the implementation's behavior is correct can be difficult if a poor state representation is chosen.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nOne way to verify that an implementation with a poor state representation is correct is to test the implementation against a known correct implementation. This can be done by running the same inputs through both implementations and comparing the outputs. If the outputs match, then the implementation with the poor state representation is likely correct. Another way to verify the correctness of an implementation with a poor state representation is to examine the logic expressions for the next-state variables and the output signals. If these expressions are correct, then the implementation is likely correct.""
 }
]","{
 ""id"": 256
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the consequences of a bad state mapping?\n#### Option 1\n-------\nIf we choose a bad representation, the implementation of the FSM will be incorrect. This is because the states will not be correctly mapped to the internal state representation. As a result, the FSM will not function properly.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA bad state representation can lead to a incorrect implementation of an FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA bad state mapping can lead to an incorrect or inefficient implementation of an FSM. A good state representation is important because it can simplify the implementation of an FSM and make it easier to build correctly.""
 }
]","{
 ""id"": 257
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of the table?\n#### Option 1\n-------\nThe table is meant to show a poorly chosen mapping from states to internal state representation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe table is a mapping from states to internal state representation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of the table is to map the current state and input combination into the next state of the FSM.""
 }
]","{
 ""id"": 258
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens if we choose a bad representation?\n#### Option 1\n-------\nIf we choose a bad representation, the implementation's behavior will be incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf we choose a bad representation, the implementation's behavior will be incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIf we choose a bad representation, we may not be able to detect all errors. For example, if we use a 3-bit unsigned representation, a single bit error can change a 0 into a 1 or a 1 into a 0. The number of 1s in the resulting error pattern thus differs by exactly one from the original pattern, and the parity of the error pattern is even. But all valid patterns have odd parity, so any single bit error can be detected by simply counting the number of 1s.""
 }
]","{
 ""id"": 259
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between states and internal state representation?\n#### Option 1\n-------\nThe difference between states and internal state representation is that states are the specific conditions that a system can be in at any given time, while internal state representation is the way in which the system encodes and stores information about those states. In the context of finite state machines (FSMs), a bad state representation can make it difficult or even impossible to correctly implement the machine's intended behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe internal state representation is how the states are mapped in the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are several differences between states and internal state representation. First, states are the actual conditions that a system or object can be in, while internal state representation is how those states are represented internally. For example, the state of a light bulb can be either on or off, while its internal state representation might be a binary number (1 for on, 0 for off). Second, states can be changed externally, while internal state representation generally can only be changed internally. For example, someone flipping a light switch would change the state of the light bulb from off to on, while the only way to change the internal state representation would be to physically change the bulb itself. Finally, states can be observed externally, while internal state representation generally can only be observed internally. For example, someone looking at a light bulb can tell whether it is on or off, while the only way to observe the internal state representation would be to look at the bulb itself.""
 }
]","{
 ""id"": 260
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the impact of a bad state representation?\n#### Option 1\n-------\nIf we choose a bad representation, the implementation's behavior will be incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf we choose a bad representation, it can be difficult to verify the implementation's behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIf we choose a bad state representation, the implementation's behavior is incorrect. For example, in the two-bit Gray code counter with start and stop inputs, the table below shows a poorly chosen mapping from states to internal state representation. Below the table is a diagram of an implementation using that representation. Verifying that the implementation's behavior is correct is left as an exercise for the determined reader.""
 }
]","{
 ""id"": 261
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a bad state representation impact verification?\n#### Option 1\n-------\nA bad state representation can impact verification in a few ways. First, it can make the system more difficult to understand. This can lead to errors in the implementation, or in the verification process itself. Second, a bad state representation can make the system more difficult to test. This can lead to errors in the system's behavior that are difficult to find and fix. Finally, a bad state representation can make the system more difficult to maintain. This can lead to errors in the system that are difficult to track and fix.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA bad state representation makes verification more difficult because the states are not clearly defined.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA bad state representation can impact verification in several ways. First, if the representation is not complete, some states may not be reachable from the initial state, and thus may not be verifiable. Second, if the representation is not consistent, some states may be reachable from the initial state, but may not be reachable from other states, and thus may not be verifiable. Finally, if the representation is not unique, some states may be reachable from the initial state, but may not be reachable from other states, and thus may not be verifiable.""
 }
]","{
 ""id"": 262
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the consequences of a poorly chosen mapping from states to internal state representation?\n#### Option 1\n-------\nA bad state representation can lead to incorrect behavior of the FSM. This is because the states are not correctly mapped to the internal state representation. This can lead to errors in the FSM's behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf a bad representation is chosen, it can be difficult or impossible to verify the implementation's behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA poorly chosen mapping from states to internal state representation can lead to a number of problems. First, it can make the implementation of the FSM more complex and difficult to understand. Second, it can make the FSM more difficult to verify and test. Third, it can make the FSM more difficult to maintain and modify. Finally, it can impact the performance of the FSM.""
 }
]","{
 ""id"": 263
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between a good and bad representation?\n#### Option 1\n-------\nA good representation is one where the states are clearly defined and there is a one-to-one mapping between the states and the internal state representation. A bad representation is one where the states are not clearly defined or there is not a one-to-one mapping between the states and the internal state representation. In the example above, the states are not clearly defined and there is not a one-to-one mapping between the states and the internal state representation. As a result, it would be difficult to verify that the implementation's behavior is correct.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA good representation is one in which the states are mapped correctly to the internal state representation. A bad representation is one in which the states are mapped incorrectly to the internal state representation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA good representation is one that is easy to understand and work with. A bad representation is one that is difficult to understand and work with. For example, a good representation of a Boolean function is one that is easy to read and understand. A bad representation of a Boolean function is one that is difficult to read and understand.""
 }
]","{
 ""id"": 264
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How do you know if a representation is good or bad?\n#### Option 1\n-------\nThere is no definitive answer to this question, as it depends on the specific application and design requirements. However, there are some general guidelines that can be followed in order to choose an effective representation.\\n \nFirst, the representation should be as simple as possible. This will make it easier to design and implement the system, and also make it more likely that the system will behave as expected.\\n \nSecond, the representation should be easy to understand and use. This will make it easier to verify that the system is functioning correctly.\\n \nThird, the representation should be flexible. This will allow the system to be easily modified if necessary.\\n \nFourth, the representation should be efficient. This means that it should use as few resources as possible, such as memory and processing power.\\n \nFinally, the representation should be robust. This means that it should be able to handle errors and unexpected inputs without causing the system to fail.\\n \nIn general, a good representation is one that meets all of these criteria. However, it is often necessary to trade off some of these properties in order to meet the specific requirements of the application.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf the implementation's behavior is correct, the representation is good.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are many ways to measure the goodness of a representation, but three common metrics are cost, power, and performance. Cost usually represents the manufacturing cost, which is closely related to the physical silicon area required for the design: the larger the chip, the more expensive the chip is to produce. Power measures energy consumption over time. A chip that consumes more power means that a user's energy bill is higher and, in a portable device, either that the device is heavier or has a shorter battery life. Performance measures the speed at which the design operates. A faster design can offer more functionality, such as supporting the latest games, or can just finish the same work in less time than a slower design.""
 }
]","{
 ""id"": 265
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the consequences of choosing a bad representation?\n#### Option 1\n-------\nIf we choose a bad representation, the implementation's behavior will be incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf we choose a bad representation, the implementation's behavior may be incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are a few consequences of choosing a bad representation. One is that the design may be more expensive to produce. Another is that the design may consume more power, which can be a problem in portable devices. Finally, the design may be slower, which can limit functionality.""
 }
]","{
 ""id"": 266
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the impact of the state representation?\n#### Option 1\n-------\nThe impact of the state representation is that it can determine the correctness of the implementation. A well-chosen mapping from states to internal state representation can make the implementation correct, while a poorly chosen mapping can make the implementation incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf we choose a bad representation, it is difficult to verify the implementation's behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n""
 }
]","{
 ""id"": 267
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a bad representation choice impact FSM behavior?\n#### Option 1\n-------\nA bad representation choice can impact an FSM's behavior in a number of ways. For example, if the states are not properly mapped to the internal state representation, the FSM may not function correctly. Additionally, if the representation is not well-chosen, the FSM may be more difficult to verify for correctness.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA bad representation choice can make verifying the implementation's behavior more difficult.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA bad representation choice can impact FSM behavior in a number of ways. First, it can lead to an implementation that is more complex and difficult to understand. Second, it can make it more difficult to correctly derive the logic expressions for the next-state variables and output signals. Finally, it can lead to a design that is less intuitive and harder for humans to understand.""
 }
]","{
 ""id"": 268
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the consequences of a poorly chosen state mapping?\n#### Option 1\n-------\nThe consequences of a poorly chosen state mapping can be seen in the table and diagram above. If we choose a bad representation, the implementation's behavior will be incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf a poor state mapping is chosen, the implementation's behavior will be incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA poorly chosen state mapping can have a number of consequences. First, it can lead to an increase in the number of logic gates required to implement the design. This, in turn, can lead to an increase in the cost of the design, as well as an increase in the power consumption and/or decrease in the performance. Second, a poorly chosen state mapping can lead to a design that is more difficult to verify and test. This can lead to an increase in the time and cost required to bring the design to market.""
 }
]","{
 ""id"": 269
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the impact of the state representation on an FSM?\n#### Option 1\n-------\nThe state representation has a significant impact on the function of an FSM. A well-chosen representation can make the FSM more efficient and easier to understand. A poorly chosen representation can make the FSM more difficult to understand and can lead to errors.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf a bad representation is chosen, the implementation's behavior may be incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe choice of state representation for an FSM can have a significant impact on the complexity of the implementation. A more intuitive and easier-to-understand representation can often lead to a simpler and more efficient implementation.""
 }
]","{
 ""id"": 270
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the state representation affect the implementation of an FSM?\n#### Option 1\n-------\nThe state representation affects the implementation of an FSM in two ways. \n\nFirst, the state representation determines how the states are encoded. \nFor example, the two-bit Gray code counter with start and stop inputs can be encoded in one of two ways. \nThe first way is to use a three-bit state representation, with the states being encoded as 000, 001, 010, 011, 100, 101, 110, and 111. \nThe second way is to use a two-bit state representation, with the states being encoded as 00, 01, 10, and 11. \n\nThe second way is more efficient, because it requires less hardware. \n\nSecond, the state representation affects the order in which the states are visited. \nFor example, if the states are encoded as 000, 001, 010, 011, 100, 101, 110, and 111, then the order in which the states are visited is: 000, 001, 010, 011, 100, 101, 110, 111. \n\nHowever, if the states are encoded as 00, 01, 10, and 11, then the order in which the states are visited is: 00, 01, 10, 11, 00, 01, 10, 11. \n\nThus, the state representation can affect the behavior of an FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf a bad representation is chosen, it can make verifying the implementation's behavior more difficult.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe state representation affects the implementation of an FSM in two ways: first, by determining the number of flip-flops and gates needed; and second, by affecting the complexity of the logic expressions.\n\nThe number of flip-flops and gates needed is determined by the number of states in the FSM. For example, if the FSM has four states, then two flip-flops are needed; if the FSM has eight states, then three flip-flops are needed.\n\nThe complexity of the logic expressions is affected by the choice of state representation. For example, if the states are represented by binary numbers, then the logic expressions will be simpler than if the states are represented by decimal numbers.""
 }
]","{
 ""id"": 271
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to choose a good state representation for an FSM?\n#### Option 1\n-------\nIt is important to choose a good state representation for an FSM because it can impact the behavior of the machine. A well-chosen representation can make the machine easier to understand and verify. A poorly-chosen representation can make the machine more difficult to understand and verify.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIf we choose a bad representation, the implementation's behavior may be incorrect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt is important to choose a good state representation for an FSM because the choice of representation can affect the complexity of the implementation. A more intuitive and easier-to-understand representation typically makes for a better design in terms of other metrics, such as logic complexity.""
 }
]","{
 ""id"": 272
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the memory abstraction?\n#### Option 1\n-------\nThe memory abstraction is a way of representing memories in digital systems. The most common type of memory used in digital systems is RAM, which stands for random access memory. RAM is a type of memory that can be accessed randomly, meaning that any location in the memory can be accessed without having to go through the entire memory.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe memory abstraction is a digital system that stores data.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe memory abstraction is a way of representing a memory system in a way that is independent of the specific implementation details. This abstraction is useful in understanding how a memory system works, and in designing new memory systems.""
 }
]","{
 ""id"": 273
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the types of memory most commonly used in digital systems?\n#### Option 1\n-------\nThere are two main types of memory used in digital systems: static RAM (SRAM) and dynamic RAM (DRAM). SRAM is faster and more expensive, while DRAM is slower and cheaper.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe types of memory most commonly used in digital systems are static RAMs and dynamic RAMs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two most common types of memory used in digital systems are static random access memory (SRAM) and dynamic random access memory (DRAM). SRAM is used for high-speed applications such as processor caches and some embedded designs. DRAM is used for most other applications, such as main memory in computers, because it has a higher bit density than SRAM. Both types of memory are volatile, which means that they lose all data when the power supply is removed.""
 }
]","{
 ""id"": 274
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How can one build memories (static RAMs) using logic?\n#### Option 1\n-------\nStatic random access memories (SRAMs) can be built using logic gates. The basic idea is to use two cross-coupled inverters to store a single bit. When the SRAM is not being accessed, the two inverters will hold the bit steady. When the SRAM is being accessed, one of the inverters will be turned off, allowing the other inverter to switch the bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic RAMs can be built using logic by using tri-state buffers to simplify output connections, and by combining memory chips to provide larger and wider memories.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory (SRAM) is a type of random access memory (RAM) that uses active logic in the form of a two-inverter loop to maintain stored values. SRAM is used for high-speed applications such as processor caches and some embedded designs. \n\nAs SRAM bit density---the number of bits in a given chip area---is significantly lower than DRAM bit density, most applications with less demanding speed requirements use DRAM. The main memory in most computers, for example, is DRAM, whereas the memory on the same chip as a processor is SRAM. Chips combining both DRAM and processor logic are available, and are used by some processor manufacturers (such as IBM). Research is underway to couple such logic types more efficiently by building 3D stacks of chips.\n\nA diagram of an SRAM cell (a single bit) appears below. A dual-inverter loop stores the bit, and is connected to opposing BIT lines through transistors controlled by a SELECT line.\n\nThe cell works as follows. When SELECT is high, the transistors connect the inverter loop to the bit lines. When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input. When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs. The value""
 }
]","{
 ""id"": 275
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the memory abstraction?\n#### Option 1\n-------\nThe memory abstraction is a model of memory that is used to simplify the design of digital systems. The memory abstraction is based on the idea that memory is a collection of cells, each of which can store a bit of information. The memory abstraction is used to simplify the design of digital systems by allowing the designer to think of memory as a collection of cells, rather than as a collection of wires.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe memory abstraction is a way of representing data in a digital system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n\\n\n\nThe memory abstraction is a way of representing a memory system in a way that is independent of the specific implementation details. This abstraction is useful in understanding how a memory system works, and in designing new memory systems. The memory abstraction consists of two parts: the address space and the data. The address space is a set of addresses, each of which corresponds to a specific location in the memory system. The data is the set of values that can be stored at each location in the memory system.""
 }
]","{
 ""id"": 276
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the types of memory most commonly used in digital systems?\n#### Option 1\n-------\nThe types of memory most commonly used in digital systems are static RAMs and dynamic RAMs. Static RAMs are faster and more expensive than dynamic RAMs, but they require more power and are more difficult to design. Dynamic RAMs are slower and less expensive, but they are easier to design and require less power.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic and dynamic RAMs are the most common types of memory used in digital systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two most common types of memory used in digital systems are static random access memory (SRAM) and dynamic random access memory (DRAM). SRAM is used for high-speed applications such as processor caches and some embedded designs. DRAM is used for most other applications, such as main memory in computers, because it has a higher bit density than SRAM. Both types of memory are volatile, which means that they lose all data when the power supply is removed.""
 }
]","{
 ""id"": 277
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How can one build memories (static RAMs) using logic?\n#### Option 1\n-------\nStatic random access memories (SRAMs) can be built using logic gates. The most common type of SRAM is the six-transistor (6T) SRAM cell, which is composed of four N-type metal-oxide-semiconductor field-effect transistors (MOSFETs) and two P-type MOSFETs. The four N-type MOSFETs form the two cross-coupled inverters of a flip-flop, with the two P-type MOSFETs acting as access transistors. The access transistors are used to connect the SRAM cell to the bitlines, which are used to read and write data to the cell.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic RAMs can be built using logic by connecting tri-state buffers to provide larger and wider memories.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory (SRAM) is a type of random access memory (RAM) that uses active logic in the form of a two-inverter loop to maintain stored values. SRAM is used for high-speed applications such as processor caches and some embedded designs. \n\nAs SRAM bit density (the number of bits in a given chip area) is significantly lower than DRAM bit density, most applications with less demanding speed requirements use DRAM. The main memory in most computers, for example, is DRAM, whereas the memory on the same chip as a processor is SRAM. \n\nDRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs. \n\nA diagram of an SRAM cell (a single bit) appears below. A dual-inverter loop stores the bit, and is connected to opposing BIT lines through transistors controlled by a SELECT line.   \n\nThe cell works as follows. When SELECT is high, the transistors connect the inverter loop to the bit lines. When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input. When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs.    \n\nThe value stored previously is thus copied onto the""
 }
]","{
 ""id"": 278
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does one build memories (static RAMs) using logic?\n#### Option 1\n-------\nStatic random-access memory (static RAM or SRAM) is a type of random-access memory (RAM) that uses bistable latching circuitry (flip-flop) to store each bit. SRAM shares many of the advantages and disadvantages of DRAM; it is much faster, but also much more expensive and requires more power to operate. A static RAM contains an array of flip-flops, which are used to store the data bits. The flip-flops are connected to sense amplifiers, which are used to read the data bits. The sense amplifiers are connected to input/output (I/O) circuits, which are used to write the data bits.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic RAMs are built using logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory (SRAM) is built using logic gates, such as AND, OR, and NOT gates, to create a storage element. The basic SRAM cell contains two inverters, which are connected to each other and to the bit lines through transistors. The transistors are controlled by a select line. When the select line is high, the transistors connect the inverters to the bit lines. When writing to a cell, the bit lines are held at opposite logic values, which forces the inverters to match the values on the lines and stores the value from the BIT input. When reading from a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs. The value stored previously is thus copied onto the BIT line as an output, and the opposite value is placed on the""
 }
]","{
 ""id"": 279
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a tri-state buffer and how does it simplify output connections?\n#### Option 1\n-------\nA tri-state buffer is a digital circuit that can be used to control the flow of data on a data bus. It is used to simplify output connections by allowing only one device to be connected to the bus at a time. When the tri-state buffer is enabled, the data on the bus is driven by the device; when it is disabled, the data on the bus is 'floating' and is not driven by any device.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a digital circuit that can be used to improve the efficiency of output connections. It does this by allowing the output of the buffer to be \""disconnected\"" from the input, which reduces the number of required connections.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. This is achieved by using a pair of transistors, one of which is used to connect the signal line to the power supply, and the other of which is used to connect the signal line to ground. When the buffer is enabled, both transistors are turned on, and the signal line is connected to either the power supply or ground, depending on the value of the input signal. When the buffer is disabled, both transistors are turned off, and the signal line is effectively disconnected from both the power supply and ground.\n\nTri-state buffers are often used to simplify output connections in digital circuits. For example, if a circuit has two outputs that are always complementary (i.e. one is always high when the other is low, and vice versa), then a tri-state buffer can be used to connect both outputs to the same signal line. This is because when the buffer is enabled, one output will be connected to the power supply and the other will be connected to ground, and when the buffer is disabled, both outputs will be effectively disconnected from the power supply and ground.""
 }
]","{
 ""id"": 280
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How are memory chips combined to provide larger and wider memories?\n#### Option 1\n-------\nMemory chips can be combined in a number of ways to provide larger and wider memories. One way is to connect them in parallel, with each chip providing one bit of data. This approach can be used to create very wide memories, but is limited in terms of the total amount of data that can be stored.\n\nAnother way to combine memory chips is to connect them in series, with each chip providing one byte of data. This approach can be used to create very large memories, but is limited in terms of the width of the data that can be stored.\n\n yet another way to combine memory chips is to connect them in a hierarchy, with each chip providing a certain amount of data. This approach can be used to create both large and wide memories, and is therefore the most flexible.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nTri-state buffers are used to simplify output connections, and memory chips can be combined to provide larger and wider memories.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe figure on the left above shows a generic RAM structure.  The memory contains 2^k elements of N bits each.  A {k-bit} address input, ADDR, identifies the memory element of interest for any particular operation.  The write enable input, WE, selects the operation to be performed: if WE is high, the operation is a write; if it is low, the operation is a read.  Data to be written into an element are provided through N inputs at the top, and data read from an element appear on N outputs at the bottom.  Finally, a { chip select} input, CS, functions as an enable control for the memory; when CS is low, the memory neither reads nor writes any location.  Random access memory further divides into two important types: { static RAM}, or { SRAM}, and { dynamic RAM}, or { DRAM}. SRAM employs active logic in the form of a two-inverter loop to maintain stored values.  DRAM uses a charged capacitor to store a bit; the charge drains over time and must be replaced, giving rise to the qualifier ``dynamic.''  ``Static'' thus serves only to differentiate memories with active logic elements from those with capacitive elements.  Both types are volatile, that is, both lose all data when the power supply is removed.  We consider both SRAM and DRAM  in this course, but the details of DRAM operation are beyond""
 }
]","{
 ""id"": 281
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the memory abstraction?\n#### Option 1\n-------\nThe memory abstraction is a way of representing memories in digital systems. It is a way of representing the data stored in memories in a way that is easy to understand and use. There are two types of memory abstraction: static and dynamic. Static memory abstraction is used to represent data that is not changing, while dynamic memory abstraction is used to represent data that is changing.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe memory abstraction is a way of representing data in a digital system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe memory abstraction is a way of representing a memory system in a way that is independent of the specific details of the implementation. This abstraction is useful in understanding how a memory system works, and in designing new memory systems. The memory abstraction has two parts: the address space and the data. The address space is a set of addresses, each of which corresponds to a specific location in the memory system. The data is the set of values that can be stored at each location in the memory system.""
 }
]","{
 ""id"": 282
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the types of memory most commonly used in digital systems?\n#### Option 1\n-------\nThere are two main types of memory most commonly used in digital systems: static RAM (SRAM) and dynamic RAM (DRAM). SRAM is made up of flip-flops, which store each bit of data. This makes SRAM faster and more expensive than DRAM, which uses capacitors to store data.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic and dynamic RAMs are the most common types of memory used in digital systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two most common types of memory used in digital systems are static random access memory (SRAM) and dynamic random access memory (DRAM). SRAM is used for high-speed applications such as processor caches and some embedded designs. DRAM is used for most other applications, such as main memory in computers, because it has a higher bit density than SRAM. DRAM is also available when recharging its capacitors, which can be a problem for applications with stringent real-time needs.""
 }
]","{
 ""id"": 283
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How can one build memories (static RAMs) using logic?\n#### Option 1\n-------\nOne can build memories (static RAMs) using logic by connecting memory cells in a grid. Each memory cell is made up of a flip-flop, which is a type of logic device that can store a single bit of data. The flip-flops are connected so that each one can be addressed by a unique combination of signals from the address bus. When a particular flip-flop is selected, the data stored in that flip-flop can be read from or written to, depending on the state of the control signals.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic RAMs can be built using logic by connecting memory cells in a grid.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory (SRAM) is a type of random access memory (RAM) that uses active logic in the form of a two-inverter loop to maintain stored values. SRAM is used for high-speed applications such as processor caches and some embedded designs. \n\nAs SRAM bit density---the number of bits in a given chip area---is significantly lower than DRAM bit density, most applications with less demanding speed requirements use DRAM. The main memory in most computers, for example, is DRAM, whereas the memory on the same chip as a processor is SRAM. Chips combining both DRAM and processor logic are available, and are used by some processor manufacturers (such as IBM). Research is underway to couple such logic types more efficiently by building 3D stacks of chips.\n\nA diagram of an SRAM cell (a single bit) appears below. A dual-inverter loop stores the bit, and is connected to opposing BIT lines through transistors controlled by a SELECT line.\n\nThe cell works as follows. When SELECT is high, the transistors connect the inverter loop to the bit lines. When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input. When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs. The value""
 }
]","{
 ""id"": 284
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the memory abstraction?\n#### Option 1\n-------\nThe memory abstraction is a model of memory that is used to simplify the design of digital systems. The memory abstraction is based on the idea that memory is a collection of cells, each of which can store a bit of data. The memory abstraction is used to simplify the design of digital systems by allowing the designer to think of memory as a collection of cells, rather than as a collection of wires.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe memory abstraction is a way of representing data in a digital system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe memory abstraction is a way of representing a memory system in a way that is independent of the specific details of the underlying implementation. This abstraction is useful because it allows different types of memory systems to be compared and contrasted in a way that is independent of their specific implementation details. For example, a memory system can be represented as a set of addressable storage elements, each of which is associated with a unique address. This abstraction makes it possible to compare and contrast different types of memory systems, such as static random access memory (SRAM) and dynamic random access memory (DRAM).""
 }
]","{
 ""id"": 285
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the types of memory most commonly used in digital systems?\n#### Option 1\n-------\nThere are two main types of memory used in digital systems: static RAM (SRAM) and dynamic RAM (DRAM). SRAM is faster and more expensive, while DRAM is slower and cheaper.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic and dynamic RAMs are the most common types of memory used in digital systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two most common types of memory used in digital systems are static random access memory (SRAM) and dynamic random access memory (DRAM). SRAM is used for high-speed applications such as processor caches and some embedded designs. DRAM is used for most other applications, such as main memory in computers, because it has a higher bit density than SRAM. Both types of memory are volatile, which means that they lose all data when the power supply is removed.""
 }
]","{
 ""id"": 286
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How can one build memories (static RAMs) using logic?\n#### Option 1\n-------\nStatic random access memories (SRAMs) can be built using logic. The basic idea is to use flip-flops to store data. A flip-flop can be thought of as a two-state memory element, which can store one bit of data. To store more than one bit of data, multiple flip-flops can be connected together. \n\nThe number of flip-flops needed to store a certain number of bits can be determined by using the following formula: \n\nNumber of flip-flops = 2^n \n\nwhere n is the number of bits to be stored. \n\nFor example, if we wanted to store 8 bits of data, we would need 2^8, or 256, flip-flops. \n\nTo read from and write to an SRAM, we need to use a set of control signals. The most common control signals are: \n\n- /CE (chip enable): This signal is used to enable or disable the SRAM. When the SRAM is disabled, it will not respond to any other control signals. \n- /WE (write enable): This signal is used to control writing to the SRAM. When writing is enabled, data can be written to the SRAM; when writing is disabled, data cannot be written to the SRAM. \n- /OE (output enable): This signal is used to control reading from the SRAM. When the output""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic RAMs can be built using logic by connecting memory cells in a grid.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory (SRAM) is a type of random access memory (RAM) that uses active logic in the form of a two-inverter loop to maintain stored values. SRAM is used for high-speed applications such as processor caches and some embedded designs. DRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs. \n\nA diagram of an SRAM cell (a single bit) appears below. A dual-inverter loop stores the bit, and is connected to opposing BIT lines through transistors controlled by a SELECT line. The cell works as follows. When SELECT is high, the transistors connect the inverter loop to the bit lines. When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input. When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs. The value stored previously is thus copied onto the BIT line as an output, and the opposite value is placed on the""
 }
]","{
 ""id"": 287
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does one build memories (static RAMs) using logic?\n#### Option 1\n-------\nOne can build memories (static RAMs) using logic by connecting memory cells in a grid. Each memory cell is made up of a flip-flop, which is a type of logic device that can store a single bit of data. The flip-flops are connected together so that each cell can be addressed by a unique address. When data is written to a cell, it is stored in the flip-flop until the data is changed or the power is turned off.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic RAMs are built using logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory (SRAM) is built using logic circuits. The most common type of SRAM cell uses a dual-inverter loop to store a bit. The cell is connected to opposing bit lines through transistors controlled by a select line. When the select line is high, the transistors connect the inverter loop to the bit lines. When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the bit input. When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs. The value stored previously is thus copied onto the bit line as an output, and the opposite value is placed on the""
 }
]","{
 ""id"": 288
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a tri-state buffer and how does it simplify output connections?\n#### Option 1\n-------\nA tri-state buffer is a digital circuit that can be used to control the flow of data on a data bus. It is used to simplify output connections by allowing multiple devices to share a common data bus. When the tri-state buffer is enabled, it passes the data on the bus to the output. When it is disabled, it blocks the data on the bus, preventing it from being passed to the output. This allows multiple devices to share a common data bus without interference.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a type of digital circuit that can be used to simplify output connections. It does this by allowing a single output to be turned on or off, or to be left in a high-impedance state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is an electronic circuit that can be used to either connect or disconnect an electronic component from a circuit. The two main purposes of a tri-state buffer are to simplify output connections and to reduce the number of pins needed on a chip.\n\nWhen used to simplify output connections, a tri-state buffer is placed between the output of a memory chip and the external circuit. The tri-state buffer has three states: high, low, and high impedance (or \""hi-Z\""). The high impedance state effectively disconnects the output of the memory chip from the external circuit. This allows the same output line to be shared by multiple memory chips without the need for additional multiplexers.\n\nWhen used to reduce the number of pins needed on a chip, the tri-state buffer is used to combine data inputs and outputs. For example, data inputs and outputs of memory chips can be combined into a single set of data wires. This reduces the number of pins needed on the chip.""
 }
]","{
 ""id"": 289
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can memory chips be combined to provide larger and wider memories?\n#### Option 1\n-------\nMemory chips can be combined to provide larger memories by connecting them in parallel. This is called parallelism. Wider memories can be provided by connecting the chips in series. This is called serialism.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nMemory chips can be combined to provide larger and wider memories by using tri-state buffers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nOne way to provide larger and wider memories is to combine multiple memory chips. This can be done by connecting the chips in parallel, which will increase the width of the memory, or by connecting the chips in series, which will increase the size of the memory. For example, a 64-bit memory could be created by connecting eight 8-bit memory chips in parallel. Alternatively, a 256-bit memory could be created by connecting four 64-bit memory chips in series.""
 }
]","{
 ""id"": 290
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the memory abstraction?\n#### Option 1\n-------\nThe memory abstraction is a way of representing information in a digital system. It is the most basic form of data storage and is used to store instructions and data that can be accessed by the system. There are two main types of memory: volatile and non-volatile. Volatile memory is lost when power is removed from the system, while non-volatile memory is retained.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe memory abstraction is a way of representing data in a digital system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe memory abstraction is a way of representing a memory system in a way that is independent of the specific implementation details. This abstraction is useful in understanding how a memory system works, and in designing new memory systems. The memory abstraction has two main components: the address space and the data storage. The address space is the set of all possible addresses that can be used to access data in the memory system. The data storage is the set of all possible data values that can be stored in the memory system.""
 }
]","{
 ""id"": 291
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the types of memory most commonly used in digital systems?\n#### Option 1\n-------\nThe types of memory most commonly used in digital systems are static RAMs and dynamic RAMs. Static RAMs are faster and more expensive than dynamic RAMs, but they require more power and are more difficult to design. Dynamic RAMs are slower and less expensive, but they are easier to design and require less power.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic and dynamic RAMs are the most common types of memory used in digital systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two types of memory most commonly used in digital systems are static random access memory (SRAM) and dynamic random access memory (DRAM). SRAM is used for high-speed applications such as processor caches and some embedded designs, while DRAM is used for applications with less demanding speed requirements, such as main memory in most computers. DRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs.""
 }
]","{
 ""id"": 292
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How can one build memories (static RAMs) using logic?\n#### Option 1\n-------\nStatic random access memories (SRAMs) can be built using logic gates. The basic idea is to use two cross-coupled inverters to store a single bit. When the SRAM is not being accessed, the two inverters will maintain the stored bit. When the SRAM is being accessed, one of the inverters will be turned off, allowing the other inverter to change the stored bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic RAMs can be built using logic by connecting tri-state buffers to memory chips to provide larger and wider memories.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory (SRAM) is a type of random access memory (RAM) that uses active logic in the form of a two-inverter loop to maintain stored values. SRAM is used for high-speed applications such as processor caches and some embedded designs. \n\nAs SRAM bit density---the number of bits in a given chip area---is significantly lower than DRAM bit density, most applications with less demanding speed requirements use DRAM. The main memory in most computers, for example, is DRAM, whereas the memory on the same chip as a processor is SRAM. \n\nChips combining both DRAM and processor logic are available, and are used by some processor manufacturers (such as IBM). Research is underway to couple such logic types more efficiently by building 3D stacks of chips.""
 }
]","{
 ""id"": 293
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the memory abstraction?\n#### Option 1\n-------\nThe memory abstraction is a model of memory that is used to simplify the design of digital systems. The memory abstraction is based on the idea that memory is a collection of cells, each of which can store a bit of data. The memory abstraction is used to simplify the design of digital systems by allowing the designer to think of memory as a collection of cells, rather than as a collection of wires.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe memory abstraction is a way of representing data in a digital system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe memory abstraction is a way of representing a memory system in a computer. It is a way of representing the data stored in a memory system, the operations that can be performed on that data, and the structure of the memory system.""
 }
]","{
 ""id"": 294
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the types of memory most commonly used in digital systems?\n#### Option 1\n-------\nThere are two main types of memory used in digital systems: static RAM (SRAM) and dynamic RAM (DRAM). SRAM is faster and more expensive, while DRAM is slower and cheaper.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic and dynamic RAMs are the most common types of memory used in digital systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two most common types of memory used in digital systems are static random access memory (SRAM) and dynamic random access memory (DRAM). SRAM is used for high-speed applications such as processor caches and some embedded designs. DRAM is used for most other applications, such as main memory in computers. DRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs.""
 }
]","{
 ""id"": 295
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How can one build memories (static RAMs) using logic?\n#### Option 1\n-------\nStatic RAMs are built using logic gates, which are the basic components of digital circuits. The most common type of logic gate is the AND gate, which has two inputs and one output. If both inputs are 1, the output is 1. Otherwise, the output is 0.\n\nStatic RAMs are made up of cells, which are made up of two parts: a flip-flop and a logic gate. The flip-flop stores the data bit, and the logic gate controls the flow of data. The most common type of flip-flop is the D flip-flop, which has two inputs (D and clock) and one output (Q). The D input is the data input, and the clock input is used to synchronize the data. The output Q is the data output.\n\nTo build a static RAM, the flip-flops and logic gates are connected together in a particular way. The flip-flops are connected in a series, and the logic gates are connected in a parallel. The data input (D) is connected to the flip-flop, and the clock input is connected to the logic gate. The output of the flip-flop is connected to one input of the logic gate, and the other input of the logic gate is connected to the data output (Q).\n\nTri-state buffers are used to simplify output connections. A tri-state buffer has three states: high, low, and high impedance""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic RAMs can be built using logic gates. Tri-state buffers are used to simplify output connections. Memory chips can be combined to provide larger and wider memories.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic RAMs are built using logic by combining multiple memory chips. This is done by using a decoder to enable one of the chips. The address, write enable, and chip select inputs are routed to both chips. The data inputs and outputs are separate.\n\nThe purpose of tri-state buffers is to provide a logical disconnection between the tri-state buffer and the output. This is done by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground.\n\nMemory chips are combined to provide larger memories by using a decoder to enable one of the chips. The address, write enable, and chip select inputs are routed to both chips. The data inputs and outputs are separate. Memory chips are also combined to provide wider memories by using a decoder to enable one of the chips. The address, write enable, and chip select inputs are routed to both chips. The data inputs and outputs are separate.""
 }
]","{
 ""id"": 296
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the addressability of a computer memory?\n#### Option 1\n-------\nThe addressability of a computer memory is the number of bits that can be stored in each element of the memory. The addressability of a memory can vary from a single bit to a byte or more.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe addressability of a computer memory is the size of the elements in the memory, which can be a single binary digit, or bit, to a byte (8 bits) or more.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe addressability of a computer memory is the number of bits that can be addressed by the memory. For example, a computer memory with an addressability of 8 bits can store 2^8 = 256 different values.""
 }
]","{
 ""id"": 297
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is a word in relation to computer memory?\n#### Option 1\n-------\nA word in relation to computer memory is a data element that is larger than a byte. The size of a word depends on the context.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA word is a data element larger than a byte.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA word in computer memory is a unit of data that can be read or written by a processor. A word is typically made up of a fixed number of bits, and the number of bits in a word determine the range of values that can be represented by that word. For example, a word made up of 8 bits can represent a number between 0 and 255, while a word made up of 32 bits can represent a number between 0 and 4,294,967,295.""
 }
]","{
 ""id"": 298
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the difference between SRAM and DRAM?\n#### Option 1\n-------\nSRAM and DRAM are two important types of random access memory (RAM). SRAM employs active logic in the form of a two-inverter loop to maintain stored values. DRAM uses a charged capacitor to store a bit; the charge drains over time and must be replaced, giving rise to the qualifier ``dynamic.'' ``Static'' thus serves only to differentiate memories with active logic elements from those with capacitive elements. Both types are volatile, that is, both lose all data when the power supply is removed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM employs active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nSRAM is a type of random access memory that employs active logic in the form of a two-inverter loop to maintain stored values. DRAM uses a charged capacitor to store a bit; the charge drains over time and must be replaced, giving rise to the qualifier \""dynamic.\"" Static RAM is used for high-speed applications such as processor caches and some embedded designs, while DRAM is used for applications with less demanding speed requirements.""
 }
]","{
 ""id"": 299
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is a computer memory?\n#### Option 1\n-------\nA computer memory is a group of storage elements and the logic necessary to move data in and out of the elements. The size of the elements in a memory - called the addressability of the memory - varies from a single binary digit, or bit, to a byte (8 bits) or more. Typically, we refer to data elements larger than a byte as words, but the size of a word depends on context.\\n \nEach element in a memory is assigned a unique name, called an address, that allows an external circuit to identify the particular element of interest. These addresses are not unlike the street addresses that you use when you send a letter. Unlike street addresses, however, memory addresses usually have little or no redundancy; each possible combination of bits in an address identifies a distinct set of bits in the memory.\\n \nThe memories that we consider in this class have several properties in common. These memories support two operations: write places a word of data into an element, and read retrieves a copy of a word of data from an element. The memories are also volatile, which means that the data held by a memory are erased when electrical power is turned off or fails. Non-volatile forms of memory include magnetic and optical storage media such as DVDs, CD-ROMs, disks, and tapes, capacitive storage media such as Flash drives, and some programmable logic devices.\\n \nFinally, the memories considered in this class are random access memories""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA computer memory is a group of storage elements and the logic necessary to move data in and out of the elements.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA computer memory is a device that stores data for future use. There are two main types of computer memory: static random access memory (SRAM) and dynamic random access memory (DRAM). SRAM is used for high-speed applications such as processor caches, while DRAM is used for most other applications such as main memory in computers. Both SRAM and DRAM are volatile, meaning they lose all data when power is removed.""
 }
]","{
 ""id"": 300
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the two types of RAM?\n#### Option 1\n-------\nRandom access memory (RAM) is divided into two important types: static RAM (SRAM) and dynamic RAM (DRAM). SRAM employs active logic in the form of a two-inverter loop to maintain stored values. DRAM uses a charged capacitor to store a bit; the charge drains over time and must be replaced, giving rise to the qualifier ``dynamic.'' ``Static'' thus serves only to differentiate memories with active logic elements from those with capacitive elements.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic RAM (SRAM) and Dynamic RAM (DRAM)""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two types of RAM are SRAM and DRAM. SRAM is a type of RAM that uses active logic in the form of a two-inverter loop to maintain stored values. DRAM is a type of RAM that uses a charged capacitor to store a bit.""
 }
]","{
 ""id"": 301
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the difference between SRAM and DRAM?\n#### Option 1\n-------\nThere are two important types of computer memories: static RAM (SRAM) and dynamic RAM (DRAM). SRAM employs active logic in the form of a two-inverter loop to maintain stored values. DRAM uses a charged capacitor to store a bit; the charge drains over time and must be replaced, giving rise to the qualifier ``dynamic.''  ``Static'' thus serves only to differentiate memories with active logic elements from those with capacitive elements.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM uses active logic in the form of a two-inverter loop to maintain stored values while DRAM uses a charged capacitor to store a bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two important types of computer memories- static RAM (SRAM), and dynamic RAM (DRAM). SRAM employs active logic in the form of a two-inverter loop to maintain stored values. DRAM uses a charged capacitor to store a bit; the charge drains over time and must be replaced, giving rise to the qualifier ``dynamic.''  ``Static'' thus serves only to differentiate memories with active logic elements from those with capacitive elements.""
 }
]","{
 ""id"": 302
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the addressability of a typical computer memory?\n#### Option 1\n-------\nThe addressability of a typical computer memory is a single binary digit, or bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe size of the elements in a memory, called the addressability of the memory, varies from a single binary digit, or bit, to a byte (8 bits) or more.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe addressability of a typical computer memory is the number of bits that can be stored in each element of the memory. For example, a typical SRAM cell can store one bit, so the addressability of an SRAM memory is 1 bit. A typical DRAM cell can store one bit, so the addressability of a DRAM memory is also 1 bit.""
 }
]","{
 ""id"": 303
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is a word in this context?\n#### Option 1\n-------\nA word in this context is a data element that is larger than a byte.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA word is a data element larger than a byte.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA word in this context is a unit of data that can be stored in a memory element.""
 }
]","{
 ""id"": 304
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the difference between SRAM and DRAM?\n#### Option 1\n-------\nThe main difference between SRAM and DRAM is that SRAM uses active logic in the form of a two-inverter loop to maintain stored values while DRAM uses a charged capacitor to store a bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM uses active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main difference between SRAM and DRAM is that SRAM uses active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit. SRAM is thus faster and more expensive than DRAM. DRAM is also less dense than SRAM, meaning that more DRAM chips are required to store the same amount of data.""
 }
]","{
 ""id"": 305
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the two types of RAM?\n#### Option 1\n-------\nThe two types of RAM are SRAM and DRAM. SRAM is a static RAM that uses active logic in the form of a two-inverter loop to maintain stored values. DRAM is a dynamic RAM that uses a charged capacitor to store a bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM and DRAM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are two types of RAM: static RAM (SRAM) and dynamic RAM (DRAM). SRAM uses active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit. Both types of RAM are volatile, meaning they lose all data when the power supply is removed.""
 }
]","{
 ""id"": 306
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does SRAM store data?\n#### Option 1\n-------\nSRAM stores data using active logic in the form of a two-inverter loop. This loop allows the SRAM to maintain stored values. SRAM is a volatile memory, which means that it will lose all data when the power supply is removed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM uses active logic in the form of a two-inverter loop to maintain stored values.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nSRAM stores data using a dual-inverter loop that is connected to opposing BIT lines through transistors controlled by a SELECT line. When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input. When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs.""
 }
]","{
 ""id"": 307
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does DRAM store data?\n#### Option 1\n-------\nDRAM stores data using a charged capacitor. The charge on the capacitor drains over time, and must be replaced in order to maintain the stored data.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nDRAM uses a charged capacitor to store a bit; the charge drains over time and must be replaced.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main difference between SRAM and DRAM is that SRAM uses active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit. DRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs.""
 }
]","{
 ""id"": 308
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is each element in a memory assigned a unique name?\n#### Option 1\n-------\nEach element in a memory is assigned a unique name, called an address, that allows an external circuit to identify the particular element of interest. This is necessary in order to be able to read or write to specific elements in the memory. Addresses are typically assigned in a linear fashion, so that each element has a unique address within the memory.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSo that an external circuit can identify the particular element of interest.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nEach element in a memory is assigned a unique name because memories are random access memories (RAMs). This means that the time required to access an element in the memory is independent of the element being accessed.""
 }
]","{
 ""id"": 309
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does an external circuit identify the particular element of interest?\n#### Option 1\n-------\nEach element in a memory is assigned a unique name, called an address, that allows an external circuit to identify the particular element of interest.  These addresses are not unlike the street addresses that you use when you send a letter.  Unlike street addresses, however, memory addresses usually have little or no redundancy; each possible combination of bits in an address identifies a distinct set of bits in the memory.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nEach element in a memory is assigned a unique name, called an address.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe particular element of interest is identified by the address input, ADDR. The address input is a k-bit input that identifies the memory element of interest for any particular operation.""
 }
]","{
 ""id"": 310
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the two operations that memories support?\n#### Option 1\n-------\nThe two operations that memories support are write and read.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe two operations that memories support are write and read.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two operations that memories support are write and read. Write places a word of data into an element, and read retrieves a copy of a word of data from an element.""
 }
]","{
 ""id"": 311
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the difference between SRAM and DRAM?\n#### Option 1\n-------\nStatic RAM (SRAM) uses active logic in the form of a two-inverter loop to maintain stored values.  Dynamic RAM (DRAM) uses a charged capacitor to store a bit; the charge drains over time and must be replaced, giving rise to the qualifier ``dynamic.''  ``Static'' thus serves only to differentiate memories with active logic elements from those with capacitive elements.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM employs active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nSRAM is a type of random access memory that uses active logic in the form of a two-inverter loop to maintain stored values. DRAM uses a charged capacitor to store a bit; the charge drains over time and must be replaced, giving rise to the qualifier \""dynamic.\"" Static random access memory is used for high-speed applications such as processor caches and some embedded designs. DRAM is used for applications with less demanding speed requirements.""
 }
]","{
 ""id"": 312
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How is data stored in an SRAM?\n#### Option 1\n-------\nSRAM stores data in active logic elements, in the form of a two-inverter loop. This means that the data is stored as long as there is power supplied to the SRAM. When the power is removed, the data is lost.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nData is stored in an SRAM using active logic in the form of a two-inverter loop.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn an SRAM, data is stored in a dual-inverter loop. This loop is connected to opposing BIT lines through transistors controlled by a SELECT line. When writing to a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input. When reading from a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs.""
 }
]","{
 ""id"": 313
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How is data stored in a DRAM?\n#### Option 1\n-------\nData is stored in a DRAM using a charged capacitor. The charge drains over time and must be replaced, giving rise to the qualifier \""dynamic.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA DRAM stores data in a charged capacitor.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn a DRAM, data is stored in a capacitor. The capacitor stores a charge that represents a bit. The charge drains over time and must be replaced, giving rise to the qualifier \""dynamic.\""""
 }
]","{
 ""id"": 314
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is a computer memory?\n#### Option 1\n-------\nA computer memory is a group of storage elements and the logic necessary to move data in and out of the elements. The size of the elements in a memory\u2014called the addressability of the memory\u2014varies from a single binary digit, or bit, to a byte (8 bits) or more. Typically, we refer to data elements larger than a byte as words, but the size of a word depends on context.\\n \nEach element in a memory is assigned a unique name, called an address, that allows an external circuit to identify the particular element of interest. These addresses are not unlike the street addresses that you use when you send a letter. Unlike street addresses, however, memory addresses usually have little or no redundancy; each possible combination of bits in an address identifies a distinct set of bits in the memory. The figure on the right below illustrates the concept. Each house represents a storage element and is associated with a unique address.\\n \nThe memories that we consider in this class have several properties in common. These memories support two operations: write places a word of data into an element, and read retrieves a copy of a word of data from an element. The memories are also volatile, which means that the data held by a memory are erased when electrical power is turned off or fails. Non-volatile forms of memory include magnetic and optical storage media such as DVDs, CD-ROMs, disks, and tapes, capacitive storage media such as Flash""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA computer memory is a group of storage elements and the logic necessary to move data in and out of the elements.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA computer memory is a storage element that holds data and instructions for processing by a computer. There are two main types of computer memory: static random access memory (SRAM) and dynamic random access memory (DRAM). SRAM is used for high-speed applications such as processor caches, while DRAM is used for lower-speed applications such as main memory. Both types of memory are volatile, meaning they lose all data when power is removed.""
 }
]","{
 ""id"": 315
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the addressability of a memory?\n#### Option 1\n-------\nThe addressability of a memory is the size of the storage elements in the memory, typically measured in bits. The addressability of a memory determines the maximum amount of data that can be stored in the memory.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe addressability of a memory is the size of the elements in the memory, which can be a single binary digit, or bit, to a byte (8 bits) or more.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe addressability of a memory refers to the number of unique addresses that can be assigned to elements in the memory. For example, a memory with 2^k elements can be addressed using k-bit addresses. This means that each element in the memory can be uniquely identified by a k-bit address.""
 }
]","{
 ""id"": 316
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is a word in this context?\n#### Option 1\n-------\nA word in this context is a data element that is larger than a byte.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA word in this context is a data element larger than a byte.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA word in this context is a unit of data that can be stored in a memory element.""
 }
]","{
 ""id"": 317
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why does each element in a memory have a unique address?\n#### Option 1\n-------\nEach element in a memory has a unique address so that an external circuit can identify the particular element of interest. This is similar to how street addresses are used to identify specific locations. Memory addresses usually have little or no redundancy, which means that each possible combination of bits in an address identifies a distinct set of bits in the memory.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSo that an external circuit can identify the particular element of interest.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nEach element in a memory has a unique address because each element is associated with a unique storage location. This is necessary in order to ensure that each element can be accessed independently from any other element in the memory.""
 }
]","{
 ""id"": 318
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How is data written into an element in a memory?\n#### Option 1\n-------\nThe data to be written into an element in a memory is provided through N inputs at the top. A k-bit address input, ADDR, identifies the memory element of interest for any particular operation. The write enable input, WE, selects the operation to be performed: if WE is high, the operation is a write.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe write enable input, WE, selects the operation to be performed: if WE is high, the operation is a write.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn a memory, data is written into an element by providing the data through inputs at the top. The write enable input, WE, selects the operation to be performed: if WE is high, the operation is a write; if it is low, the operation is a read. The data to be written into an element are provided through N inputs at the top.""
 }
]","{
 ""id"": 319
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between SRAM and DRAM?\n#### Option 1\n-------\nThe main difference between SRAM and DRAM is that SRAM uses active logic in the form of a two-inverter loop to maintain stored values while DRAM uses a charged capacitor to store a bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM employs active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main difference between SRAM and DRAM is that SRAM is a static memory while DRAM is a dynamic memory. This means that SRAM uses active logic in the form of a two-inverter loop to maintain stored values while DRAM uses a charged capacitor to store a bit. As a result, SRAM is faster but also more expensive than DRAM. SRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs.""
 }
]","{
 ""id"": 320
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is SRAM used for?\n#### Option 1\n-------\nSRAM is used for high-speed applications such as processor caches and some embedded designs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic random access memory is used for high-speed applications such as processor caches and some embedded designs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory is used for high-speed applications such as processor caches and some embedded designs.  As SRAM bit density---the number of bits in a given chip area---is significantly lower than DRAM bit density, most applications with less demanding speed requirements use DRAM.  The main memory in most computers, for example, is DRAM, whereas the memory on the same chip as a processor is SRAM. Chips combining both DRAM and processor logic are available, and are used by some processor manufacturers (such  as IBM).  Research is underway to couple such logic types more efficiently by building 3D stacks of chips.""
 }
]","{
 ""id"": 321
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a SRAM cell work?\n#### Option 1\n-------\nStatic random access memory is used for high-speed applications such as processor caches and some embedded designs.  As SRAM bit density\u2014the number of bits in a given chip area\u2014is significantly lower than DRAM bit density, most applications with less demanding speed requirements use DRAM.  The main memory in most computers, for example, is DRAM, whereas the memory on the same chip as a processor is SRAM. Chips combining both DRAM and processor logic are available, and are used by some processor manufacturers (such as IBM).  Research is underway to couple such logic types more efficiently by building 3D stacks of chips.  DRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs.\n\nA diagram of an SRAM cell (a single bit) appears to the right.  A dual-inverter loop stores the bit, and is connected to opposing BIT lines through transistors controlled by a SELECT line.  The cell works as follows.  When SELECT is high, the transistors connect the inverter loop to the bit lines.  When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input.  When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs.  The value stored previously is thus copied""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA SRAM cell stores a bit using a dual-inverter loop that is connected to opposing BIT lines through transistors controlled by a SELECT line.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA SRAM cell works by storing a bit of data in the form of a charge on a capacitor. When SELECT is low, the transistors disconnect the inverters from the bit lines, and the cell holds its current value until SELECT goes high again. The actual operation of an SRAM cell is more complicated than we have described. For example, when writing a bit, the BIT lines can temporarily connect high voltage to ground (a short). The circuit must be designed carefully to minimize the power consumed during this process. When reading a bit, the BIT lines are pre-charged halfway between high-voltage and ground, and analog devices called sense amplifiers are used to detect the voltage changes on the BIT lines (driven by the inverter loop) as quickly as possible. These analog design issues are outside of the scope of our class.\n\nA number of cells are combined into a bit slice, as shown in the figure. The labels along the bottom of the figure are external inputs to the bit slice, and match the labels for the abstract memory discussed earlier. The bit slice in the figure can be thought of as a 16-address, 1-bit-addressable memory (2^4b). The cells in a bit slice share bit lines and analog read and write logic, which appears to the right in the figure. Based on the ADDR input, a decoder sets one cell's SELECT line high to enable a read or write operation to the cell. The""
 }
]","{
 ""id"": 322
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the benefits of using coincident selection?\n#### Option 1\n-------\nThe benefits of using coincident selection are that it is more efficient in terms of the number of gates required for the decoders, and it also saves on chip area.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe benefits of using coincident selection are that it is more efficient in terms of the number of gates required for the decoders, and it saves chip area.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe benefits of using coincident selection are that it is easier to design and it requires fewer gates. Coincident selection is easier to design because the address of the cell to be read or written is provided to the decoder, which then activates the appropriate cell. This design is simpler than having to provide the address of the cell to be read or written to each individual cell. In addition, coincident selection requires fewer gates because the address of the cell to be read or written is provided to the decoder, which then activates the appropriate cell. This design is more efficient than having to provide the address of the cell to be read or written to each individual cell.""
 }
]","{
 ""id"": 323
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is SRAM used for?\n#### Option 1\n-------\nSRAM is used for high-speed applications such as processor caches and some embedded designs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM is used for high-speed applications such as processor caches and some embedded designs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory is used for high-speed applications such as processor caches and some embedded designs.  As SRAM bit {density---the} number of bits in a given chip {area---is} significantly lower than DRAM bit density, most applications with less demanding speed requirements use DRAM.  The main memory in most computers, for example, is DRAM, whereas the memory on the same chip as a processor is SRAM.{Chips combining both DRAM and processor logic are available, and are used by some processor manufacturers (such  as IBM).  Research is underway to couple such logic types more efficiently by building 3D stacks of chips.}  DRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs.""
 }
]","{
 ""id"": 324
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does an SRAM cell work?\n#### Option 1\n-------\nStatic random access memory is used for high-speed applications\nsuch as processor caches and some embedded designs.  As SRAM bit\ndensity---the number of bits in a given chip area---is\nsignificantly lower than DRAM bit density, most applications with less\ndemanding speed requirements use DRAM.  The main memory in most\ncomputers, for example, is DRAM, whereas the memory on the same chip\nas a processor is SRAM. Chips combining both DRAM and processor\nlogic are available, and are used by some processor manufacturers (such \nas IBM).  Research is underway to couple such logic types more efficiently\nby building 3D stacks of chips.  DRAM is also unavailable\nwhen recharging its capacitors, which can be a problem for\napplications with stringent real-time needs.\n\nA diagram of an SRAM cell (a single bit) appears to\nthe right.  A dual-inverter loop stores the bit, and is connected\nto opposing BIT lines through transistors controlled by a SELECT\nline.  \n\nThe cell works as follows.  When SELECT is high, the\ntransistors connect the inverter loop to the bit lines.  When writing\na cell, the bit lines are held at opposite logic values, forcing the\ninverters to match the values on the lines and storing the value from\nthe BIT input.  When reading a cell, the bit""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe cell works as follows.  When SELECT is high, the transistors connect the inverter loop to the bit lines.  When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input.  When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAn SRAM cell is a type of memory cell that uses a flip-flop to store data. The flip-flop is made up of two transistors, which are connected in a loop. When a bit is stored in the cell, one of the transistors is turned on, and the other is turned off. This creates a current loop that keeps the bit stored in the cell. To read the bit, the transistors are disconnected from the bit lines and the current in the loop is measured. To write a bit, the bit lines are pre-charged and the transistors are turned on or off to create the desired current loop.""
 }
]","{
 ""id"": 325
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How are SRAM cells combined into a bit slice?\n#### Option 1\n-------\nA number of cells are combined into a bit slice, as shown to the right.\\n\\nThe labels along the bottom of the figure are external inputs to the bit slice, and match the labels for the abstract memory discussed earlier. The bit slice in the figure can be thought of as a 16-address, 1-bit-addressable memory (2^4b).\\n\\nThe cells in a bit slice share bit lines and analog read and write logic, which appears to the right in the figure. Based on the ADDR input, a decoder sets one cell's SELECT line high to enable a read or write operation to the cell.\\n\\nThe chip select input CS drives the enable input of the decoder, so none of the memory cells is active when chip select is low (CS=0), and exactly one of the memory cells is active when chip select is high (CS=1).\\n\\nActual bit slices can contain many more cells than are shown in the figure---more cells means less extra logic per cell, but slower memory, since longer wires have higher capacitance.\\n\\nA read operation is performed as follows. We set CS=1 and WE=0, and place the address of the cell to be read on the ADDR input. The decoder outputs a 1 on the appropriate cell's SELECT line, and the read logic reads the bit from the cell and delivers it to its Q output,""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM cells are combined into a bit slice by sharing bit lines and analog read and write logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nSRAM cells are combined into a bit slice by sharing bit lines and analog read and write logic. A read operation is performed by setting CS=1 and WE=0, and placing the address of the cell to be read on the ADDR input. The decoder outputs a 1 on the appropriate cell's SELECT line, and the read logic reads the bit from the cell and delivers it to its Q output, which is then available on the bit slice's DATA-OUT output. For a write operation, CS=1 and WE=1. The address of the cell to be written is placed on the ADDR input and the value of the bit slice's DATA-IN input is set to the value to be written into the memory cell. When the decoder activates the cell's SELECT line, the write logic writes the new value from its D input into the memory cell. Later reads from that cell then produce the new value.""
 }
]","{
 ""id"": 326
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is SRAM used for?\n#### Option 1\n-------\nStatic random access memory is used for high-speed applications such as processor caches and some embedded designs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM is used for high-speed applications such as processor caches and some embedded designs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory is used for high-speed applications such as processor caches and some embedded designs.  As SRAM bit density---the number of bits in a given chip area---is significantly lower than DRAM bit density, most applications with less demanding speed requirements use DRAM.  The main memory in most computers, for example, is DRAM, whereas the memory on the same chip as a processor is SRAM. Chips combining both DRAM and processor logic are available, and are used by some processor manufacturers (such  as IBM).  Research is underway to couple such logic types more efficiently by building 3D stacks of chips.""
 }
]","{
 ""id"": 327
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a SRAM cell work?\n#### Option 1\n-------\nA SRAM cell works by storing a bit in a dual-inverter loop that is connected to opposing BIT lines through transistors controlled by a SELECT line. When SELECT is high, the transistors connect the inverter loop to the bit lines. When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input. When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs. The value stored previously is thus copied onto the BIT line as an output, and the opposite value is placed on the other line. When SELECT is low, the transistors disconnect the inverters from the bit lines, and the cell holds its current value until SELECT goes high again.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA SRAM cell stores a bit using a dual-inverter loop that is connected to opposing BIT lines through transistors controlled by a SELECT line.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWhen a SRAM cell is selected, the transistors in the cell connect the inverters in the cell to the bit lines. This causes the cell to hold its current value. The actual operation of an SRAM cell is more complicated than this, however. For example, when writing a bit, the bit lines can temporarily connect high voltage to ground (a short). The circuit must be designed carefully to minimize the power consumed during this process. When reading a bit, the bit lines are pre-charged halfway between high-voltage and ground, and sense amplifiers are used to detect the voltage changes on the bit lines (driven by the inverter loop) as quickly as possible. These analog design issues are outside of the scope of this class.\n\nA number of cells are combined into a bit slice, as shown in the figure. The labels along the bottom of the figure are external inputs to the bit slice, and match the labels for the abstract memory discussed earlier. The bit slice in the figure can be thought of as a 16-address, 1-bit-addressable memory (2^4b). The cells in a bit slice share bit lines and analog read and write logic, which appears to the right in the figure. Based on the ADDR input, a decoder sets one cell's SELECT line high to enable a read or write operation to the cell. The chip select input CS drives the enable input of the decoder, so none of the memory""
 }
]","{
 ""id"": 328
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the benefits of using coincident selection?\n#### Option 1\n-------\nThe benefits of using coincident selection are that it is more efficient in terms of the number of gates required for the decoders, and it also saves on chip area.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic random access memory is used for high-speed applications such as processor caches and some embedded designs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nSRAM is used for high-speed applications because it is faster than DRAM. A cell in SRAM works by storing a bit in an inverter loop. The inverter loop is connected to a bit line and a select line. When the select line is low, the transistors disconnect the inverters from the bit line, and the cell holds its current value. When the select line is high, the transistors connect the inverters to the bit line, and the cell can be read or written.""
 }
]","{
 ""id"": 329
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the main difference between SRAM and DRAM?\n#### Option 1\n-------\nThe main difference between SRAM and DRAM is that SRAM is used for high-speed applications such as processor caches and some embedded designs while DRAM is used for most applications with less demanding speed requirements.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM is used for high-speed applications while DRAM is used for most other applications.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main difference between SRAM and DRAM is that SRAM uses active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit.""
 }
]","{
 ""id"": 330
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How is a SRAM cell structured?\n#### Option 1\n-------\nA SRAM cell is made up of a dual-inverter loop that is connected to opposing BIT lines through transistors. The transistors are controlled by a SELECT line. The cell works by storing a bit when the SELECT line is high. When the cell is being read, the BIT lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs. The value stored is then copied onto the BIT line as an output. When the SELECT line is low, the transistors disconnect the inverters from the bit lines, and the cell holds its current value.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA SRAM cell is a dual-inverter loop that is connected to opposing BIT lines through transistors controlled by a SELECT line.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe structure of a SRAM cell is based on a dual-inverter loop that is connected to opposing BIT lines through transistors controlled by a SELECT line. When SELECT is high, the transistors connect the inverter loop to the bit lines. When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input. When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs.""
 }
]","{
 ""id"": 331
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the benefits of using a coincident selection scheme for SRAM?\n#### Option 1\n-------\nThe benefits of using a coincident selection scheme for SRAM are that it reduces the number of gates required for the decoders and it saves on chip area.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe benefits of using a coincident selection scheme for SRAM are that it saves on decoder complexity and chip area.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe benefits of using a coincident selection scheme for SRAM are:\n\n1. Reduced gate count: Since the same decoder is used to select both the row and column of the desired cell, fewer gates are required overall.\n\n2. Reduced power consumption: Since the decoder only needs to be activated once to select the desired cell, power consumption is reduced.\n\n3. Increased speed: Since the decoder only needs to be activated once to select the desired cell, the time required to access the desired cell is reduced.""
 }
]","{
 ""id"": 332
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is SRAM used for?\n#### Option 1\n-------\nStatic random access memory is used for high-speed applications such as processor caches and some embedded designs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStatic random access memory is used for high-speed applications such as processor caches and some embedded designs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nSRAM is used for high-speed applications such as processor caches and some embedded designs. As SRAM bit density is significantly lower than DRAM bit density, most applications with less demanding speed requirements use DRAM.""
 }
]","{
 ""id"": 333
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does an SRAM cell work?\n#### Option 1\n-------\nStatic random access memory is used for high-speed applications such as processor caches and some embedded designs. As SRAM bit density\u2014the number of bits in a given chip area\u2014is significantly lower than DRAM bit density, most applications with less demanding speed requirements use DRAM. The main memory in most computers, for example, is DRAM, whereas the memory on the same chip as a processor is SRAM. Chips combining both DRAM and processor logic are available, and are used by some processor manufacturers (such as IBM). Research is underway to couple such logic types more efficiently by building 3D stacks of chips. DRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs.\n\nA diagram of an SRAM cell (a single bit) appears to the right. A dual-inverter loop stores the bit, and is connected to opposing BIT lines through transistors controlled by a SELECT line. \n\nThe cell works as follows. When SELECT is high, the transistors connect the inverter loop to the bit lines. When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input. When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs. \n\nThe value stored previously is thus copied onto the BIT line""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe cell works as follows.  When SELECT is high, the transistors connect the inverter loop to the bit lines.  When writing a cell, the bit lines are held at opposite logic values, forcing the inverters to match the values on the lines and storing the value from the BIT input.  When reading a cell, the bit lines are disconnected from other logic, allowing the inverters to drive the lines with their current outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAn SRAM cell consists of four transistors arranged in a loop. The loop ensures that the cell's output is always the inverse of its input. The cell's output is connected to one of the bit lines, and its input is connected to the other bit line. The cell is selected by a signal called SELECT. When SELECT is low, the transistors disconnect the inverters from the bit lines, and the cell holds its current value until SELECT goes high again. The actual operation of an SRAM cell is more complicated than we have described. For example, when writing a bit, the BIT lines can temporarily connect high voltage to ground (a short). The circuit must be designed carefully to minimize the power consumed during this process. When reading a bit, the BIT lines are pre-charged halfway between high-voltage and ground, and analog devices called sense amplifiers are used to detect the voltage changes on the BIT lines (driven by the inverter loop) as quickly as possible. These analog design issues are outside of the scope of our class.\n\nA number of cells are combined into a bit slice, as shown in the figure. The labels along the bottom of the figure are external inputs to the bit slice, and match the labels for the abstract memory discussed earlier. The bit slice in the figure can be thought of as a 16-address, 1-bit-addressable memory (2^4b). The cells in a bit slice share bit lines and analog""
 }
]","{
 ""id"": 334
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between SRAM and DRAM?\n#### Option 1\n-------\nThe main difference between SRAM and DRAM is that SRAM is faster and more expensive, while DRAM is slower and less expensive. SRAM is used for high-speed applications such as processor caches, while DRAM is used for main memory in most computers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSRAM is faster but uses more power, while DRAM is slower but uses less power.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStatic random access memory (SRAM) is a type of random access memory (RAM) that uses active logic in the form of a two-inverter loop to maintain stored values. SRAM is used for high-speed applications such as processor caches and some embedded designs. \n\nDynamic random access memory (DRAM) is a type of random access memory (RAM) that uses a charged capacitor to store a bit. DRAM is used for applications that do not require high-speed access, such as main memory in most computers. DRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs.""
 }
]","{
 ""id"": 335
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a tri-state buffer?\n#### Option 1\n-------\nThe purpose of a tri-state buffer is to provide a logical disconnection between the memory logic and the output line when the memory is not performing a read. This allows for multiple memories to share the same output line without the need for additional multiplexers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is used to logically disconnect the output of a device from a bus.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. This allows multiple memories to share the same output line without the need for additional multiplexers. Tri-state buffers are also used to reduce the number of pins needed on chips. For example, data inputs and outputs of memory are often combined into a single set of data wires, with bidirectional signals.""
 }
]","{
 ""id"": 336
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can tri-state buffers be used to construct larger memories?\n#### Option 1\n-------\nTri-state buffers can be used to construct larger memories by using multiple chips. In the case shown, two 2^-bit memories are used to implement a 2^{k+1}-bit memory. One of the address bits - in the case shown, the most significant bit - is used to drive a decoder that determines which of the two chips is active (CS=1). The decoder is enabled with the chip select signal for the larger memory, so neither chip is enabled when the external CS is low, as desired. The rest of the address bits, as well as the external data inputs and write enable signal, are simply delivered to both memories. The external data outputs are also connected to both memories. Ensuring that at most one chip select signal is high at any time guarantees that at most one of the two memory chips drives logic values on the data outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nBy using one address bit to drive a decoder that determines which of the two chips is active, multiple chips can be used to construct a larger memory.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nTri-state buffers can be used to construct larger memories by connecting multiple chips together. This allows the same output line to be shared by multiple chips without the need for additional multiplexers. For example, two 2-bit memories can be used to construct a 4-bit memory. One of the address bits is used to drive a decoder that determines which of the two chips is active (CS=1). The decoder is enabled with the chip select signal for the larger memory, so neither chip is enabled when the external CS is low, as desired. The rest of the address bits, as well as the external data inputs and write enable signal, are simply delivered to both memories. The external data outputs are also connected to both memories. This ensures that at most one of the two memory chips drives logic values on the data outputs. Multiple chips can also be used to construct wider memories. For example, two 2-bit memories can be used to construct a 4-bit memory. Both chips are either active or inactive at the same time, so the external address, write enable, and chip select inputs are routed to both chips. In contrast, the data inputs and outputs are separate: the left chip handles the high N bits of input on writes and produces the high N bits of output on reads, while the right chip handles the low N bits of input and produces the low N bits of output.""
 }
]","{
 ""id"": 337
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can tri-state buffers be used to reduce the number of pins needed on a chip?\n#### Option 1\n-------\nTri-state buffers can be used to reduce the number of pins needed on a chip by combining inputs and outputs. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip can drive the data pins with the bits being read (tri-state buffers on the memory chip can be enabled). When performing a write, other logic, such as a processor, can write the value to be stored onto the data pins (tri-state buffers can be disabled).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nTri-state buffers can be used to combine inputs and outputs, reducing the number of pins needed on a chip.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nTri-state buffers can be used to reduce the number of pins needed on a chip by combining inputs and outputs. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 338
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does a tri-state buffer do?\n#### Option 1\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. The buffer achieves this by using a pair of transistors, one to connect the signal to the power supply and the other to connect the signal to ground. When the buffer is enabled, both transistors are turned on and the signal is passed through. When the buffer is disabled, both transistors are turned off and the signal is effectively disconnected.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a logical disconnection achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect an electronic component from a circuit. The two states are known as the high-impedance state and the low-impedance state. In the high-impedance state, the tri-state buffer effectively disconnects the electronic component from the circuit. This is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. In the low-impedance state, the tri-state buffer connects the electronic component to the circuit. This is achieved by using the inner pair of transistors in the logic diagram. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT.""
 }
]","{
 ""id"": 339
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How is a tri-state buffer used to construct larger memories?\n#### Option 1\n-------\nA tri-state buffer is used to construct larger memories by connecting multiple chips together. This allows for the same output line to be shared by multiple memories without the need for additional multiplexers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is used to connect and disconnect the memory logic from the output line when the memory is not performing a read. This allows for multiple memories to be combined without the need for additional multiplexers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is used to construct larger memories by connecting multiple chips together. This allows for the same output line to be shared by more than one memory without the need for additional multiplexers. For example, two 2-bit memories can be used to implement a 4-bit memory. One of the address bits is used to drive a decoder that determines which of the two chips is active (CS=1). The decoder is enabled with the chip select signal for the larger memory, so neither chip is enabled when the external CS is low, as desired. The rest of the address bits, as well as the external data inputs and write enable signal, are simply delivered to both memories. The external data outputs are also connected to both memories. This ensures that at most one of the two memory chips drives logic values on the data outputs.""
 }
]","{
 ""id"": 340
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How is a tri-state buffer used to reduce the number of pins needed on a chip?\n#### Option 1\n-------\nA tri-state buffer is used to reduce the number of pins needed on a chip by combining inputs and outputs. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nBy combining inputs and outputs, the number of pins needed is halved.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is used to reduce the number of pins needed on a chip by combining inputs and outputs. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 341
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a tri-state buffer work?\n#### Option 1\n-------\nA tri-state buffer is a type of logic gate that can be used to either connect or disconnect a signal from a circuit. The buffer has three states: high (1), low (0), and high impedance (Z). The high impedance state effectively disconnects the signal from the circuit, meaning that there is no electrical connection between the tri-state buffer and the output. \n\nThe high and low states are achieved by using a pair of transistors in the logic diagram. When the enable signal is low (EN=0), both transistors turn off, meaning that regardless of the value of the input signal (IN), the output (OUT) is connected neither to high voltage nor to ground. When the enable signal is high (EN=1), both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table. \n\nThe benefit of this logical disconnection is that it allows multiple memories to share the same output line without the need for additional multiplexers. Memory chips can be combined in this way to produce larger memories. For example, two 2^k-bit memories can be used to implement a 2^(k+1)-bit memory. Alternatively, multiple chips can be used to construct wider memories. For example, two 2^k-bit memories can be used to implement a 2^(2k)-""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a logical disconnection achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. The tri-state buffer has three possible states: high impedance (the buffer is effectively disconnected), 0 (the buffer is connected to ground), or 1 (the buffer is connected to the power supply). The tri-state buffer is controlled by an enable signal. When the enable signal is low, the tri-state buffer is in the high impedance state. When the enable signal is high, the tri-state buffer copies the input signal to the output. The tri-state buffer is often used to share a signal line between multiple devices. For example, a tri-state buffer can be used to connect a data line from a memory chip to an input/output (I/O) port on a microprocessor. By using a tri-state buffer, multiple memory chips can share the same data line.""
 }
]","{
 ""id"": 342
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a tri-state buffer?\n#### Option 1\n-------\nThe purpose of a tri-state buffer is to provide a logical disconnection between the memory logic and the output line when the memory is not performing a read. This allows for multiple memories to share the same output line without the need for additional multiplexers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is used to logically disconnect the output of a device from a bus.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. This allows multiple memory chips to share the same output line without the need for additional multiplexers. Tri-state buffers are also used to reduce the number of pins needed on chips. For example, data inputs and outputs of memory are often combined into a single set of data wires, with bidirectional signals.""
 }
]","{
 ""id"": 343
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can tri-state buffers be used to reduce the number of pins needed on a chip?\n#### Option 1\n-------\nTri-state buffers can be used to reduce the number of pins needed on a chip by combining inputs and outputs. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nTri-state buffers can be used to reduce the number of pins needed on a chip by combining inputs and outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nTri-state buffers can be used to reduce the number of pins needed on a chip by combining inputs and outputs. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 344
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a tri-state buffer?\n#### Option 1\n-------\nA tri-state buffer is a type of digital logic gate that is used to disconnect the output of a digital circuit from its input. This is achieved by using a pair of transistors, one of which is used to connect the output to ground, and the other of which is used to connect the output to the power supply. When the tri-state buffer is not enabled, both transistors are turned off, and the output is effectively disconnected from both the power supply and ground. When the tri-state buffer is enabled, both transistors are turned on, and the output is connected to either the power supply or ground, depending on the input.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a logical disconnection achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is an electronic circuit that can be used to either connect or disconnect a signal from a circuit. The signal can be either an input or an output. The circuit is designed such that when the buffer is enabled, the signal is passed through (i.e. the input is connected to the output), and when the buffer is disabled, the signal is disconnected (i.e. the input is disconnected from the output).\n\nThe main use of a tri-state buffer is to reduce the number of pins needed on a chip. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 345
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a tri-state buffer function?\n#### Option 1\n-------\nA tri-state buffer is a type of logic gate that can be used to disconnect a circuit from an output line. The buffer has three states: high, low, and high impedance. High impedance means that there is effectively no electrical connection between the buffer and the output line. \n\nThe high and low states function like a pair of back-to-back inverters, copying the signal from the input to the output. The high impedance state is achieved by using the outer pair of transistors in the logic diagram. When the enable signal is low, both transistors turn off, meaning that regardless of the value of the input, the output is connected neither to high voltage nor to ground. \n\nThe tri-state buffer is used to disconnect the memory logic from the output line when the memory is not performing a read. This allows multiple memories to share the same output line without the need for additional multiplexers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a logical disconnection achieved by using the outer transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. The logical disconnection is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table. \n\nThe main benefit of using a tri-state buffer is that it can be used to reduce the number of pins needed on a chip. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 346
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a tri-state buffer?\n#### Option 1\n-------\nThe purpose of a tri-state buffer is to provide a logical disconnection between the memory logic and the output line when the memory is not performing a read. This allows for the same output line to be shared by multiple memories without the need for additional multiplexers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is used to logically disconnect the memory logic from the output line when the memory is not performing a read.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a type of digital circuit that is used to either connect or disconnect a signal from a circuit. The purpose of a tri-state buffer is to provide a logical disconnection between the buffer and the output signal. This is achieved by using two transistors in the logic diagram. When the enable signal is low, both transistors are turned off, and the output signal is disconnected from the circuit. When the enable signal is high, both transistors are turned on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from the input to the output. \n\nTri-state buffers are often used to reduce the number of pins needed on a chip. For example, data inputs and outputs of memory chips can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled). \n\nMultiple chips can also be used to construct wider memories. For example, two memory chips can be used to implement a 32-bit memory. Both chips are either active or inactive at the same time, so the external address, write enable, and chip select inputs are routed to both""
 }
]","{
 ""id"": 347
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is a tri-state buffer?\n#### Option 1\n-------\nA tri-state buffer is a type of digital logic circuit that can be used to either connect or disconnect a signal line from a power supply or ground. The circuit achieves this by using a pair of transistors, one of which is used to connect the signal line to the power supply, and the other of which is used to connect the signal line to ground. When the circuit is turned off, both transistors are turned off, effectively disconnecting the signal line from both the power supply and ground. When the circuit is turned on, one of the transistors is turned on, depending on the value of the input signal, which then either connects the signal line to the power supply (for a logic 1 input) or ground (for a logic 0 input).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a logical disconnection that is achieved by using the outer transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. The logical disconnection is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table. \n\nThe main benefit of using a tri-state buffer is that it can reduce the number of pins needed on a chip. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 348
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What does a tri-state buffer do?\n#### Option 1\n-------\nA tri-state buffer is used to disconnect the memory logic from the output line when the memory is not performing a read. This logical disconnection is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a logic gate that disconnects the memory logic from the output line when the memory is not performing a read.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. This is achieved by using two transistors, one to connect the signal line to the power supply, and the other to connect the signal line to ground. When the enable signal is low, both transistors are turned off, effectively disconnecting the signal line from both the power supply and ground. When the enable signal is high, one of the transistors is turned on, depending on the value of the input signal. If the input signal is low, the transistor connected to the power supply is turned on, and the signal line is pulled up to the power supply voltage. If the input signal is high, the transistor connected to ground is turned on, and the signal line is pulled down to ground voltage. This allows the same signal line to be shared by multiple devices without the need for additional multiplexers.""
 }
]","{
 ""id"": 349
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How does a tri-state buffer work?\n#### Option 1\n-------\nA tri-state buffer is a type of digital logic circuit that is used to either connect or disconnect a signal line from a power source. The circuit is designed such that it can be used to connect or disconnect the signal line from the power source with the help of an enable signal. The enable signal is used to control the circuit, and when it is active, the signal line is connected to the power source. When the enable signal is inactive, the signal line is disconnected from the power source. The tri-state buffer is a type of digital logic circuit that is used to either connect or disconnect a signal line from a power source. The circuit is designed such that it can be used to connect or disconnect the signal line from the power source with the help of an enable signal. The enable signal is used to control the circuit, and when it is active, the signal line is connected to the power source. When the enable signal is inactive, the signal line is disconnected from the power source. \n\nThe tri-state buffer is a type of digital logic circuit that is used to either connect or disconnect a signal line from a power source. The circuit is designed such that it can be used to connect or disconnect the signal line from the power source with the help of an enable signal. The enable signal is used to control the circuit, and when it is active, the signal line is connected to the power source. When the enable signal is inactive, the signal line is disconnected from the""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a device that can disconnect a circuit from an output line. This is achieved by using two transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to improve the performance of a system by providing a logical disconnection between the tri-state buffer and the output. This logical disconnection is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table.\n\nThe main benefit of using a tri-state buffer is that it can reduce the number of pins needed on a chip. By combining inputs and outputs, chip designers are able to halve the number of pins needed. For example, data inputs and outputs of memory are often combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 350
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a tri-state buffer work?\n#### Option 1\n-------\nA tri-state buffer is a type of digital logic circuit that is used to either connect or disconnect a signal line from a power supply or other signal source. The name \u201ctri-state buffer\u201d comes from the fact that the output of the circuit can be in one of three states: high (1), low (0), or high impedance (Z). The high impedance state effectively disconnects the output from the signal line. \n\nThe figure below shows a basic implementation diagram for a tri-state buffer, along with the symbolic form and a truth table. The \u201cZ\u201d in the truth table output means high impedance (and is sometimes written \u201chi-Z\u201d). \n\n\n\nfile=part3/figs/tri-state.eps,width=3in\n\nEN& IN& OUT \n0& x& Z\n1& 0& 0\n1& 1& 1\n\nThe high impedance state is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. \n\nWhen EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table. \n\nSo long as only one memory""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a pair of back-to-back inverters that copies the signal from IN to OUT when EN=1. When EN=0, the transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a type of digital logic device that is used to either connect or disconnect a signal line from a power supply or ground. The device has three states: high, low, and high impedance (written \""hi-Z\""). In the hi-Z state, the signal line is effectively disconnected from both the power supply and ground. This state is achieved by using the outer pair of transistors in the logic diagram. When the enable signal (EN) is low, both transistors are turned off, meaning that regardless of the value of the input signal (IN), the output signal (OUT) is neither connected to the power supply nor to ground. When EN is high, both transistors are turned on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table.\n\nThe hi-Z state is useful in applications where multiple memory chips are used to construct a larger memory. By ensuring that only one chip select input is high at any time, the same output line can be shared by more than one memory without the need for additional multiplexers. Memory chips were often combined in this way to produce larger memories.\n\nTri-state buffers were also historically used to reduce the number of pins needed on chips. By combining inputs and outputs, chip designers were able to halve the number of pins needed. For example, data inputs and outputs""
 }
]","{
 ""id"": 351
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a tri-state buffer?\n#### Option 1\n-------\nThe purpose of a tri-state buffer is to provide a logical disconnection between the memory logic and the output line when the memory is not performing a read. This allows for multiple memories to share the same output line without the need for additional multiplexers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is used to logically disconnect the output of a device from a bus.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a type of digital logic device that is used to either connect or disconnect a signal line from a power supply or ground. This is achieved by using transistors to control the connection. When the buffer is enabled (EN=1), the transistors are turned on and the signal line is connected to the power supply or ground. When the buffer is disabled (EN=0), the transistors are turned off and the signal line is effectively disconnected from the power supply or ground.\n\nTri-state buffers are used in a variety of applications, such as memory chips, where they are used to multiplex multiple memory chips onto a single output line. This allows for larger memories to be constructed from smaller chips. Tri-state buffers can also be used to reduce the number of pins needed on a chip. For example, data inputs and outputs on memory chips are often combined into a single set of data wires, with bidirectional signals. When the chip is being read, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When the chip is being written to, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 352
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How would you use a tri-state buffer to reduce the number of pins needed on a chip?\n#### Option 1\n-------\nOne way to use a tri-state buffer to reduce the number of pins needed on a chip is to combine inputs and outputs. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. This reduces the number of pins needed for data input and output by half.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nTri-state buffers can be used to combine inputs and outputs, reducing the number of pins needed on a chip.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer can be used to reduce the number of pins needed on a chip by combining inputs and outputs. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 353
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a tri-state buffer?\n#### Option 1\n-------\nThe purpose of a tri-state buffer is to provide a logical disconnection between the memory logic and the output line when the memory is not performing a read. This allows for multiple memories to share the same output line without the need for additional multiplexers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is used to logically disconnect the memory logic from the output line when the memory is not performing a read.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. This logical disconnection is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table. \n\nThe purpose of a tri-state buffer is to provide a way to either connect or disconnect a signal line from a power supply or ground. This can be useful in situations where multiple memories need to share the same output line, as only one memory's chip select input needs to be high at any time. Tri-state buffers can also be used to reduce the number of pins needed on a chip, as data inputs and outputs can be combined into a single set of wires.""
 }
]","{
 ""id"": 354
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How do tri-state buffers enable multiple memories to share the same output line?\n#### Option 1\n-------\nTri-state buffers enable multiple memories to share the same output line by allowing the output of one memory to be disconnected from the output line when the memory is not performing a read. This logical disconnection is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nTri-state buffers provide a logical disconnection, so that when one memory's chip select input is high, the other memories are disconnected from the output line.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nTri-state buffers enable multiple memories to share the same output line by providing a logical disconnection between the tri-state buffer and the output. This logical disconnection is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table.""
 }
]","{
 ""id"": 355
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How are tri-state buffers used to reduce the number of pins needed on a chip?\n#### Option 1\n-------\nBy combining inputs and outputs, chip designers were able to halve the number of pins needed.  For example, data inputs and outputs of memory were often combined into a single set of data wires, with bidirectional signals.  When performing a read from a memory chip, the memory chip drove the data pins with the bits being read (tri-state buffers on the memory chip were enabled).  When performing a write, other logic such as a processor wrote the value to be stored onto the data pins (tri-state buffers were not enabled).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nTri-state buffers are used to reduce the number of pins needed on a chip by combining inputs and outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nTri-state buffers can be used to reduce the number of pins needed on a chip by combining inputs and outputs. For example, data inputs and outputs of memory can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 356
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a tri-state buffer?\n#### Option 1\n-------\nA tri-state buffer is a type of digital logic circuit that is used to achieve logical disconnection between a memory and an output line. This is done by using two transistors in the logic diagram, which act as a pair of back-to-back inverters. When the tri-state buffer is not enabled, both transistors are turned off, meaning that the output is not connected to either high voltage or ground. When the tri-state buffer is enabled, both transistors are turned on and the tri-state buffer copies the signal from the input to the output. Tri-state buffers are often used in order to construct larger memories by combining multiple chips. This is done by using one address bit to drive a decoder that determines which chip is active. The chip select signal for the larger memory is then used to enable the decoder. The rest of the address bits, as well as the external data inputs and write enable signal, are delivered to both memories. The external data outputs are also connected to both memories. By ensuring that only one chip select signal is high at a time, it is guaranteed that only one of the two memory chips will drive logic values on the data outputs. Tri-state buffers can also be used to reduce the number of pins needed on a chip. This is done by combining inputs and outputs, which halves the number of pins needed. For example, data inputs and outputs of memory are often combined into a single set of data wires, with bid""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a logical disconnection achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal from a circuit. The buffer has three states: high, low, and high impedance (hi-Z). The high and low states correspond to the signal being either connected or disconnected from the circuit, respectively. The hi-Z state effectively disconnects the signal from the circuit, meaning that there is effectively no electrical connection between the tri-state buffer and the output. This logical disconnection is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table. \n\nThe main benefit of using a tri-state buffer is that it allows for multiplexing of signals. This means that a single signal can be shared by multiple circuits without the need for additional multiplexers. For example, memory chips can be combined in this way to produce larger memories. The figure to the right illustrates how larger memories can be constructed using multiple chips. In the case shown, two {2^-bit}  memories are used to implement a {2^{k+1}-bit} memory. One""
 }
]","{
 ""id"": 357
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a tri-state buffer work?\n#### Option 1\n-------\nA tri-state buffer is a type of digital logic circuit that is used to either connect or disconnect a signal line from a power supply or other signal source. The name \""tri-state\"" comes from the fact that the output of the circuit can be in one of three states: high (1), low (0), or high impedance (Z). The high impedance state effectively disconnects the output from the signal line, allowing other devices to drive the line. \n\nThe basic operation of a tri-state buffer is controlled by an enable signal. When the enable signal is low (0), the tri-state buffer is disabled and the output is in the high impedance state. When the enable signal is high (1), the tri-state buffer is enabled and the output will be either high or low, depending on the input signal. \n\nThe figure to the right illustrates the basic operation of a tri-state buffer. The enable signal is applied to the gate of an N-channel MOSFET transistor. When the enable signal is low, the transistor is turned off and the output is in the high impedance state. When the enable signal is high, the transistor is turned on and the output will follow the input signal. \n\n{file=part3/figs/tri-state.eps,width=3in}\n\n{cc|c}\nEN& IN& OUT \n0& x& Z\n1& 0& 0""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a logical disconnection achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that acts as either a digital signal repeater or an open circuit, depending on the value of an enable signal. When the enable signal is low, the tri-state buffer acts as a digital signal repeater, copying the value of an input signal to an output signal. When the enable signal is high, the tri-state buffer acts as an open circuit, effectively disconnecting the input signal from the output signal.\n\nThe tri-state buffer is often used to share a single output line among multiple memory chips. When only one memory chip's chip select input is high at a time, the same output line can be shared by multiple memory chips without the need for additional multiplexers. This allows for larger memories to be constructed from multiple smaller memory chips.\n\nThe tri-state buffer can also be used to reduce the number of pins needed on a chip. By combining inputs and outputs, chip designers can halve the number of pins needed. For example, data inputs and outputs of memory chips can be combined into a single set of data wires, with bidirectional signals. When performing a read from a memory chip, the memory chip drives the data pins with the bits being read (tri-state buffers on the memory chip are enabled). When performing a write, other logic such as a processor writes the value to be stored onto the data pins (tri-state buffers are not enabled).""
 }
]","{
 ""id"": 358
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a tri-state buffer?\n#### Option 1\n-------\nThe purpose of a tri-state buffer is to provide a logical disconnection between the memory logic and the output line when the memory is not performing a read. This allows for the same output line to be shared by multiple memories without the need for additional multiplexers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is used to logically disconnect the memory logic from the output line when the memory is not performing a read.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal from a circuit. The purpose of a tri-state buffer is to provide a logical disconnection between the buffer and the output signal. This is achieved by using two transistors in the logic diagram. When one transistor is turned on, the other transistor is turned off, and vice versa. This ensures that only one signal is active at any given time. Tri-state buffers are often used to construct larger memories by combining multiple chips. This allows the same output line to be shared by more than one memory without the need for additional multiplexers.""
 }
]","{
 ""id"": 359
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a tri-state buffer work?\n#### Option 1\n-------\nA tri-state buffer is a type of digital logic circuit that is used to either connect or disconnect a signal line from a power supply or ground. The buffer gets its name from the fact that it has three states: active, inactive, and high impedance. The active state is when the buffer is connected to the power supply or ground, the inactive state is when the buffer is disconnected, and the high impedance state is when the buffer is neither connected nor disconnected. \n\nThe high impedance state is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table. \n\nThe benefit of this logical disconnection is that it allows multiple memories to share the same output line without the need for additional multiplexers. Memory chips were often combined in this way to produce larger memories. \n\nMultiple chips can also be used to construct wider memories. In the case shown in the figure, two 2^-bit memories are used to implement a 2^-bit memory. Both chips are either active or inactive at the same time, so the external address, write enable, and chip select inputs""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is a logical disconnection achieved by using the outer transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. The tri-state buffer has three states: high, low, and high impedance (written \""hi-Z\""). In the high state, the signal line is connected to the power supply. In the low state, the signal line is connected to ground. In the high impedance state, the signal line is effectively disconnected from both the power supply and ground. This logical disconnection is achieved by using the outer pair of transistors in the logic diagram. When the enable signal (EN) is low, both transistors are turned off, meaning that regardless of the value of the input signal (IN), the output signal (OUT) is connected neither to the power supply nor to ground. When EN is high, both transistors are turned on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table.\n\nThe benefit of this logical disconnection is that it allows a single signal line to be shared by multiple devices without the need for additional multiplexers. For example, memory chips can be combined in this way to produce larger memories. The figure to the right illustrates how larger memories can be constructed using multiple chips. In the case shown, two 2-bit memories are used to implement a 4-bit memory. One of the""
 }
]","{
 ""id"": 360
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a tri-state buffer?\n#### Option 1\n-------\nThe purpose of a tri-state buffer is to provide a logical disconnection between the memory logic and the output line when the memory is not performing a read. This allows for multiple memories to share the same output line without the need for additional multiplexers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is used to logically disconnect the memory logic from the output line when the memory is not performing a read.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA tri-state buffer is a digital circuit that can be used to either connect or disconnect a signal line from a power supply or ground. When the buffer is enabled (EN=1), it acts as a pair of back-to-back inverters, copying the signal from IN to OUT. When the buffer is disabled (EN=0), the signal line is effectively disconnected from both the power supply and ground. This allows multiple memories to share the same output line without the need for additional multiplexers.""
 }
]","{
 ""id"": 361
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" When would you use a tri-state buffer?\n#### Option 1\n-------\nA tri-state buffer is used to disconnect the memory logic from the output line when the memory is not performing a read. This logical disconnection is achieved by using the outer pair of transistors in the logic diagram. When EN=0, both transistors turn off, meaning that regardless of the value of IN, OUT is connected neither to high voltage nor to ground. When EN=1, both transistors turn on, and the tri-state buffer acts as a pair of back-to-back inverters, copying the signal from IN to OUT, as shown in the truth table.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA tri-state buffer is used to logically disconnect the output of a device from a bus.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nTri-state buffers are used in a variety of applications, including:\n\n- Memory chips: Tri-state buffers are used to implement larger memories by combining multiple chips. This allows the same output line to be shared by multiple chips without the need for additional multiplexers.\n\n- Wider memories: Tri-state buffers can be used to construct wider memories by combining multiple chips. This allows the data inputs and outputs to be separate, which reduces the number of pins needed.\n\n- Reducing the number of pins needed: Tri-state buffers can also be used to reduce the number of pins needed on a chip. This is because they can be used to combine inputs and outputs, which reduces the number of pins needed.""
 }
]","{
 ""id"": 362
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is DRAM used for?\n#### Option 1\n-------\nDRAM is used for main memory in computers and for other applications in which size is more important than speed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nDRAM is used for main memory in computers and for other applications in which size is more important than speed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nDynamic random access memory (DRAM) is used for applications that require high-speed data access, such as processor caches and some embedded designs. DRAM is also used for main memory in most computers, as it has a higher bit density than static random access memory (SRAM). DRAM is also unavailable when recharging its capacitors, which can be a problem for applications with stringent real-time needs.""
 }
]","{
 ""id"": 363
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a DRAM cell work?\n#### Option 1\n-------\nA DRAM cell stores a bit by charging or not charging a capacitor. The capacitor is attached to a BIT line through a transistor controlled by a SELECT line. When SELECT is low, the capacitor is isolated and holds its charge. However, the transistor's resistance is finite, and some charge leaks out onto the bit line. Charge also leaks into the substrate on which the transistor is constructed. After some amount of time, all of the charge dissipates, and the bit is lost. To avoid such loss, the cell must be refreshed periodically by reading the contents and writing them back with active logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA DRAM cell is a capacitor that stores a charge to represent a 0 or 1. The capacitor is attached to a bit line through a transistor. When the transistor is turned on, the capacitor is charged or discharged, depending on the value being written.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA DRAM cell stores a bit by charging or not charging a capacitor. The capacitor is attached to a bit line through a transistor controlled by a select line. When the select line is low, the capacitor is isolated and holds its charge. However, the transistor's resistance is finite, and some charge leaks out onto the bit line. Charge also leaks into the substrate on which the transistor is constructed. After some amount of time, all of the charge dissipates, and the bit is lost. To avoid such loss, the cell must be refreshed periodically by reading the contents and writing them back with active logic.\n\nWhen the select line is high during a write operation, logic driving the bit line forces charge onto the capacitor or removes all charge from it. For a read operation, the bit line is first brought to an intermediate voltage level, then the select line is raised, allowing the capacitor to either pull a small amount of charge from the bit line or to push a small amount of charge onto the bit line. The resulting change in voltage is then detected by a sense amplifier at the end of the bit line.\n\nA sense amplifier is analogous to a marble on a mountaintop: a small push causes the marble to roll rapidly downhill in the direction of the push. Similarly, a small change in voltage causes a sense amplifier's output to move rapidly to a logical 0 or 1, depending on the direction of the small change. Sense amplifiers also appear in SRAM implementations""
 }
]","{
 ""id"": 364
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the inputs and outputs of a DRAM chip?\n#### Option 1\n-------\nThe inputs and outputs of a DRAM chip are the address pins, the data pins, the row address strobe (RAS), the column address strobe (CAS), the output enable (OE), and the write enable (WE).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe inputs of a DRAM chip are the row address, the column address, RAS, CAS, WE, and OE. The outputs of a DRAM chip are the data pins.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe inputs and outputs of a DRAM chip are the address pins, the data pins, the row address strobe (RAS), the column address strobe (CAS), the output enable (OE), and the write enable (WE).""
 }
]","{
 ""id"": 365
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is DRAM?\n#### Option 1\n-------\nDRAM is a type of random access memory that is used for main memory in computers and other applications where size is more important than speed. DRAM is slower than SRAM but denser, meaning that it can store more bits per chip area. A large part of DRAM density is due to transistor count: typical SRAM cells use six transistors while DRAM cells use only one. However, memory designers have also made significant advances in miniaturizing DRAM cells to improve density beyond the benefit available from simple transistor count.\\n \nDRAM storage is capacitive, meaning that a bit is stored by charging or not charging a capacitor. The capacitor is attached to a bit line through a transistor controlled by a select line. When the select line is low, the capacitor is isolated and holds its charge. However, the transistor's resistance is finite, and some charge leaks out onto the bit line. Charge also leaks into the substrate on which the transistor is constructed. After some amount of time, all of the charge dissipates, and the bit is lost. To avoid such loss, the cell must be refreshed periodically by reading the contents and writing them back with active logic.\\n \nEach read operation on a DRAM cell brings the voltage on its capacitor closer to the intermediate voltage level, in effect destroying the data in the cell. DRAM is thus said to have destructive reads. To preserve data during a read, the bits must be written back into the cells after""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nDynamic random access memory, or DRAM, is a type of main memory used in computers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nDynamic random access memory (DRAM) is a type of random access memory that stores data in a capacitor. The capacitor can be charged or discharged; when the capacitor is charged, it represents a 1, and when it is discharged, it represents a 0. DRAM is volatile, which means that it will lose its data when the power is turned off.""
 }
]","{
 ""id"": 366
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between SRAM and DRAM?\n#### Option 1\n-------\nSRAM is faster than DRAM, but DRAM is denser (has more bits per chip area). A substantial part of DRAM density is due to transistor count: typical SRAM cells use six transistors (two for each inverter, and two more to connect the inverters to the bit lines), while DRAM cells use only a single transistor.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nDRAM is denser and slower than SRAM, and uses a single transistor per cell.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main difference between SRAM and DRAM is that SRAM is a static memory while DRAM is a dynamic memory. SRAM employs active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit. As a result, SRAM is faster and more expensive than DRAM. SRAM is also less dense than DRAM, meaning that more SRAM chips are required to store the same amount of data as DRAM.""
 }
]","{
 ""id"": 367
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How do you refresh a DRAM cell?\n#### Option 1\n-------\nTo refresh a DRAM cell, you must first read the contents of the cell and then write the data back into the cell. This can be done by using the output of the sense amplifiers to drive the bit lines and rewrite the cells with the appropriate data.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nDRAM is refreshed by reading the contents and writing them back with active logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main difference between DRAM and SRAM is that DRAM is denser. This is due to the fact that DRAM cells use only a single transistor, while SRAM cells use six transistors. DRAM is also slower than SRAM.""
 }
]","{
 ""id"": 368
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the main difference between DRAM and SRAM?\n#### Option 1\n-------\nThe main difference between DRAM and SRAM is that DRAM is denser (has more bits per chip area) than SRAM. A substantial part of DRAM density is due to transistor count: typical SRAM cells use six transistors (two for each inverter, and two more to connect the inverters to the bit lines), while DRAM cells use only a single transistor. However, memory designers have also made significant advances in further miniaturizing DRAM cells to improve density beyond the benefit available from simple transistor count.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nDRAM is slower than SRAM, but denser (has more bits per chip area).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main difference between DRAM and SRAM is that SRAM uses active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit.""
 }
]","{
 ""id"": 369
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a DRAM cell work?\n#### Option 1\n-------\nA DRAM cell stores data by charging or not charging a capacitor. The capacitor is attached to a bit line through a transistor controlled by a select line. When the select line is low, the capacitor is isolated and holds its charge. However, the transistor's resistance is finite, and some charge leaks out onto the bit line. Charge also leaks into the substrate on which the transistor is constructed. After some amount of time, all of the charge dissipates, and the bit is lost. To avoid such loss, the cell must be refreshed periodically by reading the contents and writing them back with active logic.\n\nWhen the select line is high during a write operation, logic driving the bit line forces charge onto the capacitor or removes all charge from it. For a read operation, the bit line is first brought to an intermediate voltage level (a voltage level between 0 and 1), then select is raised, allowing the capacitor to either pull a small amount of charge from the bit line or to push a small amount of charge onto the bit line. The resulting change in voltage is then detected by a sense amplifier at the end of the bit line.\n\nEach read operation on a DRAM cell brings the voltage on its capacitor closer to the intermediate voltage level, in effect destroying the data in the cell. DRAM is thus said to have destructive reads. To preserve data during a read, the bits must be written back into the cells after a read. \n\nAt the chip level""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA DRAM cell stores a bit by charging or not charging a capacitor, which is attached to a bit line through a transistor.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA DRAM cell stores a bit by charging or not charging a capacitor. The capacitor is attached to a bit line through a transistor controlled by a select line. When the select line is low, the capacitor is isolated and holds its charge. However, the transistor's resistance is finite, and some charge leaks out onto the bit line. Charge also leaks into the substrate on which the transistor is constructed. After some amount of time, all of the charge dissipates, and the bit is lost. To avoid such loss, the cell must be refreshed periodically by reading the contents and writing them back with active logic.\n\nWhen the select line is high during a write operation, logic driving the bit line forces charge onto the capacitor or removes all charge from it. For a read operation, the bit line is first brought to an intermediate voltage level, then the select line is raised, allowing the capacitor to either pull a small amount of charge from the bit line or to push a small amount of charge onto the bit line. The resulting change in voltage is then detected by a sense amplifier at the end of the bit line.\n\nEach read operation on a DRAM cell brings the voltage on its capacitor closer to the intermediate voltage level, in effect destroying the data in the cell. DRAM is thus said to have destructive reads. To preserve data during a read, the bits must be written back into the cells after a read.\n\nAt the chip level, typical DRAM inputs and""
 }
]","{
 ""id"": 370
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a sense amplifier in DRAM?\n#### Option 1\n-------\nThe sense amplifier is used to detect small changes in voltage in order to read data from the DRAM cell. The sense amplifier is analogous to a marble on a mountaintop: a small push causes the marble to roll rapidly downhill in the direction of the push. Similarly, a small change in voltage causes a sense amplifier's output to move rapidly to a logical 0 or 1, depending on the direction of the small change.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA sense amplifier is used to read the data stored in a DRAM cell.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA sense amplifier is used to read the contents of a DRAM cell. The sense amplifier amplifies the small changes in voltage that occur when the capacitor in the DRAM cell is charged or discharged. This allows the DRAM cell to be read without destroying the data in the cell.""
 }
]","{
 ""id"": 371
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the main difference between SRAM and DRAM?\n#### Option 1\n-------\nThe main difference between SRAM and DRAM is that SRAM is faster but more expensive, while DRAM is slower but cheaper.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nDRAM is denser than SRAM, meaning it can hold more bits per chip area.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main difference between SRAM and DRAM is that SRAM uses active logic in the form of a two-inverter loop to maintain stored values, while DRAM uses a charged capacitor to store a bit.""
 }
]","{
 ""id"": 372
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a DRAM cell store data?\n#### Option 1\n-------\nA DRAM cell stores data by charging or not charging a capacitor. The capacitor is attached to a BIT line through a transistor controlled by a SELECT line. When SELECT is low, the capacitor is isolated and holds its charge. However, the transistor's resistance is finite, and some charge leaks out onto the bit line. Charge also leaks into the substrate on which the transistor is constructed. After some amount of time, all of the charge dissipates, and the bit is lost. To avoid such loss, the cell must be refreshed periodically by reading the contents and writing them back with active logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA DRAM cell stores data by charging or not charging a capacitor.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA DRAM cell stores data by charging or not charging a capacitor. The capacitor is attached to a BIT line through a transistor controlled by a SELECT line. When SELECT is low, the capacitor is isolated and holds its charge. However, the transistor's resistance is finite, and some charge leaks out onto the bit line. Charge also leaks into the substrate on which the transistor is constructed. After some amount of time, all of the charge dissipates, and the bit is lost. To avoid such loss, the cell must be refreshed periodically by reading the contents and writing them back with active logic.""
 }
]","{
 ""id"": 373
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a sense amplifier in DRAM?\n#### Option 1\n-------\nA sense amplifier is used in DRAM to detect small changes in voltage and convert them into a logical 0 or 1. This allows for faster reads of data from the DRAM cells.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA sense amplifier is used to read the data stored in a DRAM cell. The data in a DRAM cell is read by first bringing the bit line to an intermediate voltage level, then raising the SELECT line. This allows the capacitor to either pull a small amount of charge from the bit line or to push a small amount of charge onto the bit line. The resulting change in voltage is then detected by the sense amplifier.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe sense amplifier is used to detect small changes in voltage on the bit line, which allows the DRAM cell to be read without destroying the data. The DRAM cell is refreshed by reading the contents and writing them back with active logic. The difference between SRAM and DRAM is that SRAM is volatile and DRAM is not.""
 }
]","{
 ""id"": 374
}"
