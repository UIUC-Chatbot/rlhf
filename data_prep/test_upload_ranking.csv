attachments_json,metadata
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a finite state machine?\n#### Option 1\n-------\nA finite state machine is a mathematical model of computation that can be used to design digital logic circuits. It consists of a set of states, a set of transitions between those states, and a set of outputs. The state machine can be in only one state at a time; it can change from one state to another only when triggered by an input event or condition.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA finite state machine (FSM) is a mathematical model of computation used to design both computer programs and sequential logic circuits. It is conceived as an abstract machine that can be in one of a finite number of user-specified states. An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA finite state machine is a model of computation used to design digital logic circuits.""
 }
]","{
 ""id"": 1
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the basic steps of designing a finite state machine?\n#### Option 1\n-------\nThe basic steps of designing a finite state machine are to first develop an abstract model, then create functions for the next-state variables and output signals, and finally to implement the design using flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe basic steps of designing a finite state machine are as follows: \\n\n1) Develop an abstract model of the system \\n\n2) Translate the abstract model into a concrete implementation \\n\n3) Initialize the FSM \\n\n4) Choose a representation for the FSM's internal state \\n""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe basic steps of designing a finite state machine are developing an abstract model, implementing functions for the next-state variables and output signals, and translating a concrete and complete state transition diagram into an implementation based on flip-flops and logic gates.""
 }
]","{
 ""id"": 2
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is an example of a design that is more intuitive and easier for humans to understand?\n#### Option 1\n-------\nA counter with a number of states that is not a power of two.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA design that is more intuitive and easier for humans to understand is one that uses a representation for the FSM's internal state that is easy to understand. For example, a design that uses a binary representation for the internal state is easier to understand than a design that uses a hexadecimal representation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process as a whole through a more general example of a counter with multiple inputs to control its behavior.""
 }
]","{
 ""id"": 3
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the design process for a digital FSM?\n#### Option 1\n-------\nThe design process for a digital FSM is a process of translating a concrete and complete state transition diagram into an implementation based on flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for a digital FSM typically begins with the development of an abstract model. \nThis model is then used to determine the function of the next-state variables and output signals. \nFinally, the design is implemented using flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 }
]","{
 ""id"": 4
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is an example of a counter with a number of states that is not a power of two?\n#### Option 1\n-------\nA counter with a number of states that is not a power of two is an example of a counter with a number of states that is not a power of two.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nOur first example is of a counter with four states, which is not a power of two. In this case, we need to initialize the FSM to one of the four states. We can do this by using a multiplexer to select the initial state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA counter with a number of states that is not a power of two is an example of a counter that needs FSM initialization.""
 }
]","{
 ""id"": 5
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the general form of selection logic called a multiplexer?\n#### Option 1\n-------\nThe general form of selection logic is called a multiplexer.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA multiplexer is a general form of selection logic that allows for the implementation of a counter with multiple inputs to control its behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA multiplexer is a general form of selection logic.""
 }
]","{
 ""id"": 6
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to have a clear understanding of the abstract model when designing a FSM?\n#### Option 1\n-------\nBecause if you don't have a clear understanding of the abstract model, you won't be able to design a FSM that is easy for humans to understand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA clear understanding of the abstract model is important when designing a FSM because it allows the designer to make decisions about how to simplify the implementation. For example, if the abstract model includes multiple inputs that control the behavior of the FSM, the designer can choose to represent the internal state of the FSM in a way that makes it easier to understand and implement.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA clear understanding of the abstract model is necessary in order to simplify the implementation.""
 }
]","{
 ""id"": 7
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the choice of representation for the FSM's internal state affect the complexity of the implementation?\n#### Option 1\n-------\nThe choice of representation for the FSM's internal state does not affect the complexity of the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe choice of representation for the FSM's internal state can affect the complexity of the implementation in a number of ways. For example, if the internal state is represented as a set of Boolean variables, then the number of logic gates required to implement the FSM will be proportional to the number of variables. If the internal state is represented as a set of integers, then the number of logic gates required to implement the FSM will be proportional to the number of bits in each integer. In addition, different representations may require different numbers of flip-flops to store the state information.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe choice of representation for the FSM's internal state can affect the complexity of the implementation.""
 }
]","{
 ""id"": 8
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can semantic knowledge from the abstract model be used to simplify the implementation?\n#### Option 1\n-------\nI'm not sure, but I think it has something to do with the design process.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWe can use semantic knowledge from the abstract model to simplify the implementation by using it to choose a suitable representation for the FSM's internal state. A more intuitive and easier-to-understand representation will typically make the best design in terms of logic complexity.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nBy understanding the meaning of the states and transitions in the abstract model, the implementation can be made more efficient.""
 }
]","{
 ""id"": 9
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a finite state machine?\n#### Option 1\n-------\nA finite state machine is a digital logic circuit that can be in one of a finite number of states. The state of the machine is determined by the values of its inputs and outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA finite state machine is a model of computation that can be used to design digital logic circuits. It consists of a set of states, a set of inputs, and a set of outputs. The machine transitions from one state to another in response to input signals. The output signals are determined by the state that the machine is in.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA finite state machine is a machine that can be in one of a finite number of states.""
 }
]","{
 ""id"": 10
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are some applications of finite state machines?\n#### Option 1\n-------\nFinite state machines are used in a variety of applications, including digital logic design, computer programming, and automata theory.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nOne application of finite state machines is in digital logic design, where they are used to design and implement digital circuits. Another application is in computer programming, where they can be used to model the behavior of programs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nApplications of FSMs include digital logic design, computer programming, and automata theory.""
 }
]","{
 ""id"": 11
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How do you design a finite state machine?\n#### Option 1\n-------\nI'm not sure, but I think you start with a concrete model and then work your way down to an implementation. From there, you can choose how complex you want your design to be.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for a finite state machine generally consists of four steps: \n1) developing an abstract model; \n2) translating the abstract model into a concrete state transition diagram; \n3) implementing functions for the next-state variables and output signals; and \n4) initializing the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nBy working from an abstract model to an implementation, using a series of examples to illustrate design principles.""
 }
]","{
 ""id"": 12
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is an FSM?\n#### Option 1\n-------\nI have no idea what you're talking about.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA finite state machine (FSM) is a model of computation consisting of a finite number of states, transitions between those states, and actions that can be performed in each state. FSMs are often used to design digital logic circuits, such as counters and state machines.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAn FSM is a finite state machine.""
 }
]","{
 ""id"": 13
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the design process for a digital FSM?\n#### Option 1\n-------\nThe design process for a digital FSM is a process of translating a concrete and complete state transition diagram into an implementation based on flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for a digital FSM typically begins with the development of an abstract model. \nThis model is then used to determine the next-state variables and output signals. \nFinally, the design is implemented using flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 }
]","{
 ""id"": 14
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the concrete aspects of implementing an FSM?\n#### Option 1\n-------\nThe concrete aspects of implementing an FSM are the flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe concrete aspects of implementing an FSM include the development of an abstract model, the implementation of functions for the next-state variables and output signals, and the choice of representation for the FSM's internal state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 }
]","{
 ""id"": 15
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a finite state machine?\n#### Option 1\n-------\nA finite state machine is a mathematical model of computation used to design digital logic circuits.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA finite state machine is a mathematical model of computation that defines an abstract machine which can be in one of a finite number of states. The machine is in only one state at a time; the state it is in at any given time is called the current state. It can change from one state to another when initiated by a triggering event or condition; this is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA finite state machine is a system with a finite number of states that can be transition between those states.""
 }
]","{
 ""id"": 16
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are some design principles for implementing a finite state machine?\n#### Option 1\n-------\nThe design process for a digital FSM is simple: just translate a concrete and complete state transition diagram into an implementation based on flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSome design principles for implementing a finite state machine include:\n\n-Developing an abstract model of the FSM\n-Implementing functions for next-state variables and output signals\n-Initializing the FSM (if necessary)\n-Using a multiplexer (if necessary)\n-Choosing an appropriate representation for the internal state""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 }
]","{
 ""id"": 17
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is an example of a counter with multiple inputs to control its behavior?\n#### Option 1\n-------\nThe example of a counter with multiple inputs to control its behavior is the design process as a whole through a more general example of a counter with multiple inputs to control its behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for a digital FSM typically starts with an abstract model. In this example, the abstract model is a counter with multiple inputs to control its behavior. From the abstract model, we can then develop a concrete and complete state transition diagram. This state transition diagram is then used to implement the FSM using flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA counter with multiple inputs to control its behavior is an example of a more general design process.""
 }
]","{
 ""id"": 18
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the design process for a digital FSM?\n#### Option 1\n-------\nThe design process for a digital FSM is a process of translation from a concrete and complete state transition diagram into an implementation based on flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for a digital FSM begins with the development of an abstract model. This model is then used to create functions for the next-state variables and output signals. The design process ends with the implementation of flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for a digital FSM, from the development of an abstract model through the implementation of functions for the next-state variables and output signals.""
 }
]","{
 ""id"": 19
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are some examples of counters?\n#### Option 1\n-------\nsome examples of counters are the abacus, an odometer, and a stopwatch.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nCounters are a type of finite state machine that can be designed to count up or down, or to count in different sequences under the control of external inputs. Counters can be designed with different numbers of states, depending on the application. For example, a two-bit counter can count from 0 to 3 in binary, or from 0 to 9 in decimal. A three-bit counter can count from 0 to 7 in binary, or from 0 to 99 in decimal.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWe implement several counters, which illustrate the basic \nprocess of translating a concrete and complete state transition diagram\ninto an implementation based on flip-flops and logic gates.""
 }
]","{
 ""id"": 20
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the need for FSM initialization?\n#### Option 1\n-------\nThe need for FSM initialization is to ensure that the FSM starts in a known state. This is especially important when the number of states is not a power of two.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe need for FSM initialization arises when the number of states in the FSM is not a power of two. In this case, it is necessary to provide a mechanism for selecting the initial state of the FSM. This can be done using a multiplexer.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe need for FSM initialization arises when the number of states in a counter is not a power of two.""
 }
]","{
 ""id"": 21
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the design process for a digital FSM work?\n#### Option 1\n-------\nThe design process for a digital FSM is pretty simple. You start with an abstract model, then move on to implementing functions for the next-state variables and output signals. After that, it's just a matter of translating the state transition diagram into an implementation based on flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for a digital FSM typically starts with the development of an abstract model. This model is then used to generate functions for the next-state variables and output signals. The resulting design is then implemented using flip-flops and logic gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for a digital FSM begins with the development of an abstract model, which is then translated into an implementation based on flip-flops and logic gates.""
 }
]","{
 ""id"": 22
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to have an abstract model when designing an FSM?\n#### Option 1\n-------\nBecause it's more intuitive and easier for humans to understand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nHaving an abstract model is important when designing an FSM because it helps to simplify the implementation. By working from an abstract model, designers can make use of semantic knowledge to reduce the number of states and transitions that need to be implemented. This can lead to a simpler and more efficient design.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAn abstract model is important when designing an FSM because it allows for a simpler implementation.""
 }
]","{
 ""id"": 23
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the choice of representation for the FSM's internal state affect the complexity of the implementation?\n#### Option 1\n-------\nIf you choose a more complex representation for the FSM's internal state, it will affect the complexity of the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe choice of representation for the FSM's internal state can affect the complexity of the implementation in a number of ways. For example, if the internal state is represented as a series of flip-flops, then the number of flip-flops required will increase with the number of states in the FSM. Alternatively, if the internal state is represented as a lookup table, then the size of the lookup table will increase with the number of states in the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe choice of representation for the FSM's internal state can affect the complexity of the implementation by making it more difficult for humans to understand.""
 }
]","{
 ""id"": 24
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the six steps in the design process?\n#### Option 1\n-------\nThe six steps in the design process are develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe six steps in the design process are: develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n{develop an abstract model}{step-abs}\n{specify I/O behavior}{step-io}\n{complete the specification}{step-complete}\n{choose a state representation}{step-repn}\n{calculate logic expressions}{step-logic}\n{implement with flip-flops and gates}{step-gates}\\n""
 }
]","{
 ""id"": 25
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 26
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the last step in the design process?\n#### Option 1\n-------\nStep {step-gates}, where we translate our logic expressions into gates and use flip-flops (or registers) to hold the internal state bits of the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe last step in the design process is Step {step-gates}, where we translate our logic expressions into gates and use flip-flops (or registers) to hold the internal state bits of the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nImplementing with flip-flops and gates.""
 }
]","{
 ""id"": 27
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 28
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does Step 2 involve?\n#### Option 1\n-------\nStep 2 involves coming up with a model for the FSM using states and desired behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIn Step 2, we formalize the model by specifying the input and output behavior.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nStep 2 involves specifying I/O behavior.""
 }
]","{
 ""id"": 29
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the final step in the design process?\n#### Option 1\n-------\nThe final step in the design process is to implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStep {step-gates} is the final step in the design process, in which logic expressions are translated into gates and flip-flops (or registers) are used to hold the internal state bits of the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nImplementing with flip-flops and gates.""
 }
]","{
 ""id"": 30
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to have compatible digital systems when developing large digital systems?\n#### Option 1\n-------\nMost problems in developing large digital systems today arise because of incompatibilities when composing two or more separately designed pieces into an integrated system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIt is important to have compatible digital systems when developing large digital systems because incompatibilities can lead to problems when composing two or more separately designed pieces into an integrated system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nMost problems in developing large digital systems occur because of incompatibilities when composing two or more separately designed pieces into an integrated system.""
 }
]","{
 ""id"": 31
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does abstraction simplify the implementation process?\n#### Option 1\n-------\nAbstraction makes the process more manageable by breaking it down into smaller, more manageable pieces.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAbstraction can simplify the implementation process by allowing the designer to focus on the functionality of the system rather than on the details of its implementation. By abstracting away these details, the designer can more easily see how the system should work and can more easily identify errors. Additionally, abstraction can allow for different levels of detail to be considered during different stages of the design process, which can make the overall design process more efficient.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nBy Step {step-logic}, our design is a complete specification in terms of bits, and we need merely derive logic expressions for the next-state variables and the output signals.  This process is no different than for combinational logic, and should already be fairly familiar to you.\\n\\n \nFinally, in Step {step-gates}, we translate our logic expressions into gates and use flip-flops (or registers) to hold the internal state bits of the FSM.  In later notes, we use more complex building blocks when implementing an FSM, building up abstractions in order to simplify the design process in much the same way that we have shown for combinational logic.""
 }
]","{
 ""id"": 32
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it helpful to use a computer to select an internal representation for small designs?\n#### Option 1\n-------\nIt's helpful to use a computer to select an internal representation for small designs because it can help optimize the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIt is helpful to use a computer to select an internal representation for small designs because it can optimize the implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt can help to optimize the implementation.""
 }
]","{
 ""id"": 33
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 34
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does step two entail?\n#### Option 1\n-------\nIn Step {step-io} begins to formalize the model, starting with its\ninput and output behavior.  If we eventually plan to develop an\nimplementation of our FSM as a digital system (which is not the \nonly choice, of course!), all input and output\nmust consist of bits.  Often, input and/or output specifications\nmay need to match other digital systems to which we plan to connect\nour FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nStep two of the design process, specifying I/O behavior, begins to formalize the model by focusing on its input and output behavior. All input and output must be in bits in order to develop an implementation of the FSM as a digital system. Additionally, the input and/or output specifications may need to match other digital systems that the FSM will be connected to.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn Step 2, we formalize the model by translating the human language description into a model with states and desired behavior.""
 }
]","{
 ""id"": 35
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How do you choose a state representation in step four?\n#### Option 1\n-------\nFor small designs, the state representation can be selected by a computer in such a way as to optimize the implementation. However, for large designs, such as the LC-3 instruction set architecture, humans do most of the work by hand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIn Step {step-repn}, we select an internal representation\nfor the bits necessary to encode the state of our FSM.  In practice,\nfor small designs, this representation can be selected by a computer \nin such a way as to optimize the implementation.  However, for large\ndesigns, such as the LC-3 instruction set architecture that we\nstudy later in this class, humans do most of the work by hand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn Step {step-repn}, we select an internal representation\nfor the bits necessary to encode the state of our FSM.""
 }
]","{
 ""id"": 36
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the six steps in the design process?\n#### Option 1\n-------\nThe six steps in the design process are develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe six steps in the design process are: \n1) Develop an abstract model \n2) Specify I/O behavior \n3) Complete the specification \n4) Choose a state representation \n5) Calculate logic expressions \n6) Implement with flip-flops and gates""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe six steps in the design process are: develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 }
]","{
 ""id"": 37
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the first step in the design process?\n#### Option 1\n-------\nThe first step is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\ndeveloping an abstract model""
 }
]","{
 ""id"": 38
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the fourth step in the design process?\n#### Option 1\n-------\nIn Step {step-repn}, we select an internal representation\\nfor the bits necessary to encode the state of our FSM.  In practice,\\nfor small designs, this representation can be selected by a computer \\nin such a way as to optimize the implementation.  However, for large\\ndesigns, such as the LC-3 instruction set architecture that we\\nstudy later in this class, humans do most of the work by hand.\\n')\n\nQuestion: 'What is the fourth step in the design process?'\n\nAnswer: Step four is when we select an internal representation for the bits necessary to encode the state of our FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe fourth step in the design process is to choose a state representation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nChoose a state representation.""
 }
]","{
 ""id"": 39
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to develop an abstract model?\n#### Option 1\n-------\nTo make sure that the design is compatible with other digital systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIn Step {step-abs}, we translate our description in human language into a model with states and desired behavior.  At this stage, we simply try to capture the intent of the description and are not particularly thorough nor exact.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt is important to develop an abstract model to translate the description into a model with states and desired behavior.""
 }
]","{
 ""id"": 40
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does specifying the I/O behavior help formalize the model?\n#### Option 1\n-------\nIt begins to formalize the model by starting with its input and output behavior. This way we can make sure that everything is compatible and will work well together.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nSpecifying the I/O behavior helps formalize the model by making sure that all input and output is in the form of bits. This makes it easier to connect the FSM to other digital systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt begins to formalize the model by translating the description into a model with states and desired behavior.""
 }
]","{
 ""id"": 41
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why might you choose to leave something undecided in the design process?\n#### Option 1\n-------\nYou might choose to leave something undecided in the design process in order to simplify the design with \""don't care\"" entries in the logic formulation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nYou may choose to leave something undecided in the design process in order to simplify the design with \""don't care\"" entries in the logic formulation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn Step {step-complete}, we might choose to leave something undecided in the hope of simplifying the design with ``don't care'' entries in the logic formulation.""
 }
]","{
 ""id"": 42
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 43
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What does step two involve?\n#### Option 1\n-------\nIn Step {step-io} begins to formalize the model, starting with its\ninput and output behavior.  If we eventually plan to develop an\nimplementation of our FSM as a digital system (which is not the \nonly choice, of course!), all input and output\nmust consist of bits.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIn Step {step-io}, we translate our description in human language into a model with states and desired behavior.  At this stage, we \nsimply try to capture the intent of the description and are not\nparticularly thorough nor exact.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn Step 2, we formalize the model, starting with its input and output behavior.""
 }
]","{
 ""id"": 44
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the last step in the design process?\n#### Option 1\n-------\nImplementing with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIn Step {step-gates}, we translate our logic expressions\ninto gates and use flip-flops (or registers) to hold the internal\nstate bits of the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nImplementing with flip-flops and gates.""
 }
]","{
 ""id"": 45
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the six steps in the design process?\n#### Option 1\n-------\nThe six steps in the design process are develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe six steps in the design process are as follows: develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWe follow a six-step process: develop an abstract model, specify I/O behavior, complete the specification, choose a state representation, calculate logic expressions, and implement with flip-flops and gates.""
 }
]","{
 ""id"": 46
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the first step in the design process?\n#### Option 1\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe first step in the design process is to develop an abstract model.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe first step in the design process is to develop an abstract model.""
 }
]","{
 ""id"": 47
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of Step 3 in the design process?\n#### Option 1\n-------\nStep 3 is when we begin to formalize the model, starting with its input and output behavior.  If we eventually plan to develop an implementation of our FSM as a digital system (which is not the only choice, of course!), all input and output must consist of bits.  Often, input and/or output specifications may need to match other digital systems to which we plan to connect our FSM.  In fact, { most problems in developing large digital systems today arise because of incompatibilities when composing two or more separately designed pieces} (or { modules}) into an integrated system.')""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of Step 3 is to complete the specification of the FSM. This includes making any implicit assumptions clear and making any other decisions necessary to the design.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of Step 3 is to complete the specification.""
 }
]","{
 ""id"": 48
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the design process for an FSM differ from the design process of other digital systems?\n#### Option 1\n-------\nThe design process for an FSM is six steps, while the design process for other digital systems is four steps.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe design process for an FSM begins with translating a description into a model with states and desired behavior. Next, the input and output behavior is formalized. Then, the specification is completed and an internal representation for the bits necessary to encode the state of the FSM is selected. After that, logic expressions for the next-state variables and output signals are derived. Finally, the logic expressions are translated into gates and flip-flops are used to hold the internal state bits of the FSM.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe design process for an FSM includes six steps: developing an abstract model, specifying I/O behavior, completing the specification, choosing a state representation, calculating logic expressions, and implementing with flip-flops and gates.""
 }
]","{
 ""id"": 49
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to have compatible input and output specifications when designing an FSM?\n#### Option 1\n-------\nMost problems in developing large digital systems today arise because of incompatibilities when composing two or more separately designed pieces into an integrated system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIt is important to have compatible input and output specifications when designing an FSM because most problems in developing large digital systems today arise because of incompatibilities when composing two or more separately designed pieces into an integrated system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nMost problems in developing large digital systems today arise because of incompatibilities when composing two or more separately designed pieces into an integrated system.""
 }
]","{
 ""id"": 50
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can abstraction be used to simplify the implementation of an FSM?\n#### Option 1\n-------\nMost problems in developing large digital systems today arise because of incompatibilities when composing two or more separately designed pieces (or modules) into an integrated system. By abstracting away the details of the implementation, we can simplify the design process and make it easier to build a correct system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nBy Step {step-logic}, our design is a complete specification in\nterms of bits, and we need merely derive logic expressions for the\nnext-state variables and the output signals.  This process is no\ndifferent than for combinational logic, and should already be fairly \nfamiliar to you.\n\n\n\nHowever, we can use abstraction to simplify the implementation of an FSM by breaking it down into smaller modules that are easier to design and build. For example, we can create a module for each state in the FSM, with each module containing the logic expressions for that state. This will make it easier to verify the correctness of the design and build the final implementation.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nBy Step {step-logic}, our design is a complete specification in terms of bits, and we need merely derive logic expressions for the next-state variables and the output signals.  This process is no different than for combinational logic, and should already be fairly familiar to you.\n\n\n\nFinally, in Step {step-gates}, we translate our logic expressions\ninto gates and use flip-flops (or registers) to hold the internal\nstate bits of the FSM.  In later notes, we use more complex\nbuilding blocks when implementing an FSM, building up abstractions\nin order to simplify the design process in much the same way that\nwe have shown for combinational logic.""
 }
]","{
 ""id"": 51
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is a Gray code?\n#### Option 1\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 }
]","{
 ""id"": 52
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the purpose of a Gray code counter?\n#### Option 1\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Gray code counter is to count bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 }
]","{
 ""id"": 53
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How does a Gray code counter work?\n#### Option 1\n-------\nI'm not entirely sure, but I think it has something to do with the internal state of the FSM?""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit. The inputs to a counter, if any, are typically limited to functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state. A fully-specified transition diagram for a two-bit Gray code counter appears below. With no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle. Based on the transition diagram, we can fill in the K-maps for the next-state values S_1^+ and S_0^+ as shown to the right of the transition diagram, then derive algebraic expressions in the usual way to obtain S_1^+=S_0 and S_0^+={{S_1}}. We then use the next-state logic to develop \nthe implementation shown on the far right, completing our first counter design.')""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWith no inputs, the states simply form a loop, with\\n the counter moving from one state to the next each cycle.""
 }
]","{
 ""id"": 54
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a Gray code?\n#### Option 1\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 }
]","{
 ""id"": 55
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe inputs to a counter, if any, are typically limited to functions\nsuch as starting and stopping the counter, controlling the counting \ndirection, and resetting the counter to a particular state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a type of counter that is used to create a Gray code, which is a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 }
]","{
 ""id"": 56
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a Gray code counter work?\n#### Option 1\n-------\nI'm not sure, but I think it has something to do with the fact that each state in the diagram is marked with the internal state value S_1S_0 (before the ``/'') and the output Z_1Z_0 (after the ``/''), which are always equal for this counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWith no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWith no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle.""
 }
]","{
 ""id"": 57
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a Gray code?\n#### Option 1\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 }
]","{
 ""id"": 58
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 }
]","{
 ""id"": 59
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a Gray code counter work?\n#### Option 1\n-------\nI'm not sure, but I think it has something to do with the color gray.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a type of counter that uses a Gray code, which is a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit. The inputs to a Gray code counter are typically limited to functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state. The states in a Gray code counter simply form a loop, with the counter moving from one state to the next each cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter works by cycling through all bit patterns of a certain length, in which consecutive patterns differ in only one bit.""
 }
]","{
 ""id"": 60
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the inputs to the counter?\n#### Option 1\n-------\nThe inputs to the counter are the starting and stopping of the counter, the control of the counting direction, and resetting the counter to a particular state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe inputs to the counter are limited to functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe inputs to the counter are functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 }
]","{
 ""id"": 61
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the outputs of the counter?\n#### Option 1\n-------\nThe outputs of the counter are the internal state values S_1S_0 and the output Z_1Z_0.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe outputs of the counter are the internal state values S_1S_0 and \nthe output values Z_1Z_0.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe outputs of the counter are Z_1Z_0.""
 }
]","{
 ""id"": 62
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Gray code counter is to count in a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 }
]","{
 ""id"": 63
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a two-bit Gray code counter work?\n#### Option 1\n-------\nI'm not entirely sure, but I think it has something to do with the internal state of the FSM?""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA two-bit Gray code counter cycles through all possible bit patterns of length two, with each consecutive pattern differing in only one bit. The inputs to the counter control functions such as starting and stopping the counter, resetting the counter to a particular state, and controlling the counting direction. The fully-specified transition diagram for a two-bit Gray code counter appears below. With no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle. Each state in the diagram is marked with the internal state value S_1S_0 (before the ``/'') and the output Z_1Z_0 (after the ``/''), which are always equal for this counter. Based on the transition diagram, we can fill in the K-maps for the next-state values S_1^+ and S_0^+ as shown to right of transition diagram, then derive algebraic expressions in usual way to obtain S_1^+=S_0 and S_0^+={{S_1}} .We then use next-state logic to develop implementation shown on far right, completing our first design of acounter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe states simply form a loop, with the counter moving from one state to the next each cycle.""
 }
]","{
 ""id"": 64
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the inputs to a two-bit Gray code counter?\n#### Option 1\n-------\nThe inputs to a two-bit Gray code counter are starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe inputs to a two-bit Gray code counter are typically limited to functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe inputs to a two-bit Gray code counter are functions such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 }
]","{
 ""id"": 65
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the transition diagram for a two-bit Gray code counter?\n#### Option 1\n-------\nThe transition diagram for a two-bit Gray code counter is as follows: S_1^+ = S_0 and S_0^+ = {{S_1}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe transition diagram for a two-bit Gray code counter is as follows: \nS_1S_0/Z_1Z_0\n00/00\n01/01\n10/11\n11/10""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe transition diagram for a two-bit Gray code counter is a loop with the counter moving from one state to the next each cycle.""
 }
]","{
 ""id"": 66
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a Gray code?\n#### Option 1\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 }
]","{
 ""id"": 67
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe purpose of a Gray code counter is to cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a type of counter that uses a Gray code, which is a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit. This type of counter is typically used for applications such as starting and stopping the counter, controlling the counting direction, and resetting the counter to a particular state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 }
]","{
 ""id"": 68
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a Gray code counter work?\n#### Option 1\n-------\nI'm not entirely sure, but I think it has something to do with the internal state of the FSM?""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a type of digital counter that uses a Gray code to generate its output. The main difference between a Gray code counter and other types of digital counters is the way in which the output values are generated. In a Gray code counter, the output values are generated in such a way that consecutive patterns differ in only one bit. This makes it possible to use the internal state of the counter as the output values, which simplifies the design of combinational logic for the outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 }
]","{
 ""id"": 69
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a Gray code?\n#### Option 1\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code is a cycle over all bit patterns of a certain length in which consecutive patterns differ in exactly one bit.""
 }
]","{
 ""id"": 70
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a two-bit Gray code counter?\n#### Option 1\n-------\nThe purpose of a two-bit Gray code counter is to generate a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a two-bit Gray code counter is to cycle through all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nTo generate a cycle over all bit patterns of a certain length in which consecutive patterns differ in only one bit.""
 }
]","{
 ""id"": 71
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the counter move from one state to the next?\n#### Option 1\n-------\nWith no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe counter moves from one state to the next based on the transition diagram. The inputs and outputs of the two-bit Gray code counter are shown on the right side of the transition diagram. The next state expressions for the two-bit Gray code counter are S_1^+=S_0 and S_0^+={{S_1}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe counter moves from one state to the next based on the value of the input. If the input is 0, the counter will move to the next state in the sequence. If the input is 1, the counter will move to the previous state in the sequence.""
 }
]","{
 ""id"": 72
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe purpose of a Gray code counter is to count the number of gray hairs on a person's head.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Gray code counter is to create a sequence of states that loop around, with the counter moving from one state to the next each cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of a Gray code counter is to generate a sequence of binary numbers where only one bit changes at a time.""
 }
]","{
 ""id"": 73
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the benefits of using a Gray code counter over a traditional binary counter?\n#### Option 1\n-------\nThere are a few benefits of using a Gray code counter over a traditional binary counter. First, it is more efficient in terms of the number of states required to represent a given number of bits. Second, it is more resistant to errors due to noise or other sources of interference. Finally, it is easier to implement in hardware.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are a few benefits of using a Gray code counter over a traditional binary counter. First, because the output of a Gray code counter only changes one bit at a time, there is no ambiguity when reading the output. This is particularly important when multiple bits are changing at once, as is often the case in digital systems. Second, Gray code counters are more resistant to errors caused by electrical noise than traditional binary counters. This is due to the fact that only one bit changes at a time in a Gray code counter, whereas multiple bits can change simultaneously in a binary counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nGray code counters only change one bit at a time, so they are less likely to produce errors.""
 }
]","{
 ""id"": 74
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are some of the challenges that come with designing a Gray code counter?\n#### Option 1\n-------\nThe main challenge with designing a Gray code counter is ensuring that the next-state logic equations are correct. Additionally, it is important to order the inputs and outputs in a way that makes sense and is easy to follow.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe main challenge with designing a Gray code counter is the increased complexity of the next-state logic. This is because each state in the diagram is marked with the internal state value S_2S_1S_0 (before \""/\"") and the output Z_2Z_1Z_0 (after \""/\""). As a result, deriving algebraic expressions for the next-state logic becomes more complex. Another challenge is ensuring that the vertical lines carrying the current state values and their inverses back to the next state logic inputs are carefully ordered. This is necessary in order to make it easy for someone to read and check the correctness of the logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe main challenge with designing a Gray code counter is that the next-state logic equations are more complex than for a regular binary counter.""
 }
]","{
 ""id"": 75
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the value of S_2^+?\n#### Option 1\n-------\nS_2^+ is equal to the value of S_2 plus the value of S_0.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_2^+ = S_2S_0 + S_1{{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nS_2^+ = S_2 S_0 + S_1 {{S_0}}""
 }
]","{
 ""id"": 76
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the value of S_1^+?\n#### Option 1\n-------\nS_1^+ = S_2S_0 + S_1S_0""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe value of S_1^+ is {{S_2}} S_0 + S_1 {{S_0}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nS_1^+ = {{S_2}} S_0 + S_1 {{S_0}}""
 }
]","{
 ""id"": 77
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the value of S_0^+?\n#### Option 1\n-------\nS_0^+ = {{S_2}} + S_1\n\nAdding a third bit to a Gray code counter increases design complexity because you have to add more AND gates to the design.\n\nIt is important to order the inputs and outputs of a logic diagram so that it is easy for someone to read and check the correctness of the logic. You can reduce design complexity by identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe value of S_0^+ is {{S_2}} {{S_1}} + S_2 S_1. Adding a third bit to a Gray code counter increases design complexity because the equations for the next-state logic become more complex. It is important to order the inputs and outputs of a logic diagram so that it is easy to read and check the correctness of the logic. You can reduce design complexity by identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nS_0^+ = {{S_2}} {{S_1}} + S_2 S_1""
 }
]","{
 ""id"": 78
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the common term for S_2^+ and S_1^+?\n#### Option 1\n-------\nThe common term for S_2^+ and S_1^+ is S_1{{S_0}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe common term for S_2^+ and S_1^+ is S_1{{S_0}}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nS_1{{S_0}}""
 }
]","{
 ""id"": 79
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many inputs and outputs are in the transition diagram?\n#### Option 1\n-------\nThe transition diagram has three inputs and three outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are three inputs and three outputs in the transition diagram.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nFour inputs and three outputs.""
 }
]","{
 ""id"": 80
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does a fully-specified transition diagram look like?\n#### Option 1\n-------\nA fully-specified transition diagram looks like a bunch of squiggly lines and symbols that no one can understand.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA fully-specified transition diagram includes the internal state value S_2S_1S_0 (before \""/\"") and the output Z_2Z_1Z_0 (after \""/\"").""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA fully-specified transition diagram has states marked with the internal state value S_2S_1S_0 (before ``/'') and the output Z_2Z_1Z_0 (after ``/'').""
 }
]","{
 ""id"": 81
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Gray code counter?\n#### Option 1\n-------\nThe purpose of a Gray code counter is to count the number of gray hairs on a person's head.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a type of digital counter used in electronic \ncircuits. Its main purpose is to reduce the number of errors that can occur \nwhen the digital circuit is switching between states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of a Gray code counter is to simplify the design of the next-state logic by explicitly identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 }
]","{
 ""id"": 82
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the benefits of using a Gray code counter?\n#### Option 1\n-------\nThe main benefit of using a Gray code counter is that it is easy to design and implement.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are several benefits to using a Gray code counter. First, it is easier to design and understand the logic of the counter. Second, the common term in the next-state logic equations is simpler, which reduces design complexity. Finally, the vertical lines carrying state values and their inverses back to next state logic inputs are carefully ordered, making it easier to read and check the correctness of the logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe benefits of using a Gray code counter are that the design complexity is reduced by explicitly identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 }
]","{
 ""id"": 83
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a Gray code counter work?\n#### Option 1\n-------\nI'm not quite sure, but I think it has something to do with the color of the counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code counter is a counter that uses a Gray code as the basis for the state sequence. \n\nA transition diagram for such a counter appears to the right. Each state in the diagram is marked with the internal state value S_2S_1S_0 (before ``/'') and the output Z_2Z_1Z_0 (after ``/''). \n\nBased on the transition diagram, we can fill in the K-maps for the next-state values S_2^+, S_1^+, and S_0^+ as shown to the right, then derive algebraic expressions.  The results are more complex this time. \n\nFor our next-state logic, we obtain: {eqnarray*} S_2^+ &=& S_2 S_0 + S_1 {{S_0}} \\nS_1^+ &=& {{S""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Gray code counter is a 3-bit counter that uses a Gray code as the basis for the state sequence.""
 }
]","{
 ""id"": 84
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does this design enable you to reduce the complexity of the algebraic equations for the next-state logic?\n#### Option 1\n-------\nBy explicitly identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThis design enables you to reduce the complexity of the algebraic equations for the next-state logic by explicitly identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThis design allows you to reduce the complexity of the algebraic equations for the next-state logic by explicitly identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 }
]","{
 ""id"": 85
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the importance of ordering the vertical lines carrying the current state values and their inverses back to the next state logic inputs?\n#### Option 1\n-------\nThe order of the lines carrying the current state values and their inverses back to the next state logic inputs is important because it helps to simplify understanding the diagram. In particular, ordering the lines from left to right (on the left side of the figure) as {{S_0}}S_0{{S_1}}S_1{{S_2}}S_2 makes it easy for someone to read and check the correctness of the logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nOrdering the vertical lines carrying the current state values and their inverses back to the next state logic inputs is important so as to make it easy for someone (including yourself!) to read and check the correctness of the logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nOrdering the vertical lines carrying the current state values and their inverses back to the next state logic inputs makes it easy for someone to read and check the correctness of the logic.""
 }
]","{
 ""id"": 86
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How would a reasonable order make it easy for someone to read and check the correctness of the logic?\n#### Option 1\n-------\nIt would be easy for someone to read and check the correctness of the logic if the vertical lines carrying the current state values and their inverses were back to the next state logic inputs were carefully ordered from left to right (on the left side of the figure) as {{S_0}}S_0{{S_1}}S_1{{S_2}}S_2.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA reasonable order makes it easy for someone to read and check the correctness of the logic by enabling them to see the relationships between the various elements more easily. In the case of the counter's implementation diagram, the vertical lines carrying the current state values and their inverses are ordered from left to right (on the left side of the figure) as {{S_0}}S_0{{S_1}}S_1{{S_2}}S_2. This helps to highlight the relationships between these elements and makes it easier to understand how they all fit together.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nBy ordering the inputs and outputs from left to right, it is easy to see which inputs are being used for each output.""
 }
]","{
 ""id"": 87
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is a Three-Bit Gray Code Counter?\n#### Option 1\n-------\nA Three-Bit Gray Code Counter is a counter that uses a Gray code as the basis for the state sequence.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Three-Bit Gray Code Counter is a digital circuit that counts in Gray code, meaning that only one bit changes value at a time. It has three bits, so it can count from 0 to 7. The counter goes through the following sequence: 000, 001, 011, 010, 110, 111, 101, 100.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA counter that uses a Gray code as the basis for the state sequence.""
 }
]","{
 ""id"": 88
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of a Three-Bit Gray Code Counter?\n#### Option 1\n-------\nThe purpose of a Three-Bit Gray Code Counter is to count from 0 to 7 in binary, with no two adjacent numbers having the same number of 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of a Three-Bit Gray Code Counter is to count from 0 to 7 in binary, using a Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of a Three-Bit Gray Code Counter is to count in binary, with one bit changing at a time.""
 }
]","{
 ""id"": 89
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does a Three-Bit Gray Code Counter work?\n#### Option 1\n-------\nI'm not entirely sure, but I think it has something to do with the internal state value S_2S_1S_0 and the output Z_2Z_1Z_0.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Three-Bit Gray Code Counter moves from one state to the next each cycle. Each state in the diagram is marked with the internal state value S_2S_1S_0 (before ``/'') and the output Z_2Z_1Z_0 (after ``/''). The next-state logic is:\n\n{eqnarray*}\nS_2^+ &=& S_2 S_0 + S_1 {{S_0}} \nS_1^+ &=& {{S_2}} S_0 + S_1 {{S""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA Three-Bit Gray Code Counter uses a Gray code as the basis for the state sequence.""
 }
]","{
 ""id"": 90
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the algebraic expression for S_2^+?\n#### Option 1\n-------\nS_2^+ is equal to S_2S_0 + S_1{{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_2^+ = S_2S_0 + S_1{{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nS_2^+ = S_2 S_0 + S_1 {{S_0}}""
 }
]","{
 ""id"": 91
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the algebraic expression for S_1^+?\n#### Option 1\n-------\nS_1^+ = {{S_2}} S_0 + S_1 {{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_1^+ = {{S_2}} S_0 + S_1 {{S_0}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nS_1^+ = {{S_2}} S_0 + S_1 {{S_0}}""
 }
]","{
 ""id"": 92
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the algebraic expression for S_0^+?\n#### Option 1\n-------\nS_0^+ = S_2 S_1 + S_2 {{S_1}}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nS_0^+ = {{S_2}} {{S_1}} + S_2 S_1""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nS_0^+ = {{S_2}} {{S_1}} + S_2 S_1""
 }
]","{
 ""id"": 93
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the counter move from one state to the next?\n#### Option 1\n-------\nWith no inputs, the states simply form a loop, with the counter moving from one state to the next each cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe counter moves from one state to the next based on the internal state value S_2S_1S_0 (before ``/'') and the output Z_2Z_1Z_0 (after ``/'').""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe counter moves from one state to the next based on the internal state value S_2S_1S_0 and the output Z_2Z_1Z_0.""
 }
]","{
 ""id"": 94
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of using a Gray code basis for the state sequence?\n#### Option 1\n-------\nThe Gray code basis for the state sequence is used to simplify the design complexity by explicitly identifying and making use of common algebraic terms and sub-expressions for different outputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA Gray code basis is used for the state sequence so that only one bit changes at a time. This makes it easy to read and check the correctness of the logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe Gray code basis for the state sequence simplifies the design of the next-state logic.""
 }
]","{
 ""id"": 95
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it important to order the vertical lines carrying the current state values and their inverses back to the next state logic inputs?\n#### Option 1\n-------\nIt's important to order the vertical lines carrying the current state values and their inverses back to the next state logic inputs so that you can easily read and check the correctness of the logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nBy ordering the vertical lines from left to right as {{S_0}}S_0{{S_1}}S_1{{S_2}}S_2, it is easy for someone to read and check the correctness of the logic.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIt is important to order the vertical lines carrying the current state values and their inverses back to the next state logic inputs from left to right (on the left side of the figure) as {{S_0}}S_0{{S_1}}S_1{{S_2}}S_2 so as to make it easy for someone (including yourself!) to read and check the correctness of the logic.""
 }
]","{
 ""id"": 96
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the color mapping for a three-bit RGB encoding system?\n#### Option 1\n-------\nThe color mapping for a three-bit RGB encoding system is that the colors we need to produce as outputs are all unique bit patterns.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe color mapping for a three-bit RGB encoding system is as follows: \n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe color mapping for a three-bit RGB encoding system is shown to the right.""
 }
]","{
 ""id"": 97
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops are needed to create a counter to drive a light through a sequence of colors?\n#### Option 1\n-------\n3""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThree flip-flops are needed to create a counter to drive a light through a sequence of colors.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThree flip-flops are needed.""
 }
]","{
 ""id"": 98
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the desired pattern for the light?\n#### Option 1\n-------\nThe desired pattern is {c|l}\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe desired pattern is {off (black)     yellow     violet     green     blue}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe desired pattern is {off (black) yellow violet green blue}.""
 }
]","{
 ""id"": 99
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops will we need?\n#### Option 1\n-------\nWe will need at least four flip-flops.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAt least three flip-flops will be needed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n3""
 }
]","{
 ""id"": 100
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Given that we need three flip-flops, can the counter's internal state directly be used as our output values?\n#### Option 1\n-------\nNo, we cannot use the counter's internal state directly as our output values.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nYes, the counter's internal state can be used as our output values because the colors we need to produce are all unique bit patterns.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nYes""
 }
]","{
 ""id"": 101
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the fully-specified transition diagram for our color sequencer?\n#### Option 1\n-------\nI don't know, what is it?""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe fully-specified transition diagram for our color sequencer is as follows: \n\n{off (black)     yellow     violet     green     blue}\n\nYou immediately recognize that you merely need a counter with five\nstates.  How many flip-flops will we need?  At least three, since\n_2 (5)=3.  Given that we need three flip-flops, and that the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe states form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB.""
 }
]","{
 ""id"": 102
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops are needed to create a counter to drive a light through a sequence of colors?\n#### Option 1\n-------\nYou need at least three flip-flops.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThree flip-flops are needed to create a counter to drive a light through a sequence of colors.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThree flip-flops are needed.""
 }
]","{
 ""id"": 103
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of using a three-bit red-green-blue encoding for colors?\n#### Option 1\n-------\nThe purpose of using a three-bit red-green-blue encoding for colors is to create a counter to drive a light through a sequence of colors.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nEarly graphics systems used a three-bit red-green-blue (RGB) encoding for colors. The color mapping for such a system is shown to the right.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of using a three-bit red-green-blue encoding for colors is to create a counter to drive a light through a sequence of colors.""
 }
]","{
 ""id"": 104
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the desired pattern for the light?\n#### Option 1\n-------\nThe desired pattern is for the light to be off (black), then yellow, violet, green, and blue.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n{off (black)     yellow     violet     green     blue}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe desired pattern is {off (black) yellow violet green blue}.""
 }
]","{
 ""id"": 105
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the color mapping for a three-bit RGB encoding system?\n#### Option 1\n-------\nThe color mapping for a three-bit RGB encoding system is black, blue, green, cyan, red, violet, yellow, and white.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe color mapping for a three-bit RGB encoding system is as follows:\n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe color mapping for a three-bit RGB encoding system is shown to the right.""
 }
]","{
 ""id"": 106
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops are needed to create a counter to drive a light through a sequence of colors?\n#### Option 1\n-------\nYou need at least three flip-flops.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAt least three flip-flops are needed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThree flip-flops are needed.""
 }
]","{
 ""id"": 107
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the desired pattern for the light?\n#### Option 1\n-------\nThe desired pattern is black, blue, green, cyan, red, violet, yellow, and white.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe color mapping for a three-bit RGB encoding system is shown to the right. The light takes an RGB input as just described, and the desired pattern is {off (black) yellow violet green blue}. You immediately recognize that you merely need a counter with five states. Given that we need three flip-flops, and that the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe desired pattern is {off (black) yellow violet green blue}.""
 }
]","{
 ""id"": 108
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the color mapping work for a three-bit RGB system?\n#### Option 1\n-------\nI'm not sure, but I think you just need a counter with five states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe color mapping for a three-bit RGB system encodes colors as follows:\n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe color mapping for a three-bit RGB system is as follows: RGB 000 is black, RGB 001 is blue, RGB 010 is green, RGB 011 is cyan, RGB 100 is red, RGB 101 is violet, RGB 110 is yellow, andRGB 111 is white.""
 }
]","{
 ""id"": 109
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why is it necessary to use at least three flip-flops?\n#### Option 1\n-------\nBecause the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nIt is necessary to use at least three flip-flops because the colors we need to produce as outputs are all unique bit patterns.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nBecause the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values.""
 }
]","{
 ""id"": 110
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many states are in the loop for the fully-specified transition diagram?\n#### Option 1\n-------\nThere are four states in the loop for the fully-specified transition diagram.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are eight states in the loop for the fully-specified transition diagram.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThere are 5 states in the loop for the fully-specified transition diagram.""
 }
]","{
 ""id"": 111
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the color mapping for a three-bit red-green-blue encoding system?\n#### Option 1\n-------\nThe color mapping for a three-bit red-green-blue encoding system is as follows:\n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe color mapping for a three-bit red-green-blue encoding system is as follows:\n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nRGB color mapping is 000=black, 001=blue, 010=green, 011=cyan, 100=red, 101=violet, 110=yellow, 111=white.""
 }
]","{
 ""id"": 112
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops are needed to create a counter that drives a light through a sequence of colors?\n#### Option 1\n-------\nYou need at least three flip-flops.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThree flip-flops are needed to create a counter that drives a light through a sequence of colors.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThree flip-flops are needed.""
 }
]","{
 ""id"": 113
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the transition diagram for a fully-specified color sequencer?\n#### Option 1\n-------\nThe transition diagram for a fully-specified color sequencer is shown to the right. The states again form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe transition diagram for a fully-specified color sequencer is shown to the right. The states form a loop, and are marked with the internal state value S_2S_1S_0 and the output RGB.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe transition diagram for a fully-specified color sequencer is a loop of states that are marked with the internal state value S_2S_1S_0 and the output RGB.""
 }
]","{
 ""id"": 114
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the color mapping for a three-bit RGB encoding system?\n#### Option 1\n-------\nThe color mapping for a three-bit RGB encoding system is black, blue, green, cyan, red, violet, yellow, and white.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe color mapping for a three-bit RGB encoding system is as follows:\n\nRGB& color \n000& black\n001& blue\n010& green\n011& cyan\n100& red\n101& violet\n110& yellow\n111& white""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe color mapping for a three-bit RGB encoding system is shown to the right.""
 }
]","{
 ""id"": 115
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the desired pattern for the light?\n#### Option 1\n-------\nThe desired pattern is for the light to take an RGB input and output a black, blue, green, cyan, red, violet, yellow, or white light.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe light takes an RGB input as just described, and the desired pattern is\n\n{off (black)     yellow     violet     green     blue}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n{off (black)     yellow     violet     green     blue}""
 }
]","{
 ""id"": 116
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many flip-flops are needed to create a counter to drive the light through a sequence of colors?\n#### Option 1\n-------\nAt least three, since _2 (5)=3.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nAt least three flip-flops are needed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nAt least three flip-flops are needed.""
 }
]","{
 ""id"": 117
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why does the system need at least three flip-flops?\n#### Option 1\n-------\nThe system needs at least three flip-flops because the colors we need to produce as outputs are all unique bit patterns.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe system needs at least three flip-flops because the colors we need to produce as outputs are all unique bit patterns.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nBecause the colors we need to produce as outputs are all unique bit patterns, we can again choose to use the counter's internal state directly as our output values.""
 }
]","{
 ""id"": 118
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many states are in the loop?\n#### Option 1\n-------\nThere are three states in the loop.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are five states in the loop.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n5""
 }
]","{
 ""id"": 119
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does the 'x' mean in the K-map?\n#### Option 1\n-------\nThe 'x' means that the bit doesn't matter and can be a 0 or 1.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe 'x' in the K-map indicates a \""don't care\"" condition. This means that the output will be the same regardless of whether the input is a 0 or a 1.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n\""The 'x' in the K-map means 'don't care.'\""""
 }
]","{
 ""id"": 120
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\n{ The initial state may not even be 0s and 1s unless we have an \\nexplicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization.""
 }
]","{
 ""id"": 121
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nOne way the FSM can get into unexpected states is if the initial state of the three flip-flops is not properly set. The initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization. Initialization can work in two ways.  The first approach makes use of the flip-flop design. As you know, a flip-flop is built from a pair of latches, and we can make use of the internal reset lines on these latches to force each flip-flop into the 0 state (or the 1 state) using an additional input. Alternatively, we can add some extra logic to our design. Consider adding a few AND gates and a  input (active low), as shown in the dashed box in the figure to the right. In this case, when we assert  by setting it to 0,the FSM moves to state 000 in the next cycle, putting it into the BLACK state. The approach taken here is for clarity; one can optimize the design, if desired. For example, we could simply connect  as an extra input into the three AND gates on t he left rather than adding new ones, with then same effect.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 }
]","{
 ""id"": 122
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nPlugging into the equations or looking into the K-maps gives (of\\n course) the same answer: the next state is the\\n S_2^+S_1^+S_0^+=111 state.\\n In other words, the light stays white indefinitely!')\n\nQuestion :  What could be going wrong?', '\\n \nAnswer: We can extend the transition diagram that we developed for our design\\n with the extra states possible in the implementation, as shown below.\\n As with the five states in the design, the extra states are named with\\n the color of light that they produce.')""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 }
]","{
 ""id"": 123
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops is 0s and 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n{ The initial state may not even be 0s and 1s unless we have an \nexplicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization.""
 }
]","{
 ""id"": 124
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nWhat is the initial state of the three flip-flops in our implementation?\\n\n\n{ The initial state may not even be 0s and 1s unless we have an \\nexplicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWhat is the initial state of the three flip-flops in our implementation?\\n\n{ The initial state may not even be 0s and 1s unless we have an \\nexplicit mechanism for initialization.} \\n\nInitialization can work in two ways.  \\n\nThe first approach makes use of the flip-flop design.\\n\nAs you know, a flip-flop is built from a pair of latches, and\\n\nwe can \\nmake use of the internal reset lines on these latches\\n\nto force each flip-flop into the 0 state (or the 1 state) using an\\n\nadditional input. \\n\nAlternatively, we can add some extra logic to our design.\\n""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 }
]","{
 ""id"": 125
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nPlugging into the equations or looking into the K-maps gives (of\\n \ncourse) the same answer: the next state is the\\n \nS_2^+S_1^+S_0^+=111 state.\\n \nIn other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nPlugging into the equations or looking into the K-maps gives (of course) the same answer: the next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 }
]","{
 ""id"": 126
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why does the light sometimes glow cyan or red briefly before turning white?\n#### Option 1\n-------\nI'm not sure, let's try to understand. We begin by deriving K-maps for the implementation, as shown to the right. In these K-maps, each of the x's in our design has been replaced by either a 0 or a 1. These entries are highlighted with green italics.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe answer to this question can be found by understanding what could happen if the FSM got into the S_2S_1S_0=111 state. In such a state, the light would appear white, since RGB=S_2S_1S_0=111. What happens in the next cycle? Plugging into the equations or looking into the K-maps gives (of course) the same answer: The next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely! As an exercise, you should check what happens if the light is red or cyan.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nOne possible reason is that the FSM is getting into unexpected states.""
 }
]","{
 ""id"": 127
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is not even 0s and 1s unless we have an explicit mechanism for initialization.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM can get into the unexpected states if the initial state of the three flip-flops is not 0s and 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM's initial state may not be 0s and 1s unless we have an explicit mechanism for initialization.""
 }
]","{
 ""id"": 128
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops is 0s and 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe three flip-flops in our implementation have an undefined initial state. This means that they could be in any state, including the unexpected states. To avoid this, we need to add a mechanism for initialization. This can be done by adding a few AND gates and an INIT input (active low). When we assert INIT by setting it to 0, the FSM moves to state 000 in the next cycle, putting it into the BLACK state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops is unknown.""
 }
]","{
 ""id"": 129
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\n{ The initial state may not even be 0s and 1s unless we have an \\nexplicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n{The initial state may not even be 0s and 1s unless we have an \\nexplicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops is unknown unless we have an explicit mechanism for initialization.""
 }
]","{
 ""id"": 130
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe initial state of the three flip-flops in our implementation is the 0 state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state of the three flip-flops in our implementation is not even 0s and 1s unless we have an explicit mechanism for initialization. \nInitialization can work in two ways. The first approach makes use of the flip-flop design. As you know, a flip-flop is built from a pair of latches, and we can make use of the internal reset lines on these latches to force each flip-flop into the 0 state (or the 1 state) using an additional input. Alternatively, we can add some extra logic to our design. Consider adding a few AND gates and an INIT input (active low), as shown in the dashed box in the figure to the right. In this case, when we assert INIT by setting it to 0, the FSM moves to state 000 in the next cycle, putting it into Black state. The approach taken here is for clarity; one can optimize the design, if desired. For example, we could simply connect INIT as an extra input into the three AND gates on \nthe left rather than adding new ones, with same effect.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 }
]","{
 ""id"": 131
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nThe FSM stays in the same state, producing a white light.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nPlugging into the equations or looking into the K-maps gives (of course) the same answer: the next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 }
]","{
 ""id"": 132
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops is 0.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n{ The initial state may not even be 0s and 1s unless we have an \\nexplicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops is unknown and may not be 0s and 1s.""
 }
]","{
 ""id"": 133
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nThe FSM can get into the unexpected states if the initial state of the three flip-flops is not 0s and 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state of the three flip-flops in our implementation is unknown. The FSM can get into unexpected states if the initial state is not 0s and 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 }
]","{
 ""id"": 134
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nPlugging into the equations or looking into the K-maps gives (of course) the same answer: the next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely! \\n \\n As an exercise, you should check what happens if the light is red or cyan.'""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nPlugging into the equations or looking into the K-maps gives (of\ncourse) the same answer: the next state is the\nS_2^+S_1^+S_0^+=111 state.\nIn other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 }
]","{
 ""id"": 135
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does the FSM move out of the WHITE state?\n#### Option 1\n-------\nThe FSM does not move out of the WHITE state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM does not move out of the WHITE state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM does not move out of the WHITE state.""
 }
]","{
 ""id"": 136
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\n{ The initial state may not even be 0s and 1s unless we have an \\nexplicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n{ The initial state may not even be 0s and 1s unless we have an \\nexplicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops is unknown unless we have an explicit mechanism for initialization.""
 }
]","{
 ""id"": 137
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can we make use of the internal reset lines on these latches to force each flip-flop into the 0 state?\n#### Option 1\n-------\nWe can add a few AND gates and a  input (active low), as shown in the dashed box in the figure. In this case, when we assert  by setting it to 0, the FSM moves to state 000 in the next cycle, putting it into the BLACK state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nWe can use the internal reset lines on the latches to force each flip-flop into the 0 state by adding an additional input.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nBy adding an extra input and initializing it to 0, the FSM moves to state 000 in the next cycle, putting it into the BLACK state.""
 }
]","{
 ""id"": 138
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops is 0s and 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n{ The initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization.""
 }
]","{
 ""id"": 139
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nWhat is the initial state of the three flip-flops in our implementation?\\n\n\n{ The initial state may not even be 0s and 1s unless we have an \\nexplicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM can get into the unexpected states if the initial state of the three flip-flops is not properly set.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 }
]","{
 ""id"": 140
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.  In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state.""
 }
]","{
 ""id"": 141
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops is 0s and 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n{The initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state may not even be 0s and 1s unless we have an explicit mechanism for initialization.""
 }
]","{
 ""id"": 142
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nWhat is the initial state of the three flip-flops in our implementation?\\n \n{ The initial state may not even be 0s and 1s unless we have an \\nexplicit mechanism for initialization.}""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nOne possibility is that the flip-flops in the FSM are not properly initialized. \nEach flip-flop has an internal reset line that can be used to force the flip-flop into the 0 state (or the 1 state). \nAlternatively, we can add some extra logic to our design that will allow us to initialize the FSM into any specific state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nInitialization can work in two ways. The first approach makes use of the flip-flop design. As you know, a flip-flop is built from a pair of latches, and we can make use of the internal reset lines on these latches to force each flip-flop into the 0 state (or the 1 state) using an additional input. Alternatively, we can add some extra logic to our design.""
 }
]","{
 ""id"": 143
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What happens in the next cycle?\n#### Option 1\n-------\nPlugging into the equations or looking into the K-maps gives (of\\n course) the same answer: the next state is the\\n S_2^+S_1^+S_0^+=111 state.\\n In other words, the light stays white indefinitely!\\n \\n As an exercise, you should check what happens \\n if the light is red or cyan.'""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nPlugging into the equations or looking into the K-maps gives (of course) the same answer: the next state is the S_2^+S_1^+S_0^+=111 state. In other words, the light stays white indefinitely!""
 }
]","{
 ""id"": 144
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" Why does the light sometimes glow cyan or red briefly before turning white?\n#### Option 1\n-------\nThe light is briefly glows cyan or red because the FSM is in an unexpected state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe most likely explanation is that the FSM is getting into one of the unexpected states due to incorrect initialization. As we can see from the transition diagram, if the FSM is in state 111 (WHITE), it will stay there indefinitely. However, if it is in any other state, it will eventually move into state 111. Thus, if the FSM is incorrectly initialized and starts off in a state other than 111, it will briefly glow cyan or red before eventually settling into the WHITE state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM is in an unexpected state.""
 }
]","{
 ""id"": 145
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How can the FSM ever get into the unexpected states?\n#### Option 1\n-------\nIt can't.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe FSM can get into the unexpected states if the initial state of the three flip-flops is not properly set.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops in our implementation is unknown, so the FSM could get into any state.""
 }
]","{
 ""id"": 146
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the initial state of the three flip-flops in our implementation?\n#### Option 1\n-------\nThe initial state of the three flip-flops is 0s and 1s.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe initial state of the three flip-flops in our implementation is unknown.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe initial state of the three flip-flops is undefined.""
 }
]","{
 ""id"": 147
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of an abstract model?\n#### Option 1\n-------\nThe purpose of an abstract model is to provide a simplified representation of a system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of an abstract model is to provide a simplified representation of a system. Abstract models are often used to design and analyze complex systems.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of an abstract model is to provide a simplified representation of a system.""
 }
]","{
 ""id"": 148
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are some design choices that were made in this context?\n#### Option 1\n-------\nThe table contains two states, counting and halted, and specifies that the design uses two distinct buttons to move between the states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA few design choices were made in this context. First, the counter retains the current state of the system when \""halt\"" is pressed. Second, the counter is designed to stop when the user presses \""halt\"" and to resume counting when the user presses \""go.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA choice was made to have the counter retain its current state when ``halt'' is pressed, and to design the counter to stop when the user presses ``halt'' and resume counting when the user presses ``go.''""
 }
]","{
 ""id"": 149
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between a next-state table and a transition diagram?\n#### Option 1\n-------\nA next-state table lists the states, while each of the other columns lists\nstates to which the FSM transitions after a clock cycle for a particular\ninput combination. A transition diagram provides\nexactly the same information in graphical form.  Here circles represent\nstates (as labeled) and arcs represent transitions from one state\nto another based on an input combination (which is used to label the\narc).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe primary difference between a next-state table and a transition diagram is that a next-state table lists the states, while each of the other columns lists states to which the FSM transitions after a clock cycle for a particular input combination. A transition diagram, on the other hand, provides exactly the same information in graphical form with circles representing states (as labeled) and arcs representing transitions from one state to another based on an input combination (which is used to label the arc).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA next-state table lists the states, while each of the other columns lists states to which the FSM transitions after a clock cycle for a particular input combination. A transition diagram provides exactly the same information in graphical form, with circles representing states (as labeled) and arcs representing transitions from one state to another based on an input combination (which is used to label the arc).""
 }
]","{
 ""id"": 150
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of an FSM?\n#### Option 1\n-------\nThe purpose of an FSM is to design a counter that can be stopped and started.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of an FSM is to model the behaviour of a system. In this case, the FSM models the behaviour of a two-bit Gray code counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of an FSM is to model the behavior of a system.""
 }
]","{
 ""id"": 151
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the inputs and outputs of an FSM?\n#### Option 1\n-------\nThe inputs and outputs of an FSM are the states and transitions between those states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe inputs to an FSM are the current state and the current input. The output of an FSM is the next state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe inputs to an FSM are the current state and the current input. The output is the next state.""
 }
]","{
 ""id"": 152
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the states of an FSM?\n#### Option 1\n-------\nQuestion :  What are the states of an FSM?\n\nAnswer : The states of an FSM represent the different conditions that the system can be in. In this example, there are four counting states and four halted states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are four counting states and four halted states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe FSM has four counting states and four halted states.""
 }
]","{
 ""id"": 153
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the difference between 'counting' and 'halted' states?\n#### Option 1\n-------\nThey are two distinct states in which the FSM can be.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe 'counting' state represents uninterrupted counting, in which the counter cycles through these states indefinitely. A user can stop the counter in any state by pressing the ``halt'' button, causing the counter to retain its current value until the user presses the ``go'' button. The 'halted' state represents when a user has pressed the ``halt'' button, and the counter is not counting.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nIn the 'counting' state, the counter cycles through four states indefinitely, while in the 'halted' state, the counter retains its current value.""
 }
]","{
 ""id"": 154
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How many states are in the second version of the table?\n#### Option 1\n-------\nThere are four states in the second version of the table.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe second version of the table has four counting states and four halted states, for a total of eight states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n16""
 }
]","{
 ""id"": 155
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does pressing the 'halt' button do when the counter is in a 'halted' state?\n#### Option 1\n-------\nIn this form of the table,\nthe first column lists the states, while each of the other columns lists\nstates to which the FSM transitions after a clock cycle for a particular\ninput combination. \n\nThe table contains two states, counting and halted, and specifies\nthat the design uses two distinct buttons to move between the\nstates.\nThe table further implies that if the counter is halted,\nthe ``halt'' button has no additional effect, and if the counter\nis counting, the ``go'' button has no additional effect.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nPressing the 'halt' button when the counter is in a 'halted' state has no effect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nPressing the 'halt' button has no effect when the counter is in a 'halted' state.""
 }
]","{
 ""id"": 156
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the two states in the first column of the table?\n#### Option 1\n-------\nThe first column lists the states, while each of the other columns lists\nstates to which the FSM transitions after a clock cycle for a particular\ninput combination.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe two states in the first column of the table are counting and halted.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe two states are counting and halted.""
 }
]","{
 ""id"": 157
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the four counting states?\n#### Option 1\n-------\nThe four counting states are { COUNT A}, { COUNT B}, { COUNT C}, and { HALT D}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n{ COUNT A}, { COUNT B}, { COUNT C}, and { COUNT D}.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n{ COUNT A}, { COUNT B}, { COUNT C}, and { COUNT D}.""
 }
]","{
 ""id"": 158
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of the ``halt'' button?\n#### Option 1\n-------\n\""The halt button is used to stop the counter.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe ``halt'' button is used to stop the counter. If the counter is halted, the ``halt'' button has no additional effect. The table implies that if the user presses the ``halt'' button, the counter will retain its current value until the user presses the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nTo stop and start the counter.""
 }
]","{
 ""id"": 159
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of an FSM?\n#### Option 1\n-------\nThe purpose of an FSM is to design a counter that can be stopped and started by a user.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of an FSM is to model the behavior of a system. In this case, the FSM models the behavior of a two-bit Gray code counter. The FSM has two states, counting and halted, and uses two distinct buttons to move between the states. If the counter is halted, the \""halt\"" button has no additional effect, and if the counter is counting, the \""go\"" button has no additional effect.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of an FSM is to model the behavior of a system.""
 }
]","{
 ""id"": 160
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the benefits of using an FSM?\n#### Option 1\n-------\nThe benefits of using an FSM are that it is easy to design and implement, and that it is easy to understand the behavior of the system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are several benefits of using an FSM: \n\n1. FSMs are easy to design and understand. This is because they operate on a simple principle of transition from one state to another in response to an input. \n2. FSMs are easy to implement in hardware. This is because they can be represented by a small number of logic gates, which makes them efficient in terms of space and resources. \n3. FSMs are versatile and can be used to model a wide variety of systems. For example, FSMs can be used to model digital circuits, communication protocols, and computer programs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nFSMs provide a simple, abstract way to model sequential circuits.""
 }
]","{
 ""id"": 161
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" How does an FSM work?\n#### Option 1\n-------\nI'm not sure, but I think it has something to do with the state of the machine.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA finite state machine (FSM) is a mathematical model of computation used to design both computer programs and sequential logic circuits. It is conceived as an abstract machine that can be in one of a finite number of user-specified states. An FSM is defined by a list of its states, its initial state, and the conditions for each transition.'""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA counter with a single counting state, of course, does not provide\nmuch value.  We extend the table with four counting states and four\nhalted states, as shown to the right.  This version of the\ntable also introduces more formal state names, for which these notes \nuse all capital letters.""
 }
]","{
 ""id"": 162
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the purpose of an FSM?\n#### Option 1\n-------\nThe purpose of an FSM is to provide a mechanism for stopping and starting a counter.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe purpose of an FSM is to design a system that can be in one of a finite number of states and that can move from one state to another in response to some inputs.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe purpose of an FSM is to model the behavior of a system.""
 }
]","{
 ""id"": 163
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the inputs and outputs of an FSM?\n#### Option 1\n-------\nThe inputs and outputs of an FSM are the states and transitions between those states.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThere are two inputs to an FSM: the current state of the system and the input signal. The output of an FSM is the next state of the system.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe inputs to an FSM are the current state and the current input. The output is the next state.""
 }
]","{
 ""id"": 164
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the states of an FSM?\n#### Option 1\n-------\n[ 'Q: What are the states of an FSM?', '\\nThe states of an FSM are counting and halted.\\nQ: How does the counter know when to stop and start again?\\nThe counter knows when to stop and start again by pressing the ``halt'' button.\\nQ: What is the purpose of the two different buttons?\\nThe purpose of the two different buttons is to move between the states.\\nQ: What would happen if the user pressed both buttons at the same time?']""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe states of an FSM are represented by the states in the state table. The counter knows when to stop and start again based on the input from the buttons. The purpose of the two different buttons is to provide a way to control the counter. If the user pressed both buttons at the same time, the counter would either stop or start, depending on its current state.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe states of an FSM are counting and halted.""
 }
]","{
 ""id"": 165
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the two control buttons?\n#### Option 1\n-------\nThe two control buttons are the ``halt'' button and the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe two control buttons are the ``halt'' button and the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe ``halt'' button is H, and the ``go'' button is G.""
 }
]","{
 ""id"": 166
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does a two-bit Gray code represent?\n#### Option 1\n-------\nA two-bit Gray code represents the input and output behavior of a digital design.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA two-bit Gray code is a binary code where each successive value differs in only one bit.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA two-bit Gray code represents two distinct values.""
 }
]","{
 ""id"": 167
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the uninterrupted counting cycle labeled with?\n#### Option 1\n-------\nThe uninterrupted counting cycle is labeled with to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe uninterrupted counting cycle is labeled with to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\n'to indicate that it continues until we press H.\""""
 }
]","{
 ""id"": 168
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the input behavior?\n#### Option 1\n-------\nThe input behavior is to provide a single bit of input for each control button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe input behavior is that each of the two control buttons provides a single bit of input. The ``halt'' button we call H, and the ``go'' button we call G.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nEach of the two control buttons provides a single bit of input.""
 }
]","{
 ""id"": 169
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the output behavior?\n#### Option 1\n-------\nThe output behavior is that the machine outputs a two-bit Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe output behavior is a two-bit Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe output is a two-bit Gray code.""
 }
]","{
 ""id"": 170
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What do the buttons 'halt' and 'go' do?\n#### Option 1\n-------\n\""The 'halt' button makes the machine stop and the 'go' button makes it start again.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\n\""The 'halt' button halts the cycle and the 'go' button restarts it.\""""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe \""halt\"" button H and the \""go\"" button G provide input for a two-bit Gray code output.""
 }
]","{
 ""id"": 171
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""Why use a two-bit Gray code for the output?\n#### Option 1\n-------\nI don't know.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe two-bit Gray code is used for the output because it allows for the states to be marked with output values Z_1Z_0. Additionally, the transition arcs are labeled in terms of the two input buttons, G and H. This makes it easier to understand the diagram and follow the counting cycle.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWith a two-bit Gray code, we can redraw the transition diagram as show to the right.""
 }
]","{
 ""id"": 172
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""How does this choice of output allow us to redraw the transition diagram?\n#### Option 1\n-------\nWith these choices, we can redraw the transition diagram as show to the right.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe output allows us to redraw the transition diagram because it provides a two-bit Gray code. With this code, we can label the states with output values and transition arcs with the input buttons.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nWith these choices, we can redraw the transition diagram as show to the right.""
 }
]","{
 ""id"": 173
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the significance of labeling the uninterrupted counting cycle with ?\n#### Option 1\n-------\nThe significance of labeling the uninterrupted counting cycle with is that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe significance of labeling the uninterrupted counting cycle with is to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe uninterrupted counting cycle continues until the halt button is pressed.""
 }
]","{
 ""id"": 174
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What are the two control buttons?\n#### Option 1\n-------\nThe two control buttons are H and G.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe two control buttons are the ``halt'' button and the ``go'' button.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe \""halt\"" button is H, and the \""go\"" button is G.""
 }
]","{
 ""id"": 175
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What does a two-bit Gray code represent?\n#### Option 1\n-------\nA two-bit Gray code is a code that represents two-bit numbers in a way that only one bit changes between successive numbers.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nA two-bit Gray code is a binary code used to represent numbers in which adjacent values differ in only one bit. For example, the numbers 0, 1, 2, and 3 can be represented as 00, 01, 11, and 10.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nA two-bit Gray code is a code that represents two-bit numbers in a way that only one bit changes between successive numbers.""
 }
]","{
 ""id"": 176
}"
"[
 {
  ""type"": ""text"",
  ""content"": ""What is the uninterrupted counting cycle labeled with?\n#### Option 1\n-------\nThe uninterrupted counting cycle is labeled with to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe uninterrupted counting cycle is labeled with to indicate that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nto indicate that it continues until we press H.""
 }
]","{
 ""id"": 177
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What are the two input buttons?\n#### Option 1\n-------\nThe two input buttons are H and G.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nHalt (H) and Go (G).""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe ``halt'' button (H) and the ``go'' button (G).""
 }
]","{
 ""id"": 178
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What is the output behavior?\n#### Option 1\n-------\nThe output behavior is that when you press the \""halt\"" button, it outputs a two-bit gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe output behavior is a two-bit Gray code.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe output is a two-bit Gray code.""
 }
]","{
 ""id"": 179
}"
"[
 {
  ""type"": ""text"",
  ""content"": "" What does the uninterrupted counting cycle label mean?\n#### Option 1\n-------\nThe uninterrupted counting cycle label means that it continues until we press H.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 2\n-------\nThe uninterrupted counting cycle label means that the cycle continues until the H button is pressed.""
 },
 {
  ""type"": ""text"",
  ""content"": ""#### Option 3\n-------\nThe uninterrupted counting cycle is an infinite loop that continues until the H button is pressed.""
 }
]","{
 ""id"": 180
}"
