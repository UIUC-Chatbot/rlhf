{"chapter":{"0":"The Halting Problem","1":"The 2's Complement Representation","2":"The 2's Complement Representation","3":"The 2's Complement Representation","4":"Deriving 2's Complement","5":"Overflow for Unsigned Addition","6":"Overflow for 2's Complement Addition","7":"Logic Operations","8":"Logic Operations","9":"Logic Operations","10":"Logic Operations","11":"Truth Tables","12":"Logical Completeness","13":"Data Types","14":"Variable Declarations","15":"Variable Declarations","16":"Expressions and Operators","17":"Expressions and Operators","18":"Expressions and Operators","19":"Expressions and Operators","20":"Basic I\/O","21":"Basic I\/O","22":"Basic I\/O","23":"Basic I\/O","24":"Types of Statements in C","25":"Defining Optimality","26":"Terminology","27":"Terminology","28":"Two-Level Logic","29":"Logic Properties","30":"Caring about Don't Cares","31":"Example: Bit-Sliced Addition","32":"Registers","33":"Registers","34":"Shift Registers","35":"Ripple Counters","36":"Memory","37":"Tri-State Buffers and Combining Chips"},"prompt":{"0":"What is the Halting Problem?","1":"Explain the 2's Complement Representation","2":"What are Boolean expressions? ","3":"Why are Boolean expressions useful?","4":"How do you convert a given decimal number into its 2's complement representation:","5":"When does an overflow occur for unsigned addition","6":"When does an overflow occur for 2's complement addition","7":"What does the logical \u201cAND\u201d do?","8":"What does the logical \u201cOR\u201d do?","9":"What does the logical \u201cNOT\u201d do?","10":"What does the logical \u201cXOR\u201d do?","11":"How to create a truth table?","12":"What does logical completeness mean?","13":"What are the various variable types in C?","14":"How do you declare a variable in C","15":"When to declare a variable in C?","16":"What is the assignment operator?","17":"What are the arithmetic operators in C?","18":"What are relational operators in C?","19":"What are logical operators in C?","20":"What are I\/O statements?","21":"How do we use printf?","22":"How do we use scanf?","23":"What are the common escape sequences or placeholders we need to know for I\/O functions in C?","24":"What types of statements are there in C?","25":"What is an optimal expression and why would I use it over the original expression?","26":"What is a literal?","27":"What is a Sum of Products?","28":"How do I easily convert from POS to SOP form and vice versa?","29":"What is a Dual Form and what function do they serve?","30":"What are the dangers of using don't cares in our next state design implementation, for real world systems?","31":"What is the difference between a half adder and a full adder?","32":"What is parallel loading?","33":"What is a register and why do we use them?","34":"What is the difference between arithmetic and logical right shift?","35":"What are the benefits and drawbacks of using ripple counters over synchronous counters?","36":"How can we connect smaller chips (smaller address space and\/or addressability) to form larger and more powerful RAMS?","37":"What is a tri-state buffer and where is it used?"},"completion":{"0":"The halting problem is a classic problem in computer science that asks whether it is possible to determine, in a general and systematic way, whether a given computer program will eventually halt (terminate) or run forever. Fundamentally it's impossible to know if any give piece of code will get stuck in an infinite loop. \n\nThe problem was first introduced by Alan Turing in the 1930s as part of his work on the foundations of computer science and theoretical computation. Turing proved that there is no algorithmic solution to the halting problem that can work for all possible computer programs.\n\nThe halting problem tells us that there is no general algorithm that can solve this problem for all possible values of x. \n\nHere's example code to demonstrate undecidability:\n1: read x from input\n2: while x is even:\n3:     x = x \/ 2\n4: if x == 1:\n5:     print \"halted\"\n6: else:\n7:     print \"did not halt\"\n\nIn industry, it highlights the difficulty of reasoning about the behavior of complex software systems, and the potential for bugs and unexpected behavior due to the inherent unpredictability of certain program constructs.\n\nAre there work arounds to avoid the Halting Problem? \nOf course, for particular domains, you can make assumptions that allow tools to notice some, but not all, halting problems.\n\nOne such technique is to use program analysis tools that can perform static analysis of the code to detect potential infinite loops or other sources of non-termination. \n\nAnother approach is to use heuristics or statistical methods to estimate the likelihood of termination based on patterns in the program's behavior or in the values of its variables. For example, if a program appears to be making progress towards a specific goal or if its variables are converging towards certain values, it may be more likely to terminate than if it is stuck in a loop or its variables are oscillating wildly.\n\nHowever, few to zero techniques are foolproof, especially as assumptions break down in complex systems.\nThe halting problem is a classic problem in computer science that asks whether it is possible to determine, in a general and systematic way, whether a given computer program will eventually halt (terminate) or run forever. Fundamentally it's impossible to know if any give piece of code will get stuck in an infinite loop. \n\nThe problem was first introduced by Alan Turing in the 1930s as part of his work on the foundations of computer science and theoretical computation. Turing proved that there is no algorithmic solution to the halting problem that can work for all possible computer programs.\n\nThe halting problem tells us that there is no general algorithm that can solve this problem for all possible values of x. \n\nHere's example code to demonstrate undecidability:\n1: read x from input\n2: while x is even:\n3:     x = x \/ 2\n4: if x == 1:\n5:     print \"halted\"\n6: else:\n7:     print \"did not halt\"\n\nIn industry, it highlights the difficulty of reasoning about the behavior of complex software systems, and the potential for bugs and unexpected behavior due to the inherent unpredictability of certain program constructs.\n\nAre there work arounds to avoid the Halting Problem? \nOf course, for particular domains, you can make assumptions that allow tools to notice some, but not all, halting problems.\n\nOne such technique is to use program analysis tools that can perform static analysis of the code to detect potential infinite loops or other sources of non-termination. \n\nAnother approach is to use heuristics or statistical methods to estimate the likelihood of termination based on patterns in the program's behavior or in the values of its variables. For example, if a program appears to be making progress towards a specific goal or if its variables are converging towards certain values, it may be more likely to terminate than if it is stuck in a loop or its variables are oscillating wildly.\n\nHowever, few to zero techniques are foolproof, especially as assumptions break down in complex systems.","1":"The 2's complement representation is a way of representing both positive and negative integers using binary digits (bits). In this system, the most significant bit (the leftmost bit) is used as a sign bit, where 0 represents a positive number and 1 represents a negative number.\n\nTo obtain the 2's complement representation of a negative integer, we take the binary representation of the positive integer that corresponds to its absolute value, then invert (flip) all of its bits, and finally add 1 to the result. For example, to find the 2's complement of -3 using 4 bits, we take the binary representation of 3, which is 0011, invert all of its bits to get 1100, and add 1 to obtain 1101, which is the 2's complement representation of -3.\n\nAccording to Steven Lumetta, to master these topics you should be able to represent decimal numbers with unsigned, 2's complement, and IEEE floating-point representations, and be able to calculate the decimal value represented by a bit pattern in any of these representations.\n\nOne important property of the 2's complement representation is that the range of representable integers is asymmetric. In an n-bit representation, the largest representable positive integer is 2^(n-1) - 1, while the largest representable negative integer is -2^(n-1). This means that the negative range includes one more integer than the positive range, because 0 is considered positive in this system. This property can cause issues when performing arithmetic with integers near the edges of the representable range.\n\nIt's always important to consider \u201coverflow\u201d when representing numbers, so be sure to handle overflow when using these numbers. \n\nTo practice these topics, Lumetta suggests writing Boolean expressions for the overflow conditions on both unsigned and 2's complement addition. Also, you should understand the tradeoffs between integer and floating-point representations for numbers.\nThe 2's complement representation is a way of representing both positive and negative integers using binary digits (bits). In this system, the most significant bit (the leftmost bit) is used as a sign bit, where 0 represents a positive number and 1 represents a negative number.\n\nTo obtain the 2's complement representation of a negative integer, we take the binary representation of the positive integer that corresponds to its absolute value, then invert (flip) all of its bits, and finally add 1 to the result. For example, to find the 2's complement of -3 using 4 bits, we take the binary representation of 3, which is 0011, invert all of its bits to get 1100, and add 1 to obtain 1101, which is the 2's complement representation of -3.\n\nAccording to Steven Lumetta, to master these topics you should be able to represent decimal numbers with unsigned, 2's complement, and IEEE floating-point representations, and be able to calculate the decimal value represented by a bit pattern in any of these representations.\n\nOne important property of the 2's complement representation is that the range of representable integers is asymmetric. In an n-bit representation, the largest representable positive integer is 2^(n-1) - 1, while the largest representable negative integer is -2^(n-1). This means that the negative range includes one more integer than the positive range, because 0 is considered positive in this system. This property can cause issues when performing arithmetic with integers near the edges of the representable range.\n\nIt's always important to consider \u201coverflow\u201d when representing numbers, so be sure to handle overflow when using these numbers. \n\nTo practice these topics, Lumetta suggests writing Boolean expressions for the overflow conditions on both unsigned and 2's complement addition. Also, you should understand the tradeoffs between integer and floating-point representations for numbers.","2":"In computer science, Boolean expressions are used to express logical conditions in programming languages, such as \"if\" statements, \"while\" loops, and \"for\" loops. These expressions typically use logical operators, such as AND, OR, and NOT, to combine one or more Boolean values or expressions.\n\nFor example, a simple Boolean expression might be \"5 > 3\", which evaluates to true, since 5 is indeed greater than 3. Another example might be \"x < 10 AND y > 20\", which evaluates to true if x is less than 10 and y is greater than 20. A third example might be \"NOT (a OR b)\", which evaluates to true if neither a nor b is true.\n\nBoolean expressions are an essential tool for programming, as they allow programmers to write code that can make decisions and take different actions based on different conditions.\n\nAccording to Steven Lumetta, to master these topics you should be able to:\n1. Be able to write a truth table for a Boolean expression.\n2. Be able to write a Boolean expression as a sum of minterms.\n3. Write Boolean expressions for the overflow conditions on both unsigned and 2's complement addition.\nIn computer science, Boolean expressions are used to express logical conditions in programming languages, such as \"if\" statements, \"while\" loops, and \"for\" loops. These expressions typically use logical operators, such as AND, OR, and NOT, to combine one or more Boolean values or expressions.\n\nFor example, a simple Boolean expression might be \"5 > 3\", which evaluates to true, since 5 is indeed greater than 3. Another example might be \"x < 10 AND y > 20\", which evaluates to true if x is less than 10 and y is greater than 20. A third example might be \"NOT (a OR b)\", which evaluates to true if neither a nor b is true.\n\nBoolean expressions are an essential tool for programming, as they allow programmers to write code that can make decisions and take different actions based on different conditions.\n\nAccording to Steven Lumetta, to master these topics you should be able to:\n1. Be able to write a truth table for a Boolean expression.\n2. Be able to write a Boolean expression as a sum of minterms.\n3. Write Boolean expressions for the overflow conditions on both unsigned and 2's complement addition.","3":"Boolean expressions are an essential tool for programming, as they allow programmers to write code that can make decisions and take different actions based on different conditions.\n\n1. Control flow\n2. Checking program correctness, such as with assert statements.\n3. Data validation\n4. Optimization, by reducing the number of operations required if a condition is met.\n\nIn summary, Boolean expressions are useful in computer science because they provide a versatile and powerful way to represent logical conditions, which are essential for control flow, program correctness, data validation, testing, and optimization.\nBoolean expressions are an essential tool for programming, as they allow programmers to write code that can make decisions and take different actions based on different conditions.\n\n1. Control flow\n2. Checking program correctness, such as with assert statements.\n3. Data validation\n4. Optimization, by reducing the number of operations required if a condition is met.\n\nIn summary, Boolean expressions are useful in computer science because they provide a versatile and powerful way to represent logical conditions, which are essential for control flow, program correctness, data validation, testing, and optimization.","4":"Take the decimal number and write out the bit representation as you would for any decimal. If the original decimal given is positive, this is all you need to do.\nIf the given decimal number is negative, flip all the bits such that 1s become 0s and 0s become 1s. Subsequently, add 1 to this bit sequence to obtain the final 2s complement representation.\nTake the decimal number and write out the bit representation as you would for any decimal. If the original decimal given is positive, this is all you need to do.\nIf the given decimal number is negative, flip all the bits such that 1s become 0s and 0s become 1s. Subsequently, add 1 to this bit sequence to obtain the final 2s complement representation.","5":"Determining overflow for unsigned addition is a relatively straightforward process. After adding together two bit strings, if we observe that there is a carryout beyond the most significant bit, we say there is an overflow.\nDetermining overflow for unsigned addition is a relatively straightforward process. After adding together two bit strings, if we observe that there is a carryout beyond the most significant bit, we say there is an overflow.","6":"If adding together all positive or all negative bit strings, we know the output should be the same sign as the inputs. The fastest way to tell for an overflow is by comparing the MSB. If multiple positive bit strings  (represented by MSB = 0) or multiple negative bit strings are added (MSB = 1), and the resulting output produces the opposite MSB, we can tell there is an overflow.\nFor inputs which are not strictly all positive or all strictly negative, we can tell if there is an overflow by adding two of the terms together and seeing if there is an overflow, and repeating.\nIf adding together all positive or all negative bit strings, we know the output should be the same sign as the inputs. The fastest way to tell for an overflow is by comparing the MSB. If multiple positive bit strings  (represented by MSB = 0) or multiple negative bit strings are added (MSB = 1), and the resulting output produces the opposite MSB, we can tell there is an overflow.\nFor inputs which are not strictly all positive or all strictly negative, we can tell if there is an overflow by adding two of the terms together and seeing if there is an overflow, and repeating.","7":"The logical \u201cAND\u201d compares N bits. If all N bits are a 1, the output is a 1. For any other case, the output is a 0. \nThe logical \u201cAND\u201d compares N bits. If all N bits are a 1, the output is a 1. For any other case, the output is a 0. ","8":"The logical \u201cOR\u201d compares N bits. If there is at least a 1 appearing once or multiple times, the output is a 1. Else, the output is a 0.\nThe logical \u201cOR\u201d compares N bits. If there is at least a 1 appearing once or multiple times, the output is a 1. Else, the output is a 0.","9":"The logical \u201cNOT\u201d operator flips the bits, such that a 1 becomes a 0 and a 0 becomes a 1\nThe logical \u201cNOT\u201d operator flips the bits, such that a 1 becomes a 0 and a 0 becomes a 1","10":"The logical \u201cXOR\u201d compares N bits, and produces output 1 if there are an odd number of 1s, and produces a 0 if there are an even number of 1s or none at all.\nThe logical \u201cXOR\u201d compares N bits, and produces output 1 if there are an odd number of 1s, and produces a 0 if there are an even number of 1s or none at all.","11":"Step 1: Determine the number of input variables, assigning them variables such as x,y,z etc\nStep 2: Create possible input combinations. For example, if we have two input variables there are 4 combinations, if we have 3 input variables there are 8 combinations. Generally, there are 2^n input combinations possible for n input variables\nStep 3: Use the given logic equation in the question, to determine the output(s) for each of the input combinations, filling them in the truth table.\nStep 1: Determine the number of input variables, assigning them variables such as x,y,z etc\nStep 2: Create possible input combinations. For example, if we have two input variables there are 4 combinations, if we have 3 input variables there are 8 combinations. Generally, there are 2^n input combinations possible for n input variables\nStep 3: Use the given logic equation in the question, to determine the output(s) for each of the input combinations, filling them in the truth table.","12":"In layman terms, logical completeness means being able to express any form of logical expression using the given terms. For the purposes of ECE120, the set {AND,NOT,OR} is logically complete - meaning you can express any boolean logical expression in terms of just these three functions. {NAND} and {NOR} are also logically complete sets, which can be proved by using each set to construct AND, NOT and NOR separately.\nIn layman terms, logical completeness means being able to express any form of logical expression using the given terms. For the purposes of ECE120, the set {AND,NOT,OR} is logically complete - meaning you can express any boolean logical expression in terms of just these three functions. {NAND} and {NOR} are also logically complete sets, which can be proved by using each set to construct AND, NOT and NOR separately.","13":"C supports four basic data types: integers, characters, floating point numbers, and boolean values. Variables of these types can be created with the type specifiers int, char, float (or double), and _Bool (or bool)\nInt: data value represents an integer\nChar: data value represents a character\nfloat\/double: data value represents a single\/double precision float number\nBool: data with either 1 to represent true, and 0 to represent false (not relevant to ECE 120)\nC supports four basic data types: integers, characters, floating point numbers, and boolean values. Variables of these types can be created with the type specifiers int, char, float (or double), and _Bool (or bool)\nInt: data value represents an integer\nChar: data value represents a character\nfloat\/double: data value represents a single\/double precision float number\nBool: data with either 1 to represent true, and 0 to represent false (not relevant to ECE 120)","14":"To declare a variable, use the following syntax by declaring the variable type before assigning a value to it if needed. Examples are listed below for different data type.\nint x = 3;        \/\/ assigns a value 3 to the integer data type variable x\nchar lock;    \/\/ creates a char data type lock without assigning a value to it yet\nchar key = 'Q';    \/\/creates a char data type key and assigns the character \u201cQ\u201d to it\nfloat a;      \/\/ creates a single precision floating number data type variable a\ndouble b;     \/\/ creates a double precision floating number data type variable a\nTo declare a variable, use the following syntax by declaring the variable type before assigning a value to it if needed. Examples are listed below for different data type.\nint x = 3;        \/\/ assigns a value 3 to the integer data type variable x\nchar lock;    \/\/ creates a char data type lock without assigning a value to it yet\nchar key = 'Q';    \/\/creates a char data type key and assigns the character \u201cQ\u201d to it\nfloat a;      \/\/ creates a single precision floating number data type variable a\ndouble b;     \/\/ creates a double precision floating number data type variable a","15":"Any variable that needs to be used in a block of code or a function in C needs to be declared before it is used. This includes variables used to store values, temporary variables such as counters, and variables that might be used for printing. \nAny variable that needs to be used in a block of code or a function in C needs to be declared before it is used. This includes variables used to store values, temporary variables such as counters, and variables that might be used for printing. ","16":"The assignment operator is used when we want to assign a value into a variable, such that the variable holds that value and we can call back on it in other statements whenever we want. We use a SINGLE equal to sign for this. For example, I want to assign the number 5 to the variable temp_counter:\n\nint temp_counter = 5;  \/\/ assigns 5 to a declared integer straightaway OR\nint temp_counter; \nTemp_counter = 5;\n\/\/ declares an integer first, and then assigns the value in a different step\nThe assignment operator is used when we want to assign a value into a variable, such that the variable holds that value and we can call back on it in other statements whenever we want. We use a SINGLE equal to sign for this. For example, I want to assign the number 5 to the variable temp_counter:\n\nint temp_counter = 5;  \/\/ assigns 5 to a declared integer straightaway OR\nint temp_counter; \nTemp_counter = 5;\n\/\/ declares an integer first, and then assigns the value in a different step","17":"The different arithmetic operators in C are listed below:\n\nFor addition: +\nExample line of code : a = x + y;\n\nFor subtraction: - \nExample line of code : a = x-y; \n\nFor multiplication: * \nExample line of code : a = x*y \n\nFor division(returns the quotient): \/\nExample line of code : a = x\/y \n\nFor division(returns the remainder): %\nExample line of code : a = x%y \n\nWhat is the order of arithmetic operation in C?\nWe prioritize parenthesis, then multiplication\/division, and then addition\/subtraction. For example, given the code:\nint result = (a+b)*x + y;\n\/\/ step 1: (a+b)\n\/\/ step 2: (a+b)*y\n\/\/ step 3: (a+b)*y + x;\nThe different arithmetic operators in C are listed below:\n\nFor addition: +\nExample line of code : a = x + y;\n\nFor subtraction: - \nExample line of code : a = x-y; \n\nFor multiplication: * \nExample line of code : a = x*y \n\nFor division(returns the quotient): \/\nExample line of code : a = x\/y \n\nFor division(returns the remainder): %\nExample line of code : a = x%y \n\nWhat is the order of arithmetic operation in C?\nWe prioritize parenthesis, then multiplication\/division, and then addition\/subtraction. For example, given the code:\nint result = (a+b)*x + y;\n\/\/ step 1: (a+b)\n\/\/ step 2: (a+b)*y\n\/\/ step 3: (a+b)*y + x;","18":"Relational operators are used to check if a statement is valid, and usually used in a conditional statement.\na > b : used to check if a is greater than b\na >= b : used to check if a is greater than or equal to\na < b : used to check if a is smaller than b\na <= b : used to check if a is smaller than or equal to b\na == b: used to check if a is equal to b\na != b; used to check if a is not equal to b\nRelational operators are used to check if a statement is valid, and usually used in a conditional statement.\na > b : used to check if a is greater than b\na >= b : used to check if a is greater than or equal to\na < b : used to check if a is smaller than b\na <= b : used to check if a is smaller than or equal to b\na == b: used to check if a is equal to b\na != b; used to check if a is not equal to b","19":"Logical operators are a set of operators used to check for the validity of a statement or multiple statements in C, usually used in an if statement:\n\nLogical NOT: Checks if a variable if not equal to a value, returning true if so\nRepresented by !\nCode: if(x !); \/\/ returns true only if statement is valid\n\nLogical AND: Checks if multiple statements are all valid, returning true only if all of them are valid.\nRepresented by: &&\nCode: if(x==3 && y==2);  \/\/ returns true only if both statements valid\n\nLogical OR: Checks if any one of multiple statements is valid, returning true if so:\nRepresented by: ||\nCode: if(x==2 || y == 3 || z == 1); \/\/ returns true as long as one of the three statements are valid\nLogical operators are a set of operators used to check for the validity of a statement or multiple statements in C, usually used in an if statement:\n\nLogical NOT: Checks if a variable if not equal to a value, returning true if so\nRepresented by !\nCode: if(x !); \/\/ returns true only if statement is valid\n\nLogical AND: Checks if multiple statements are all valid, returning true only if all of them are valid.\nRepresented by: &&\nCode: if(x==3 && y==2);  \/\/ returns true only if both statements valid\n\nLogical OR: Checks if any one of multiple statements is valid, returning true if so:\nRepresented by: ||\nCode: if(x==2 || y == 3 || z == 1); \/\/ returns true as long as one of the three statements are valid","20":"I\/O stands for input\/output statements. For ECE120, input refers to when a number or string is inputted into a program, via a keyboard, and output refers to when the program prints a string or numbers onto the screen. These can be done in both C and LC3, using different commands.\nI\/O stands for input\/output statements. For ECE120, input refers to when a number or string is inputted into a program, via a keyboard, and output refers to when the program prints a string or numbers onto the screen. These can be done in both C and LC3, using different commands.","21":"There are two ways to use printf. The first is to print the contents of a single variable to the screen, in which case we can use \u201cprintf(value);\u201d , if value has already been defined in the program. \nIf we wish to print a combination of variables in the form of a particular sentence, we can use the form \u201cprintf(\u201c%d %d\u201d,var1,var2);\u201d where %d is a placeholder for var1, which we wish to insert into the string before it is printed onto the screen. The placeholder is often referred to as an escape sequence, and differs according to the type of the variable. For more information, read page 23 of Lumetta's notes.\nThere are two ways to use printf. The first is to print the contents of a single variable to the screen, in which case we can use \u201cprintf(value);\u201d , if value has already been defined in the program. \nIf we wish to print a combination of variables in the form of a particular sentence, we can use the form \u201cprintf(\u201c%d %d\u201d,var1,var2);\u201d where %d is a placeholder for var1, which we wish to insert into the string before it is printed onto the screen. The placeholder is often referred to as an escape sequence, and differs according to the type of the variable. For more information, read page 23 of Lumetta's notes.","22":"Scanf works very similarly to printf, the only difference being that when we enter the variable name, we need to insert an ampersand before it. For example, if we intend to read in two integers that separated by a space, we would use the statement \u201cscanf(\u201c%d %d\u201d,&num1,&num2);\u201d . For more information, read page 23 of Lumetta's notes.\nScanf works very similarly to printf, the only difference being that when we enter the variable name, we need to insert an ampersand before it. For example, if we intend to read in two integers that separated by a space, we would use the statement \u201cscanf(\u201c%d %d\u201d,&num1,&num2);\u201d . For more information, read page 23 of Lumetta's notes.","23":"For ECE120, the important ones to know are that %c is for characters, %d for integers, %f for floats, %lf for doubles and %u for unsigned integers. Page 23 of Lumetta's notes contains a table encapsulating this information.\nFor ECE120, the important ones to know are that %c is for characters, %d for integers, %f for floats, %lf for doubles and %u for unsigned integers. Page 23 of Lumetta's notes contains a table encapsulating this information.","24":"For the purposes of ECE120, there are three types of statements - sequential, conditional and iterative. Sequential steps refer to steps performed one after another, like a numbered set of instructions. In ECE120 this will mostly refer to printf() and scanf() functions.\n\nConditional steps refer to when a program branches into two paths, and the path taken depends on whether a condition is satisfied or not. This is represented by \u201cif-else\u201d statements in C.\n\nIterative steps refer to a certain step being repeated for a fixed number of times, or until a certain condition is satisfied. This is represented by a \u201cfor-loop\u201d block in C.\nFor the purposes of ECE120, there are three types of statements - sequential, conditional and iterative. Sequential steps refer to steps performed one after another, like a numbered set of instructions. In ECE120 this will mostly refer to printf() and scanf() functions.\n\nConditional steps refer to when a program branches into two paths, and the path taken depends on whether a condition is satisfied or not. This is represented by \u201cif-else\u201d statements in C.\n\nIterative steps refer to a certain step being repeated for a fixed number of times, or until a certain condition is satisfied. This is represented by a \u201cfor-loop\u201d block in C.","25":"If you were to make truth tables for an optimized expression and the original expression, you would see that they are the same. An optimized expression is a simplified version of the original logic expression. Functionally, it is identical to the original logic expression, but it requires fewer logic gates\/operations to implement since it has less terms.\nIf you were to make truth tables for an optimized expression and the original expression, you would see that they are the same. An optimized expression is a simplified version of the original logic expression. Functionally, it is identical to the original logic expression, but it requires fewer logic gates\/operations to implement since it has less terms.","26":"A literal in terms of a logical expression refers to the Boolean variables or the complement of a Boolean variable. They are the fundamental parts of a logical expression and they are often used to construct more complex Boolean expressions through logical operators like AND, OR, and NOT.\nA literal in terms of a logical expression refers to the Boolean variables or the complement of a Boolean variable. They are the fundamental parts of a logical expression and they are often used to construct more complex Boolean expressions through logical operators like AND, OR, and NOT.","27":"Sum of Products (often abbreviated as SOP) is a type of Boolean function that represents a logical function as a sum of products term, where each product term is the logical AND of one or more literals. Basically, it is the sum of several terms, each of which is the product of literals.\nSum of Products (often abbreviated as SOP) is a type of Boolean function that represents a logical function as a sum of products term, where each product term is the logical AND of one or more literals. Basically, it is the sum of several terms, each of which is the product of literals.","28":"The quickest way to convert from POS to SOP is to use DeMorgans law twice. \nGiven the expression F = xy' + yz' in SOP form, we first take DeMorgans law to get F'\nF' = (xy' + yz')'\n   = (xy')'(yz')'\n   = (x'+y)(y'+z)\n   = x'y' + x'z + yy' + yz\n   = x'y' + x'z + yz\nWe then take DeMorgan's law again\nF'' = (x'y'+x'z+yz)'\n     =(x'y')'(x'z)'(yz)'\n     =(x+y)(x+z')(y'+z')\n     =(x+y)(y'+z')\n     = F (POS form)\nThe quickest way to convert from POS to SOP is to use DeMorgans law twice. \nGiven the expression F = xy' + yz' in SOP form, we first take DeMorgans law to get F'\nF' = (xy' + yz')'\n   = (xy')'(yz')'\n   = (x'+y)(y'+z)\n   = x'y' + x'z + yy' + yz\n   = x'y' + x'z + yz\nWe then take DeMorgan's law again\nF'' = (x'y'+x'z+yz)'\n     =(x'y')'(x'z)'(yz)'\n     =(x+y)(x+z')(y'+z')\n     =(x+y)(y'+z')\n     = F (POS form)","29":"Every boolean expression has its own dual form. To derive the dual form of a boolean expression, replace all the 1s with 0s in the expression, all the 0s with 1s, all the ANDs with ORs, and ORs with ANDs. The variables themselves remain unchanged. The dual of a dual expression simply returns the original expression. Dual forms are used for CMOS gate designs, where the NMOS gate logic will be the dual of the PMOS gate logic. More information can be found on page 44 of Lumetta's notes.\nEvery boolean expression has its own dual form. To derive the dual form of a boolean expression, replace all the 1s with 0s in the expression, all the 0s with 1s, all the ANDs with ORs, and ORs with ANDs. The variables themselves remain unchanged. The dual of a dual expression simply returns the original expression. Dual forms are used for CMOS gate designs, where the NMOS gate logic will be the dual of the PMOS gate logic. More information can be found on page 44 of Lumetta's notes.","30":"If our machine falls into an unexpected state (when restarting\/initializing the machine, for example), it could end up behaving unexpectedly and failing. Page 46 of Lumetta's notes gives an example for such a situation. Using don't cares for the ice cream vending machine FSM simplifies the logic circuit, but it does not account for cases such as when multiple buttons are pressed at the same time, in which case causing the cup to overflow. \nIf our machine falls into an unexpected state (when restarting\/initializing the machine, for example), it could end up behaving unexpectedly and failing. Page 46 of Lumetta's notes gives an example for such a situation. Using don't cares for the ice cream vending machine FSM simplifies the logic circuit, but it does not account for cases such as when multiple buttons are pressed at the same time, in which case causing the cup to overflow. ","31":"A half adder only has two input bits while a full adder has 3 input bits. A full adder is especially useful for bit-sliced addition of two numbers, as you can use a bit for each number followed by another bit for the carry over sum from the previous iteration (similar to how we carry over one when adding numbers by hand and one column produces a sum greater than 10). Both the half adder and the full adder have two output bits each, one is the sum output and the other is the carry output.\nA half adder only has two input bits while a full adder has 3 input bits. A full adder is especially useful for bit-sliced addition of two numbers, as you can use a bit for each number followed by another bit for the carry over sum from the previous iteration (similar to how we carry over one when adding numbers by hand and one column produces a sum greater than 10). Both the half adder and the full adder have two output bits each, one is the sum output and the other is the carry output.","32":"Parallel Loading refers to using one input line per bit (and flip-flop) to load a multi-bit register with an entirely new number in a single clock cycle. Each flip-flop is simultaneously loaded with a new bit in the same cycle, hence the term \u201cparallel\u201d loading. For more information read page 73 of Lumetta's notes.\nParallel Loading refers to using one input line per bit (and flip-flop) to load a multi-bit register with an entirely new number in a single clock cycle. Each flip-flop is simultaneously loaded with a new bit in the same cycle, hence the term \u201cparallel\u201d loading. For more information read page 73 of Lumetta's notes.","33":"A register is a storage element comprising multiple flip-flops that operate in the same clock cycle. A register is used for storing larger chunks of data, as a flip-flop can only store a single bit at any one time. For more details read page 73 of Lumetta's notes.\nA register is a storage element comprising multiple flip-flops that operate in the same clock cycle. A register is used for storing larger chunks of data, as a flip-flop can only store a single bit at any one time. For more details read page 73 of Lumetta's notes.","34":"Logical right shift treats the bits as an unsigned number, and all the bits shift right by one number while 0 is stored in the most significant bit. Arithmetic right shift treats the bits as a signed number in two's complement, and all the bits shift right by one number while the most significant bit remains the same as what it was before. Both right shift operations are analogous to dividing the number by two. More information can be found on page 75 of Lumetta's notes.\nLogical right shift treats the bits as an unsigned number, and all the bits shift right by one number while 0 is stored in the most significant bit. Arithmetic right shift treats the bits as a signed number in two's complement, and all the bits shift right by one number while the most significant bit remains the same as what it was before. Both right shift operations are analogous to dividing the number by two. More information can be found on page 75 of Lumetta's notes.","35":"Ripple counters consume less energy than synchronous counters, and are more appropriate for devices with limited energy supplies. However, there is a delay inherent to the structure of ripple counters, and ensuring the timing delay does not make such a design unreliable is a significant drawback.\nRipple counters consume less energy than synchronous counters, and are more appropriate for devices with limited energy supplies. However, there is a delay inherent to the structure of ripple counters, and ensuring the timing delay does not make such a design unreliable is a significant drawback.","36":"This can be achieved by splitting the data lines and address lines that are meant for a larger RAM, into smaller lines that can go into smaller chips.\nFor example, if we want to build a 64Kx16 RAM from two 64Kx8 chips, we just need to split the 16 bit data line intended for the bigger RAM into two - one for each 64Kx8 chip. Typically, bits 0-7 from the dataline will go into one chip while bits 8-15 go into the other chip. The rest of the connections will be identical for both smaller chips.\nThis can be achieved by splitting the data lines and address lines that are meant for a larger RAM, into smaller lines that can go into smaller chips.\nFor example, if we want to build a 64Kx16 RAM from two 64Kx8 chips, we just need to split the 16 bit data line intended for the bigger RAM into two - one for each 64Kx8 chip. Typically, bits 0-7 from the dataline will go into one chip while bits 8-15 go into the other chip. The rest of the connections will be identical for both smaller chips.","37":"The tri-state buffer serves to disconnect an electronic component from the output line when it is not being used and we do not want to read its output. It is prominent in the LC3 datapath, where we only want one device sending an output signal onto the bus. To prevent all other components from sending signals at the same time, each component is controlled by a tri-state buffer, and at most only one of the buffers is \u201cturned on\u201d at any one time.\nThe tri-state buffer serves to disconnect an electronic component from the output line when it is not being used and we do not want to read its output. It is prominent in the LC3 datapath, where we only want one device sending an output signal onto the bus. To prevent all other components from sending signals at the same time, each component is controlled by a tri-state buffer, and at most only one of the buffers is \u201cturned on\u201d at any one time."}}